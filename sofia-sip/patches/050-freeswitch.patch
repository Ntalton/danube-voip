diff -ur a/configure.ac b/configure.ac
--- a/configure.ac	2011-03-11 16:49:18.000000000 +0200
+++ b/configure.ac	2017-12-07 23:25:58.868834655 +0200
@@ -118,10 +118,16 @@
 AM_CONDITIONAL(HAVE_CHECK, test x"$have_check" = "xyes")
 if test x"$have_check" = "xyes"; then
    AC_DEFINE([HAVE_CHECK], 1, [Define to 1 if check library is available])
-   SAC_NEW_TCASE_ADD_TEST
 fi
 AC_CHECK_HEADERS([fnmatch.h])
 
+AC_CHECK_LIB(pthread, pthread_setschedparam, [AC_DEFINE(HAVE_PTHREAD_SETSCHEDPARAM, 1, [Define if you have pthread_setschedparam()])])
+AC_CHECK_LIB(z, compress, [have_zlib=yes],[have_zlib=no])
+if test x"$have_zlib" = "xyes"; then
+   AC_DEFINE(HAVE_ZLIB_COMPRESS, 1, [Define if you have zlib compress])
+fi
+AM_CONDITIONAL([HAVE_ZLIB], [test "x$have_zlib" = xyes])
+
 dnl dl is currently used only in testing
 AC_CHECK_LIB([dl], [dlopen], [
    dnl Note: -ldl is not added to LIBS
@@ -287,7 +293,7 @@
 AC_C_CONST
 AC_C_INLINE
 AC_C_INLINE_DEFINE
-AC_C_BIGENDIAN
+AC_C_BIGENDIAN(AC_DEFINE([SWITCH_BYTE_ORDER],__BIG_ENDIAN,[Big Endian]),AC_DEFINE([SWITCH_BYTE_ORDER],__LITTLE_ENDIAN,[Little Endian]))
 
 AC_C_VAR_FUNC
 AC_C_MACRO_FUNCTION
Only in b: configure.gnu
Only in b/libsofia-sip-ua/http: headers
diff -ur a/libsofia-sip-ua/http/http_basic.c b/libsofia-sip-ua/http/http_basic.c
--- a/libsofia-sip-ua/http/http_basic.c	2011-03-11 16:49:18.000000000 +0200
+++ b/libsofia-sip-ua/http/http_basic.c	2017-12-07 23:25:59.060835696 +0200
@@ -1465,6 +1465,38 @@
 HTTP_HEADER_CLASS_LIST(upgrade, "Upgrade", list_critical);
 
 /* ====================================================================== */
+/**@HTTP_HEADER http_sec_websocket_key Sec-WebSocket-Key header. */
+
+#define http_sec_websocket_key_d msg_generic_d
+#define http_sec_websocket_key_e msg_generic_e
+msg_hclass_t http_sec_websocket_key_class[] =
+HTTP_HEADER_CLASS_G(sec_websocket_key, "Sec-WebSocket-Key", single);
+
+/* ====================================================================== */
+/**@HTTP_HEADER http_sec_websocket_protocol Sec-WebSocket-Protocol header. */
+
+#define http_sec_websocket_protocol_d msg_generic_d
+#define http_sec_websocket_protocol_e msg_generic_e
+msg_hclass_t http_sec_websocket_protocol_class[] =
+HTTP_HEADER_CLASS_G(sec_websocket_protocol, "Sec-WebSocket-Protocol", single);
+
+/* ====================================================================== */
+/**@HTTP_HEADER http_sec_websocket_version Sec-WebSocket-Version header. */
+
+#define http_sec_websocket_version_d msg_generic_d
+#define http_sec_websocket_version_e msg_generic_e
+msg_hclass_t http_sec_websocket_version_class[] =
+HTTP_HEADER_CLASS_G(sec_websocket_version, "Sec-WebSocket-Version", single);
+
+/* ====================================================================== */
+/**@HTTP_HEADER http_origin Origin header. */
+
+#define http_origin_d msg_generic_d
+#define http_origin_e msg_generic_e
+msg_hclass_t http_origin_class[] =
+HTTP_HEADER_CLASS_G(origin, "Origin", single);
+
+/* ====================================================================== */
 /**@HTTP_HEADER http_user_agent User-Agent header. */
 
 #define http_user_agent_d msg_generic_d
diff -ur a/libsofia-sip-ua/http/sofia-sip/http.h b/libsofia-sip-ua/http/sofia-sip/http.h
--- a/libsofia-sip-ua/http/sofia-sip/http.h	2011-03-11 16:49:18.000000000 +0200
+++ b/libsofia-sip-ua/http/sofia-sip/http.h	2017-12-07 23:26:00.928845827 +0200
@@ -58,7 +58,11 @@
 #define HTTP_DEFAULT_SERV "80"
 
 /** HTTP protocol identifier */
+#ifndef _MSC_VER
 #define HTTP_PROTOCOL_TAG   ((void *)0x48545450)	/* 'HTTP' */
+#else
+#define HTTP_PROTOCOL_TAG   ((void *)(UINT_PTR)0x48545450)	/* 'HTTP' */
+#endif
 
 /** HTTP parser flags */
 enum {
@@ -154,6 +158,11 @@
 
 typedef msg_list_t                  http_proxy_connection_t;
 
+typedef msg_generic_t                  http_sec_websocket_key_t;
+typedef msg_generic_t                  http_origin_t;
+typedef msg_generic_t                  http_sec_websocket_protocol_t;
+typedef msg_generic_t                  http_sec_websocket_version_t;
+
 typedef struct http_set_cookie_s    http_set_cookie_t;
 typedef struct http_cookie_s        http_cookie_t;
 
@@ -378,6 +387,11 @@
   http_set_cookie_t         *http_set_cookie;                /**< Set-Cookie */
   http_cookie_t             *http_cookie;                        /**< Cookie */
 
+  http_sec_websocket_key_t        *http_sec_websocket_key; /**< Sec-Websocket-Key */
+  http_origin_t                   *http_origin;  /**< Origin */
+  http_sec_websocket_protocol_t   *http_sec_websocket_protocol; /**< Sec-Websocket-Protocol */
+  http_sec_websocket_version_t    *http_sec_websocket_version; /**< Sec-Websocket-Version */
+
   http_mime_version_t       *http_mime_version;            /**< MIME-Version */
   http_content_encoding_t   *http_content_encoding;    /**< Content-Encoding */
   http_content_language_t   *http_content_language;    /**< Content-Language */
diff -ur a/libsofia-sip-ua/iptsec/auth_client.c b/libsofia-sip-ua/iptsec/auth_client.c
--- a/libsofia-sip-ua/iptsec/auth_client.c	2011-03-11 16:49:18.000000000 +0200
+++ b/libsofia-sip-ua/iptsec/auth_client.c	2017-12-07 23:25:59.196836434 +0200
@@ -185,6 +185,10 @@
 
   if (ca->ca_auc->auc_challenge)
     stale = ca->ca_auc->auc_challenge(ca, ch);
+
+  if (AUTH_CLIENT_IS_EXTENDED(ca))
+	  ca->ca_clear = 0;
+
   if (stale < 0)
     return -1;
 
@@ -285,19 +289,13 @@
 /**Feed authentication data to the authenticator.
  *
  * The function auc_credentials() is used to provide the authenticators in
- * with authentication data (user name, secret).
- *
- * The authentication data has format as follows:
+ * with authentication data (user name, secret).  The authentication data
+ * has format as follows:
  *
  * scheme:"realm":user:pass
  *
  * For instance, @c Basic:"nokia-proxy":ppessi:verysecret
  *
- * For Digest authentication scheme, it is possible to provide hashed
- * password instead. The scheme and hashed password should have prefix
- * "HA1+". For instance,
- * @c HA1+Digest:"realm":user1:HA1+c0890ff7a4fadc50c45f392ec4312965
- *
  * @todo The authentication data format sucks.
  *
  * @param[in,out] auc_list  list of authenticators
@@ -320,8 +318,7 @@
   /* Parse authentication data */
   /* Data is string like "Basic:\"agni\":user1:secret"
      or "Basic:\"[fe80::204:23ff:fea7:d60a]\":user1:secret" (IPv6)
-     or "Basic:\"Use \\\"interesting\\\" username and password here:\"\
-     :user1:secret"
+     or "Basic:\"Use \\\"interesting\\\" username and password here:\":user1:secret"
   */
   if (s && (s = strchr(scheme = s, ':')))
     *s++ = 0;
@@ -359,14 +356,12 @@
   return retval;
 }
 
-/**Feed authentication data to the authenticators.
+/**Feed authentication data to the authenticator.
  *
  * The function auc_credentials() is used to provide the authenticators in
  * with authentication tuple (scheme, realm, user name, secret).
  *
- * For @b Digest authentication scheme, it is possible to provide hashed
- * password instead. The @a scheme should contain "HA1+Digest", and the
- * @a password should be in hashed format prefixed with "HA1+".
+ * scheme:"realm":user:pass
  *
  * @param[in,out] auc_list  list of authenticators
  * @param[in] scheme        scheme to use (NULL, if any)
@@ -409,57 +404,16 @@
 		   char const *user,
 		   char const *pass)
 {
-  int (*save)(auth_client_t *ca,
-	      char const *scheme,
-	      char const *realm,
-	      char const *user,
-	      char const *pass);
-
-  if (!ca || !ca->ca_scheme || !ca->ca_realm)
-    return -1;
-
-  save = AUTH_CLIENT_SAVE_CREDENTIALS(ca);
-
-  if (save)
-    return (*save)(ca, scheme, realm, user, pass);
-  else
-    return auth_client_save_credentials(ca, scheme, realm, user, pass);
-}
-
-
-/**Save authentication data to an authenticator.
- *
- * Function saves the authentication data in the authentication client,
- * if the scheme and the realm match.
- *
- * @param[in] ca            client authenticator
- * @param[in] scheme        scheme to use (NULL, if any)
- * @param[in] realm         realm to use (NULL, if any)
- * @param[in] user          username
- * @param[in] pass          password
- *
- * @retval 1 if successful
- * @retval 0 data did not match
- * @retval -1 upon an error
- *
- * @NEW_1_12_11
- */
-int auth_client_save_credentials(auth_client_t *ca,
-				 char const *scheme,
-				 char const *realm,
-				 char const *user,
-				 char const *pass)
-{
   char *new_user, *new_pass;
   char *old_user, *old_pass;
 
+  assert(ca);
+
   if (!ca || !ca->ca_scheme || !ca->ca_realm)
     return -1;
 
-  if (scheme != NULL && !su_casematch(scheme, ca->ca_scheme))
-    return 0;
-
-  if (realm != NULL && !su_strmatch(realm, ca->ca_realm))
+  if ((scheme != NULL && !su_casematch(scheme, ca->ca_scheme)) ||
+      (realm != NULL && !su_strmatch(realm, ca->ca_realm)))
     return 0;
 
   old_user = ca->ca_user, old_pass = ca->ca_pass;
@@ -486,9 +440,6 @@
 
 /** Copy authentication data from @a src to @a dst.
  *
- * @param[in,out] dst  destination list of authenticators
- * @param[in] src      source list of authenticators
- *
  * @retval >0 if credentials were copied
  * @retval 0 if there was no credentials to copy
  * @retval <0 if an error occurred.
@@ -506,27 +457,35 @@
     auth_client_t const *ca;
 
     for (ca = src; ca; ca = ca->ca_next) {
-      int (*copy)(auth_client_t *d, auth_client_t const *s);
-      int result;
-
+      char *u, *p;
       if (!ca->ca_user || !ca->ca_pass)
 	continue;
       if (AUTH_CLIENT_IS_EXTENDED(ca) && ca->ca_clear)
 	continue;
+      if (!ca->ca_scheme[0] || !su_casematch(ca->ca_scheme, d->ca_scheme))
+	continue;
+      if (!ca->ca_realm || !su_strmatch(ca->ca_realm, d->ca_realm))
+	continue;
 
-      copy = AUTH_CLIENT_COPY_CREDENTIALS(d);
+      if (!(AUTH_CLIENT_IS_EXTENDED(d) && d->ca_clear) &&
+	  su_strmatch(d->ca_user, ca->ca_user) &&
+	  su_strmatch(d->ca_pass, ca->ca_pass)) {
+	retval++;
+	break;
+      }
 
-      if (copy != NULL)
-	result = (*copy)(d, src);
-      else
-	result = auth_client_copy_credentials(d, src);
+      u = su_strdup(d->ca_home, ca->ca_user);
+      p = su_strdup(d->ca_home, ca->ca_pass);
+      if (!u || !p)
+	return -1;
 
-      if (result < 0)
-	return result;
-      else if (result == 0)
-	continue;
-      else
-	retval++;
+      if (d->ca_user) su_free(d->ca_home, (void *)d->ca_user);
+      if (d->ca_pass) su_free(d->ca_home, (void *)d->ca_pass);
+      d->ca_user = u, d->ca_pass = p;
+      if (AUTH_CLIENT_IS_EXTENDED(d))
+	d->ca_clear = 0;
+
+      retval++;
       break;
     }
   }
@@ -534,49 +493,6 @@
   return retval;
 }
 
-/**Copy authentication data from a matching client in @a src to @a d.
- *
- * @retval 1 if credentials were copied
- * @retval 0 clients did not match
- * @retval -1 if an error occurred.
- *
- * @NEW_1_12_11
- */
-int auth_client_copy_credentials(auth_client_t *d,
-				auth_client_t const *s)
-{
-  char *u, *p;
-
-  if (d == NULL || s == NULL)
-    return -1;
-
-  if (!s->ca_scheme[0] || !su_casematch(s->ca_scheme, d->ca_scheme))
-    return 0;
-
-  if (!s->ca_realm || !su_strmatch(s->ca_realm, d->ca_realm))
-    return 0;
-
-  if (!(AUTH_CLIENT_IS_EXTENDED(d) && d->ca_clear) &&
-      su_strmatch(d->ca_user, s->ca_user) &&
-      su_strmatch(d->ca_pass, s->ca_pass))
-    return 1;
-
-  u = su_strdup(d->ca_home, s->ca_user);
-  p = su_strdup(d->ca_home, s->ca_pass);
-  if (!u || !p)
-    return -1;
-
-  su_free(d->ca_home, (void *)d->ca_user);
-  su_free(d->ca_home, (void *)d->ca_pass);
-
-  d->ca_user = u;
-  d->ca_pass = p;
-
-  if (AUTH_CLIENT_IS_EXTENDED(d))
-    d->ca_clear = 0;
-
-  return 1;
-}
 
 /**Clear authentication data from the authenticator.
  *
@@ -654,8 +570,10 @@
        * scheme
        */
       for (other = *auc_list; other; other = other->ca_next) {
-	if (ca == other)
-	  continue;
+		  if (ca == other) {
+			  continue;
+		  }
+
 	if (ca->ca_credential_class == other->ca_credential_class &&
 	    su_strcmp(ca->ca_realm, other->ca_realm) == 0 &&
 	    ca_has_authorization(other))
@@ -914,15 +832,6 @@
 static int auc_digest_info(auth_client_t *ca,
 			   msg_auth_info_t const *info);
 
-static int auc_digest_save_credentials(auth_client_t *ca,
-				       char const *scheme,
-				       char const *realm,
-				       char const *user,
-				       char const *pass);
-
-static int auc_digest_copy_credentials(auth_client_t *ca,
-				       auth_client_t const *src);
-
 static const auth_client_plugin_t ca_digest_plugin =
 {
   /* auc_plugin_size: */ sizeof ca_digest_plugin,
@@ -931,9 +840,7 @@
   /* auc_challenge: */   auc_digest_challenge,
   /* auc_authorize: */   auc_digest_authorization,
   /* auc_info: */        auc_digest_info,
-  /* auc_clear: */       ca_clear_credentials,
-  /* auc_save_credentials: */ auc_digest_save_credentials,
-  /* auc_copy_credentials: */ auc_digest_copy_credentials,
+  /* auc_clear: */       ca_clear_credentials
 };
 
 /** Store a digest authorization challenge.
@@ -960,7 +867,7 @@
 
   stale = ac->ac_stale || cda->cda_ac->ac_nonce == NULL;
 
-  if (ac->ac_qop && (cda->cda_cnonce == NULL || ac->ac_stale)) {
+  if (ac->ac_qop && (cda->cda_cnonce == NULL || ac->ac_stale || ca->ca_clear )) {
     su_guid_t guid[1];
     char *cnonce;
     size_t b64len = BASE64_MINSIZE(sizeof(guid)) + 1;
@@ -1037,7 +944,6 @@
   char *uri;
 
   msg_header_t *h;
-  char const *ha1;
   auth_hexmd5_t sessionkey, response;
   auth_response_t ar[1] = {{ 0 }};
   char ncount[17];
@@ -1045,11 +951,6 @@
   if (!user || !pass || (AUTH_CLIENT_IS_EXTENDED(ca) && ca->ca_clear))
     return 0;
 
-  if (!su_casenmatch(pass, "HA1+", 4))
-    return 0;
-
-  ha1 = pass + 4;
-
   ar->ar_size = sizeof(ar);
   ar->ar_username = user;
   ar->ar_realm = ac->ac_realm;
@@ -1076,16 +977,8 @@
     ar->ar_nc = ncount;
   }
 
-  if (ar->ar_md5sess) {
-    ar->ar_algorithm = "MD5-sess";
-    auth_digest_a1sess(ar, sessionkey, ha1);
-    ha1 = sessionkey;
-  }
-  else {
-    ar->ar_algorithm = "MD5";
-  }
-
-  auth_digest_response(ar, response, ha1, method, data, dlen);
+  auth_digest_sessionkey(ar, sessionkey, pass);
+  auth_digest_response(ar, response, sessionkey, method, data, dlen);
 
   h = msg_header_format(home, hc,
 			"Digest "
@@ -1124,39 +1017,6 @@
   return 0;
 }
 
-static int auc_digest_save_credentials(auth_client_t *ca,
-				       char const *scheme,
-				       char const *realm,
-				       char const *user,
-				       char const *pass)
-{
-  char prefixed[4 + sizeof (auth_hexmd5_t)]; /* "HA1+" and hex */
-
-  if (!ca)
-    return -1;
-
-  if (realm != NULL && !su_strmatch(realm, ca->ca_realm))
-    return 0;
-
-  if (scheme == NULL || su_casematch(scheme, "Digest")) {
-    strcpy(prefixed, "HA1+");
-    auth_digest_ha1(prefixed + strlen("HA1+"), user, ca->ca_realm, pass);
-    pass = prefixed;
-  }
-  else if (su_strmatch(scheme, "HA1+Digest") &&
-	   su_casenmatch(pass, "HA1+", 4))
-    pass = pass;
-  else
-    return 0;
-
-  return auth_client_save_credentials(ca, NULL, NULL, user, pass);
-}
-
-static int auc_digest_copy_credentials(auth_client_t *ca,
-				       auth_client_t const *src)
-{
-  return auth_client_copy_credentials(ca, src);
-}
 
 /* ---------------------------------------------------------------------- */
 
diff -ur a/libsofia-sip-ua/iptsec/auth_digest.c b/libsofia-sip-ua/iptsec/auth_digest.c
--- a/libsofia-sip-ua/iptsec/auth_digest.c	2011-03-11 16:49:18.000000000 +0200
+++ b/libsofia-sip-ua/iptsec/auth_digest.c	2017-12-07 23:25:59.196836434 +0200
@@ -204,39 +204,30 @@
     su_md5_strupdate(md5, quoted);
 }
 
-/** Generate the hex A1 hash for digest authentication. @NEW_1_12_11 */
-int auth_digest_ha1(auth_hexmd5_t ha1,
-		    char const *username,
-		    char const *realm,
-		    char const *secret)
+/** Generate A1 hash for digest authentication.
+ */
+int auth_digest_a1(auth_response_t *ar,
+		   auth_hexmd5_t ha1,
+		   char const *secret)
 {
   su_md5_t md5[1];
 
   /* Calculate A1 */
   su_md5_init(md5);
-  su_md5_strupdate(md5, username);
+  su_md5_strupdate(md5, ar->ar_username);
   su_md5_update(md5, ":", 1);
-  unquote_update(md5, realm);
+  unquote_update(md5, ar->ar_realm);
   su_md5_update(md5, ":", 1);
   su_md5_strupdate(md5, secret);
 
   su_md5_hexdigest(md5, ha1);
 
-  SU_DEBUG_5(("auth_digest_ha1() has A1 = MD5(%s:%s:%s) = %s\n",
-	      username, realm, "*******", ha1));
+  SU_DEBUG_5(("auth_digest_a1() has A1 = MD5(%s:%s:%s) = %s\n",
+	      ar->ar_username, ar->ar_realm, secret, ha1));
 
   return 0;
 }
 
-/** Generate A1 hash for digest authentication.
- */
-int auth_digest_a1(auth_response_t *ar,
-		   auth_hexmd5_t ha1,
-		   char const *secret)
-{
-  return auth_digest_ha1(ha1, ar->ar_username, ar->ar_realm, secret);
-}
-
 int auth_digest_a1sess(auth_response_t *ar,
 		       auth_hexmd5_t ha1sess,
 		       char const *ha1)
diff -ur a/libsofia-sip-ua/iptsec/auth_module.c b/libsofia-sip-ua/iptsec/auth_module.c
--- a/libsofia-sip-ua/iptsec/auth_module.c	2011-03-11 16:49:18.000000000 +0200
+++ b/libsofia-sip-ua/iptsec/auth_module.c	2017-12-07 23:25:59.204836477 +0200
@@ -80,10 +80,19 @@
 static void auth_call_scheme_destructor(void *);
 static void auth_md5_hmac_key(auth_mod_t *am);
 
+#ifdef __clang__
+#pragma clang diagnostic push
+#pragma clang diagnostic ignored "-Wunused-function"
+#endif
+
 HTABLE_PROTOS_WITH(auth_htable, aht, auth_passwd_t, usize_t, unsigned);
 HTABLE_BODIES_WITH(auth_htable, aht, auth_passwd_t, APW_HASH,
 		   usize_t, unsigned);
 
+#ifdef __clang__
+#pragma clang diagnostic pop
+#endif
+
 /**Allocate an authentication module instance.
  *
  * The function auth_mod_alloc() allocates an authentication module object.
@@ -535,8 +544,6 @@
     if (!au->au_params)
       continue;
     n = base64_d(userpass, upsize - 1, au->au_params[0]);
-    if (n < 0 || n >= INT_MAX)
-      continue;
     if (n >= upsize) {
       void *b = realloc(userpass == buffer ? NULL : userpass, upsize = n + 1);
       if (b == NULL)
@@ -746,7 +753,7 @@
       auth_challenge_digest(am, as, ach);
       as->as_blacklist = am->am_blacklist;
     }
-    SU_DEBUG_5(("auth_method_digest: response did not match\n"));
+    SU_DEBUG_5(("auth_method_digest: response did not match\n" VA_NONE));
 
     return;
   }
@@ -763,7 +770,7 @@
   if (am->am_challenge)
     auth_challenge_digest(am, as, ach);
 
-  SU_DEBUG_7(("auth_method_digest: successful authentication\n"));
+  SU_DEBUG_7(("auth_method_digest: successful authentication\n" VA_NONE));
 
   as->as_status = 0;	/* Successful authentication! */
   as->as_phrase = "";
@@ -963,6 +970,7 @@
   FILE *f;
   char *data, *s;
   size_t len, i, n, N;
+  ssize_t slen;
   auth_passwd_t *apw;
 
   if (!am->am_stat)
@@ -1004,7 +1012,7 @@
     if (am->am_stat)
       stat(am->am_db, am->am_stat); /* too bad if this fails */
 
-    len = readfile(am->am_home, f, &buffer, 1);
+    slen = readfile(am->am_home, f, &buffer, 1);
 
 #if HAVE_FLOCK
     /* Release shared lock on the database file */
@@ -1018,8 +1026,9 @@
 
     fclose(f);
 
-    if (len < 0)
+    if (slen < 0)
       return -1;
+    len = (size_t)slen;
 
     /* Count number of entries in new buffer */
     for (i = am->am_anonymous, s = data = buffer;
@@ -1210,7 +1219,7 @@
   buffer[len] = '\0';
   *contents = buffer;
 
-  return len;
+  return (ssize_t)len;
 }
 
 /* ====================================================================== */
@@ -1412,11 +1421,11 @@
 
   /* Check nonce */
   if (!ar->ar_nonce) {
-    SU_DEBUG_5(("auth_method_digest: no nonce\n"));
+    SU_DEBUG_5(("auth_method_digest: no nonce\n" VA_NONE));
     return -1;
   }
   if (base64_d((void*)nonce, (sizeof nonce), ar->ar_nonce) != (sizeof nonce)) {
-    SU_DEBUG_5(("auth_method_digest: too short nonce\n"));
+    SU_DEBUG_5(("auth_method_digest: too short nonce\n" VA_NONE));
     return -1;
   }
 
@@ -1426,7 +1435,7 @@
   auth_md5_hmac_digest(am, md5, hmac, sizeof hmac);
 
   if (memcmp(nonce->digest, hmac, sizeof nonce->digest)) {
-    SU_DEBUG_5(("auth_method_digest: bad nonce\n"));
+    SU_DEBUG_5(("auth_method_digest: bad nonce\n" VA_NONE));
     return -1;
   }
 
diff -ur a/libsofia-sip-ua/iptsec/sofia-sip/auth_client_plugin.h b/libsofia-sip-ua/iptsec/sofia-sip/auth_client_plugin.h
--- a/libsofia-sip-ua/iptsec/sofia-sip/auth_client_plugin.h	2011-03-11 16:49:18.000000000 +0200
+++ b/libsofia-sip-ua/iptsec/sofia-sip/auth_client_plugin.h	2017-12-07 23:26:01.008846261 +0200
@@ -93,17 +93,6 @@
 #if SOFIA_EXTEND_AUTH_CLIENT
   /** Clear credentials (user/pass). @NEW_1_12_6. */
   int (*auc_clear)(auth_client_t *ca);
-
-  /** Save credentials. @NEW_1_12_11. */
-  int (*auc_save_credentials)(auth_client_t *ca,
-			      char const *scheme,
-			      char const *realm,
-			      char const *user,
-			      char const *pass);
-
-  /** Copy credentials. @NEW_1_12_11. */
-  int (*auc_copy_credentials)(auth_client_t *dst,
-			      auth_client_t const *src);
 #endif
 };
 
@@ -114,33 +103,6 @@
    (int)offsetof(auth_client_plugin_t, auc_clear)			\
    && (ca)->ca_auc->auc_clear != NULL)
 
-/** Return auc_save_credentials method from authentication client.
- * @NEW_1_12_11.
- */
-#define AUTH_CLIENT_SAVE_CREDENTIALS(ca)				\
-  ((ca)->ca_auc &&							\
-   (ca)->ca_auc->auc_plugin_size >					\
-   (int)offsetof(auth_client_plugin_t, auc_save_credentials)		\
-   ? (ca)->ca_auc->auc_save_credentials : NULL)
-
-SOFIAPUBFUN int auth_client_save_credentials(auth_client_t *ac,
-					     char const *scheme,
-					     char const *realm,
-					     char const *user,
-					     char const *pass);
-
-/** Return auc_copy_credentials method from authentication client.
- * @NEW_1_12_11.
- */
-#define AUTH_CLIENT_COPY_CREDENTIALS(ca)				\
-  ((ca)->ca_auc &&							\
-   (ca)->ca_auc->auc_plugin_size >					\
-   (int)offsetof(auth_client_plugin_t, auc_copy_credentials)		\
-   ? (ca)->ca_auc->auc_copy_credentials : NULL)
-
-SOFIAPUBFUN int auth_client_copy_credentials(auth_client_t *ac,
-					     auth_client_t const *src);
-
 SOFIA_END_DECLS
 
 #endif /* !defined AUTH_CLIENT_PLUGIN_H */
diff -ur a/libsofia-sip-ua/iptsec/sofia-sip/auth_digest.h b/libsofia-sip-ua/iptsec/sofia-sip/auth_digest.h
--- a/libsofia-sip-ua/iptsec/sofia-sip/auth_digest.h	2011-03-11 16:49:18.000000000 +0200
+++ b/libsofia-sip-ua/iptsec/sofia-sip/auth_digest.h	2017-12-07 23:26:01.020846326 +0200
@@ -143,11 +143,6 @@
 SOFIAPUBFUN issize_t auth_digest_response_get(su_home_t *, auth_response_t *,
 					      char const * const params[]);
 
-SOFIAPUBFUN int auth_digest_ha1(auth_hexmd5_t ha1,
-				char const *username,
-				char const *realm,
-				char const *secret);
-
 SOFIAPUBFUN int auth_digest_a1(auth_response_t *ar,
 			       auth_hexmd5_t ha1,
 			       char const *secret);
@@ -158,7 +153,6 @@
 
 SOFIAPUBFUN int auth_digest_sessionkey(auth_response_t *, auth_hexmd5_t ha1,
 				       char const *secret);
-
 SOFIAPUBFUN int auth_digest_response(auth_response_t *, auth_hexmd5_t response,
 				     auth_hexmd5_t const ha1,
 				     char const *method_name,
diff -ur a/libsofia-sip-ua/iptsec/test_auth_digest.c b/libsofia-sip-ua/iptsec/test_auth_digest.c
--- a/libsofia-sip-ua/iptsec/test_auth_digest.c	2011-03-11 16:49:18.000000000 +0200
+++ b/libsofia-sip-ua/iptsec/test_auth_digest.c	2017-12-07 23:25:59.272836846 +0200
@@ -895,26 +895,6 @@
     reinit_as(as);
     auth_mod_check_client(am, as, sip->sip_authorization, ach);
     TEST(as->as_status, 0);
-    aucs = NULL;
-
-    /* Test HA1+Digest */
-    reinit_as(as);
-    auth_mod_check_client(am, as, NULL, ach); TEST(as->as_status, 401);
-    TEST(auc_challenge(&aucs, home, (msg_auth_t *)as->as_response,
-		       sip_authorization_class), 1);
-    TEST(auc_all_credentials(&aucs, "HA1+Digest", "\"ims3.so.noklab.net\"",
-			     "user1", "HA1+c0890ff7a4fadc50c45f392ec4312965"),
-	 1);
-    msg_header_remove(m2, (void *)sip, (void *)sip->sip_authorization);
-    TEST(auc_authorization(&aucs, m2, (msg_pub_t*)sip, rq->rq_method_name,
-			   (url_t *)"sip:surf3@ims3.so.noklab.net",
-			   sip->sip_payload), 1);
-    TEST_1(sip->sip_authorization);
-
-    reinit_as(as);
-    auth_mod_check_client(am, as, sip->sip_authorization, ach);
-    TEST(as->as_status, 0);
-
     auth_mod_destroy(am); aucs = NULL;
 
     TEST_1(am = auth_mod_create(NULL,
diff -ur a/libsofia-sip-ua/Makefile.am b/libsofia-sip-ua/Makefile.am
--- a/libsofia-sip-ua/Makefile.am	2011-03-11 16:49:18.000000000 +0200
+++ b/libsofia-sip-ua/Makefile.am	2017-12-07 23:25:58.928834980 +0200
@@ -60,6 +60,10 @@
 libsofia_sip_ua_la_LDFLAGS = \
 	-version-info $(LIBVER_SOFIA_SIP_UA_CUR):$(LIBVER_SOFIA_SIP_UA_REV):$(LIBVER_SOFIA_SIP_UA_AGE)
 
+if HAVE_ZLIB
+libsofia_sip_ua_la_LDFLAGS += -lz
+endif
+
 PHONY = doxygen built-sources
 
 include $(top_srcdir)/rules/recursive.am
diff -ur a/libsofia-sip-ua/msg/msg.c b/libsofia-sip-ua/msg/msg.c
--- a/libsofia-sip-ua/msg/msg.c	2011-03-11 16:49:18.000000000 +0200
+++ b/libsofia-sip-ua/msg/msg.c	2017-12-07 23:25:59.296836976 +0200
@@ -242,8 +242,8 @@
  */
 void msg_addr_zero(msg_t *msg)
 {
-  memset(&msg->m_addr, 0, sizeof(&msg->m_addr));
-  memset(&msg->m_addrinfo, 0, sizeof(&msg->m_addrinfo));
+  memset(&msg->m_addr, 0, sizeof(msg->m_addr));
+  memset(&msg->m_addrinfo, 0, sizeof(msg->m_addrinfo));
 
   msg->m_addrinfo.ai_addrlen = sizeof(msg->m_addr);
   msg->m_addrinfo.ai_addr = &msg->m_addr->su_sa;
diff -ur a/libsofia-sip-ua/msg/msg_date.c b/libsofia-sip-ua/msg/msg_date.c
--- a/libsofia-sip-ua/msg/msg_date.c	2011-03-11 16:49:18.000000000 +0200
+++ b/libsofia-sip-ua/msg/msg_date.c	2017-12-07 23:25:59.312837063 +0200
@@ -182,7 +182,7 @@
 issize_t msg_date_d(char const **ss, msg_time_t *date)
 {
   char const *s = *ss;
-  char const *wkday;
+  //char const *wkday;
   char const *tz;
   unsigned long day, year, hour, min, sec;
   int mon;
@@ -190,7 +190,8 @@
   if (!IS_TOKEN(*s) || !date)
     return -1;
 
-  wkday = s; skip_token(&s); if (*s == ',') s++;
+  //wkday = s; 
+  skip_token(&s); if (*s == ',') s++;
   while (IS_LWS(*s)) s++;
 
   if (is_digit(*s)) {
diff -ur a/libsofia-sip-ua/msg/msg_internal.h b/libsofia-sip-ua/msg/msg_internal.h
--- a/libsofia-sip-ua/msg/msg_internal.h	2011-03-11 16:49:18.000000000 +0200
+++ b/libsofia-sip-ua/msg/msg_internal.h	2017-12-07 23:25:59.340837214 +0200
@@ -114,6 +114,131 @@
   msg_payload_t  *b_chunks;	    /**< List of body chunks */
 };
 
+
+struct hep_hdr{
+    uint8_t hp_v;             /* version */
+    uint8_t hp_l;             /* length */
+    uint8_t hp_f;             /* family */
+    uint8_t hp_p;             /* protocol */
+    uint16_t hp_sport;        /* source port */
+    uint16_t hp_dport;        /* destination port */
+};
+
+
+struct hep_iphdr{
+        struct in_addr hp_src; 
+        struct in_addr hp_dst;      /* source and dest address */
+};
+
+/* HEPv2 */
+struct hep_timehdr{
+    uint32_t tv_sec;         /* seconds */
+    uint32_t tv_usec;        /* useconds */
+    uint16_t captid;          /* Capture ID node */
+};
+
+#if SU_HAVE_IN6
+struct hep_ip6hdr {
+	struct in6_addr hp6_src;        /* source address */
+	struct in6_addr hp6_dst;        /* destination address */
+};
+#endif
+
+/* HEPv3 types */
+
+#if (defined __SUNPRO_CC) || defined(__SUNPRO_C) || defined(_MSC_VER)
+#define PACKED
+#endif
+#ifndef PACKED
+#define PACKED __attribute__ ((__packed__))
+#endif
+
+#ifdef _MSC_VER
+#pragma pack(push, 1)
+#endif
+
+struct hep_chunk {
+       uint16_t vendor_id;
+       uint16_t type_id;
+       uint16_t length;
+} PACKED;
+
+typedef struct hep_chunk hep_chunk_t;
+
+struct hep_chunk_uint8 {
+       hep_chunk_t chunk;
+       uint8_t data;
+} PACKED;
+
+typedef struct hep_chunk_uint8 hep_chunk_uint8_t;
+
+struct hep_chunk_uint16 {
+       hep_chunk_t chunk;
+       uint16_t data;
+} PACKED;
+
+typedef struct hep_chunk_uint16 hep_chunk_uint16_t;
+
+struct hep_chunk_uint32 {
+       hep_chunk_t chunk;
+       uint32_t data;
+} PACKED;
+
+typedef struct hep_chunk_uint32 hep_chunk_uint32_t;
+
+struct hep_chunk_str {
+       hep_chunk_t chunk;
+       char *data;
+} PACKED;
+
+typedef struct hep_chunk_str hep_chunk_str_t;
+
+struct hep_chunk_ip4 {
+       hep_chunk_t chunk;
+       struct in_addr data;
+} PACKED;
+
+typedef struct hep_chunk_ip4 hep_chunk_ip4_t;
+
+struct hep_chunk_ip6 {
+       hep_chunk_t chunk;
+       struct in6_addr data;
+} PACKED;
+
+typedef struct hep_chunk_ip6 hep_chunk_ip6_t;
+
+struct hep_chunk_payload {
+    hep_chunk_t chunk;
+    char *data;
+} PACKED;
+
+typedef struct hep_chunk_payload hep_chunk_payload_t;
+
+struct hep_ctrl {
+    char id[4];
+    uint16_t length;
+} PACKED;
+
+typedef struct hep_ctrl hep_ctrl_t;
+
+struct hep_generic {
+        hep_ctrl_t         header;
+        hep_chunk_uint8_t  ip_family;
+        hep_chunk_uint8_t  ip_proto;
+        hep_chunk_uint16_t src_port;
+        hep_chunk_uint16_t dst_port;
+        hep_chunk_uint32_t time_sec;
+        hep_chunk_uint32_t time_usec;
+        hep_chunk_uint8_t  proto_t;
+        hep_chunk_uint32_t capt_id;
+} PACKED;
+
+#ifdef _MSC_VER
+#pragma pack(pop)
+#endif
+
+typedef struct hep_generic hep_generic_t;
+
 /** Maximum size when streaming. */
 #define MSG_SSIZE_MAX (USIZE_MAX)
 
diff -ur a/libsofia-sip-ua/msg/msg_mime.c b/libsofia-sip-ua/msg/msg_mime.c
--- a/libsofia-sip-ua/msg/msg_mime.c	2011-03-11 16:49:18.000000000 +0200
+++ b/libsofia-sip-ua/msg/msg_mime.c	2017-12-07 23:25:59.348837258 +0200
@@ -40,7 +40,6 @@
 
 #include <sofia-sip/su_alloc.h>
 #include <sofia-sip/su_string.h>
-#include <sofia-sip/su_bm.h>
 
 #include "msg_internal.h"
 #include "sofia-sip/msg.h"
@@ -56,6 +55,11 @@
 #include <errno.h>
 #include <assert.h>
 
+#if !HAVE_MEMMEM
+void *memmem(const void *haystack, size_t haystacklen,
+	     const void *needle, size_t needlelen);
+#endif
+
 /** Protocol version of MIME */
 char const msg_mime_version_1_0[] = "MIME/1.0";
 
@@ -326,7 +330,7 @@
   }
 
   /* Look for LF -- */
-  for (;(p = bm_memmem(p, end - p, LF "--", 3, NULL)); p += 3) {
+  for (;(p = memmem(p, end - p, LF "--", 3)); p += 3) {
     len = end - p;
     m = 3 + su_memspn(p + 3, len - 3, bchars, bchars_len);
     if (m + 2 >= len)
@@ -374,9 +378,8 @@
   msg_t msg[1] = {{{ SU_HOME_INIT(msg) }}};
   size_t len, m, blen;
   char *boundary, *p, *next, save;
-  char const *b, *end;
+  char *b, *end;
   msg_param_t param;
-  bm_fwd_table_t *fwd = NULL;
 
   p = pl->pl_data; len = pl->pl_len; end = p + len;
 
@@ -395,20 +398,16 @@
 
   m = strlen(boundary) - 2, blen = m - 1;
 
-  if (blen > 8 * sizeof (long))
-    fwd = bm_memmem_study(boundary + 1, blen);
-
   /* Find first delimiter */
   if (memcmp(boundary + 2, p, m - 2) == 0)
     b = p, p = p + m - 2, len -= m - 2;
-  else if ((p = bm_memmem(p, len, boundary + 1, blen, fwd))) {
+  else if ((p = memmem(p, len, boundary + 1, m - 1))) {
     if (p != pl->pl_data && p[-1] == '\r')
       b = --p, p = p + m, len -= m;
     else
       b = p, p = p + m - 1, len -= m - 1;
   }
   else {
-    free(fwd);
     su_home_deinit(msg_home(msg));
     return NULL;
   }
@@ -425,7 +424,7 @@
     if (len < blen)
       break;
 
-    next = bm_memmem(p, len, boundary + 1, m = blen, fwd);
+    next = memmem(p, len, boundary + 1, m = blen);
 
     if (!next)
       break;			/* error */
@@ -439,8 +438,11 @@
     *mmp = mp; mmp = &mp->mp_next;
 
     /* Put delimiter transport-padding CRLF here */
-    mp->mp_common->h_data = b;
+
+	*b = '\0';
     mp->mp_common->h_len = p - b;
+	b += strlen(boundary) - 2;
+    mp->mp_common->h_data = b;
 
     /* .. and body-part here */
     mp->mp_data = p;
@@ -450,22 +452,23 @@
       /* We found close-delimiter */
       assert(mp);
       if (!mp)
-	break;			/* error */
+		  break;			/* error */
       mp->mp_close_delim = (msg_payload_t *)
-	msg_header_alloc(msg_home(msg), msg_payload_class, 0);
+		  msg_header_alloc(msg_home(msg), msg_payload_class, 0);
       if (!mp->mp_close_delim)
-	break;			/* error */
+		  break;			/* error */
       /* Include also transport-padding and epilogue in the close-delimiter */
-      mp->mp_close_delim->pl_data = next;
+	  *next = '\0';
       mp->mp_close_delim->pl_len = p + len - next;
+	  next += strlen(boundary) - 2;
+      mp->mp_close_delim->pl_data = next;
+	  
       break;
     }
 
     b = next; p = next + m;
   }
 
-  free(fwd), fwd = NULL;
-
   if (!mp || !mp->mp_close_delim) {
     su_home_deinit(msg_home(msg));
     /* Delimiter error */
@@ -518,8 +521,8 @@
     mp->mp_data = boundary;
     mp->mp_len = (unsigned)blen; /* XXX */
 
-    assert(mp->mp_payload || mp->mp_separator);
-
+    if (!(mp->mp_payload || mp->mp_separator)) continue;
+	
     if (mp->mp_close_delim) {
       msg_header_t **tail;
 
@@ -1066,28 +1069,33 @@
 
 issize_t msg_accept_d(su_home_t *home, msg_header_t *h, char *s, isize_t slen)
 {
-  msg_accept_t *ac = (msg_accept_t *)h;
+	msg_accept_t *ac;
 
-  while (*s == ',')   /* Ignore empty entries (comma-whitespace) */
-    *s = '\0', s += span_lws(s + 1) + 1;
-
-  if (*s == '\0') {
-    /* Empty Accept list is not an error */
-    ac->ac_type = ac->ac_subtype = "";
-    return 0;
-  }
+	for(;;) {
+		ac = (msg_accept_t *)h;
 
-  /* "Accept:" #(type/subtyp ; *(parameters))) */
-  if (msg_mediatype_d(&s, &ac->ac_type) == -1)
-    return -1;
-  if (!(ac->ac_subtype = strchr(ac->ac_type, '/')))
-    return -1;
-  ac->ac_subtype++;
+		while (*s == ',')   /* Ignore empty entries (comma-whitespace) */
+			*s = '\0', s += span_lws(s + 1) + 1;
 
-  if (*s == ';' && msg_params_d(home, &s, &ac->ac_params) == -1)
-    return -1;
+		if (*s == '\0') {
+			/* Empty Accept list is not an error */
+			ac->ac_type = ac->ac_subtype = "";
+			return 0;
+		}
+
+		/* "Accept:" #(type/subtyp ; *(parameters))) */
+		if (msg_mediatype_d(&s, &ac->ac_type) == -1)
+			return -1;
+		if (!(ac->ac_subtype = strchr(ac->ac_type, '/')))
+			return -1;
+		ac->ac_subtype++;
+
+		if (*s == ';' && msg_params_d(home, &s, &ac->ac_params) == -1)
+			return -1;
+  
+		msg_parse_next_field_without_recursion();
+	}
 
-  return msg_parse_next_field(home, h, s, slen);
 }
 
 issize_t msg_accept_e(char b[], isize_t bsiz, msg_header_t const *h, int flags)
@@ -1164,22 +1172,26 @@
 			  char *s, isize_t slen)
 {
   /** @relatesalso msg_accept_any_s */
-  msg_accept_any_t *aa = (msg_accept_any_t *)h;
-
-  while (*s == ',')   /* Ignore empty entries (comma-whitespace) */
-    *s = '\0', s += span_lws(s + 1) + 1;
-
-  if (*s == '\0')
-    return -2;			/* Empty list */
+	msg_accept_any_t *aa;
 
-  /* "Accept-*:" 1#(token *(SEMI accept-param)) */
-  if (msg_token_d(&s, &aa->aa_value) == -1)
-    return -1;
-
-  if (*s == ';' && msg_params_d(home, &s, &aa->aa_params) == -1)
-    return -1;
+	for(;;) {
+		aa = (msg_accept_any_t *)h;
+		while (*s == ',')   /* Ignore empty entries (comma-whitespace) */
+			*s = '\0', s += span_lws(s + 1) + 1;
+
+		if (*s == '\0')
+			return -2;			/* Empty list */
+
+		/* "Accept-*:" 1#(token *(SEMI accept-param)) */
+		if (msg_token_d(&s, &aa->aa_value) == -1)
+			return -1;
+
+		if (*s == ';' && msg_params_d(home, &s, &aa->aa_params) == -1)
+			return -1;
+		
+		msg_parse_next_field_without_recursion();
+	}
 
-  return msg_parse_next_field(home, h, s, slen);
 }
 
 /** Encode an Accept-* header field. */
@@ -2068,29 +2080,33 @@
 
 issize_t msg_warning_d(su_home_t *home, msg_header_t *h, char *s, isize_t slen)
 {
-  msg_warning_t *w = (msg_warning_t *)h;
+	msg_warning_t *w;
   char *text;
 
-  while (*s == ',')   /* Ignore empty entries (comma-whitespace) */
-    *s = '\0', s += span_lws(s + 1) + 1;
-
-  /* Parse protocol */
-  if (!IS_DIGIT(*s))
-    return -1;
-  w->w_code = strtoul(s, &s, 10);
-  skip_lws(&s);
-
-  /* Host (and port) */
-  if (msg_hostport_d(&s, &w->w_host, &w->w_port) == -1)
-    return -1;
-  if (msg_quoted_d(&s, &text) == -1)
-    return -1;
-  if (msg_unquote(text, text) == NULL)
-    return -1;
-
-  w->w_text = text;
+  for(;;) {
+	  w = (msg_warning_t *)h;
+	  while (*s == ',')   /* Ignore empty entries (comma-whitespace) */
+		  *s = '\0', s += span_lws(s + 1) + 1;
+
+	  /* Parse protocol */
+	  if (!IS_DIGIT(*s))
+		  return -1;
+	  w->w_code = strtoul(s, &s, 10);
+	  skip_lws(&s);
+
+	  /* Host (and port) */
+	  if (msg_hostport_d(&s, &w->w_host, &w->w_port) == -1)
+		  return -1;
+	  if (msg_quoted_d(&s, &text) == -1)
+		  return -1;
+	  if (msg_unquote(text, text) == NULL)
+		  return -1;
+
+	  w->w_text = text;
+	  
+	  msg_parse_next_field_without_recursion();
+  }
 
-  return msg_parse_next_field(home, h, s, slen);
 }
 
 issize_t msg_warning_e(char b[], isize_t bsiz, msg_header_t const *h, int f)
diff -ur a/libsofia-sip-ua/msg/msg_parser.c b/libsofia-sip-ua/msg/msg_parser.c
--- a/libsofia-sip-ua/msg/msg_parser.c	2011-03-11 16:49:18.000000000 +0200
+++ b/libsofia-sip-ua/msg/msg_parser.c	2017-12-07 23:25:59.368837366 +0200
@@ -327,7 +327,7 @@
  * @param[in]  msg     message object
  * @param[out] vec     I/O vector
  * @param[in]  veclen  available length of @a vec
- * @param[in]  n       number of possibly available bytesÂ 
+ * @param[in]  n       number of possibly available bytes
  * @param[in]  exact   true if data ends at message boundary
  *
  * @return
@@ -739,7 +739,7 @@
 			  usize_t N,
 			  usize_t blocksize)
 {
-  msg_buffer_t *ext, *b, **bb;
+  msg_buffer_t *ext = NULL, *b, **bb;
   size_t i, I;
 
   assert(N <= 128 * 1024);
@@ -1190,6 +1190,7 @@
   return h;
 }
 
+
 /** Complete this header field and parse next header field.
  *
  * This function completes parsing a multi-field header like @Accept,
@@ -1238,6 +1239,7 @@
   return hc->hc_parse(home, h, s, end - s);
 }
 
+
 /** Decode a message header. */
 msg_header_t *msg_header_d(su_home_t *home, msg_t const *msg, char const *b)
 {
@@ -1678,7 +1680,7 @@
     n += m;
 
     if (hc->hc_name) {
-      if (!comma_list || !next || next == *return_next)
+      if (!hc->hc_name[0] || !comma_list || !next || next == *return_next)
 	s = CRLF, m = 2;
       /* Else encode continuation */
       else if (compact)
@@ -2015,7 +2017,7 @@
     for (last = h; last->sh_succ; last = last->sh_succ) {
       /* Ensure that chain is connected */
       assert(last->sh_next == last->sh_succ);
-      assert(last->sh_succ->sh_prev = &last->sh_succ);
+      assert(last->sh_succ->sh_prev == &last->sh_succ);
     }
     prev = &last->sh_succ;
   }
@@ -2468,8 +2470,6 @@
 msg_header_t **
 msg_hclass_offset(msg_mclass_t const *mc, msg_pub_t const *mo, msg_hclass_t *hc)
 {
-  int i;
-
   assert(mc && hc);
 
   if (mc == NULL || hc == NULL)
@@ -2481,12 +2481,16 @@
       if (mc->mc_hash[j].hr_class == hc) {
 	return (msg_header_t **)((char *)mo + mc->mc_hash[j].hr_offset);
       }
-  }
-  else
+  } else {
     /* Header has no name. */
-    for (i = 0; i <= 6; i++)
-      if (hc->hc_hash == mc->mc_request[i].hr_class->hc_hash)
-	return (msg_header_t **)((char *)mo + mc->mc_request[i].hr_offset);
+    if (hc->hc_hash == mc->mc_request[0].hr_class->hc_hash) return (msg_header_t **)((char *)mo + mc->mc_request[0].hr_offset);
+    if (hc->hc_hash == mc->mc_status[0].hr_class->hc_hash) return (msg_header_t **)((char *)mo + mc->mc_status[0].hr_offset);
+    if (hc->hc_hash == mc->mc_separator[0].hr_class->hc_hash) return (msg_header_t **)((char *)mo + mc->mc_separator[0].hr_offset);
+    if (hc->hc_hash == mc->mc_payload[0].hr_class->hc_hash) return (msg_header_t **)((char *)mo + mc->mc_payload[0].hr_offset);
+    if (hc->hc_hash == mc->mc_unknown[0].hr_class->hc_hash) return (msg_header_t **)((char *)mo + mc->mc_unknown[0].hr_offset);
+    if (hc->hc_hash == mc->mc_error[0].hr_class->hc_hash) return (msg_header_t **)((char *)mo + mc->mc_error[0].hr_offset);
+    if (hc->hc_hash == mc->mc_multipart[0].hr_class->hc_hash) return (msg_header_t **)((char *)mo + mc->mc_multipart[0].hr_offset);
+  }
 
   return NULL;
 }
diff -ur a/libsofia-sip-ua/msg/msg_parser_util.c b/libsofia-sip-ua/msg/msg_parser_util.c
--- a/libsofia-sip-ua/msg/msg_parser_util.c	2011-03-11 16:49:18.000000000 +0200
+++ b/libsofia-sip-ua/msg/msg_parser_util.c	2017-12-07 23:25:59.372837388 +0200
@@ -796,47 +796,6 @@
   return 0;
 }
 
-/** Clear encoded data from header fields.
- *
- * Clear encoded or cached unencoded headers from header fields.
- *
- * @param h pointer to header structure
- */
-void msg_fragment_clear_chain(msg_header_t *h)
-{
-  char const *data;
-  msg_header_t *prev, *succ;
-
-  if (h == NULL || h->sh_data == NULL)
-    return;
-
-  data = (char *)h->sh_data + h->sh_len;
-
-  /* Find first field of header */
-  for (prev = (msg_header_t *)h->sh_prev;
-       prev && (void *)prev->sh_next == (void *)h;) {
-    if (!prev->sh_data)
-      break;
-    if ((char *)prev->sh_data + prev->sh_len != data)
-      break;
-    h = prev, prev = (msg_header_t *)h->sh_prev;
-  }
-
-  for (h = h; h; h = succ) {
-    succ = h->sh_succ;
-
-    h->sh_data = NULL, h->sh_len = 0;
-
-    if (!data ||
-	!succ ||
-	h->sh_next != succ ||
-	succ->sh_data != (void *)data ||
-	succ->sh_len)
-      return;
-  }
-}
-
-
 /** Find a header parameter.
  *
  * Searches for given parameter @a name from the header. If parameter is
@@ -958,8 +917,7 @@
     params[n] = param;	/* Add .. or replace */
   }
 
-  if (h->h_data)
-    msg_fragment_clear_chain((msg_header_t *)h);
+  msg_fragment_clear(h);
 
   if (h->h_class->hc_update) {
     /* Update shortcuts */
diff -ur a/libsofia-sip-ua/msg/msg_tag.c b/libsofia-sip-ua/msg/msg_tag.c
--- a/libsofia-sip-ua/msg/msg_tag.c	2011-03-11 16:49:18.000000000 +0200
+++ b/libsofia-sip-ua/msg/msg_tag.c	2017-12-07 23:25:59.376837410 +0200
@@ -50,7 +50,11 @@
 #include <sofia-sip/su_tagarg.h>
 #include "sofia-sip/msg_tag_class.h"
 
+#ifndef _MSC_VER
 #define NONE ((void*)-1)
+#else
+#define NONE ((void*)(INT_PTR)-1)
+#endif
 
 int msghdrtag_snprintf(tagi_t const *t, char b[], size_t size)
 {
diff -ur a/libsofia-sip-ua/msg/sofia-sip/msg_header.h b/libsofia-sip-ua/msg/sofia-sip/msg_header.h
--- a/libsofia-sip-ua/msg/sofia-sip/msg_header.h	2011-03-11 16:49:18.000000000 +0200
+++ b/libsofia-sip-ua/msg/sofia-sip/msg_header.h	2017-12-07 23:26:01.056846521 +0200
@@ -224,8 +224,6 @@
   (msg_param_t **)((char *)(h) + ((msg_common_t *)h)->h_class->hc_params) : NULL)
 #endif
 
-SOFIAPUBFUN void msg_fragment_clear_chain(msg_header_t *h);
-
 SOFIAPUBFUN char const *msg_header_find_param(msg_common_t const *,
 					      char const *name);
 SOFIAPUBFUN int msg_header_add_param(su_home_t *, msg_common_t *h,
@@ -301,7 +299,12 @@
    (h))
 
 /** No header. */
+
+#ifndef _MSC_VER
 #define MSG_HEADER_NONE ((msg_header_t *)-1)
+#else
+#define MSG_HEADER_NONE ((msg_header_t *)(INT_PTR)-1)
+#endif
 
 SOFIA_END_DECLS
 
diff -ur a/libsofia-sip-ua/msg/sofia-sip/msg_mime.h b/libsofia-sip-ua/msg/sofia-sip/msg_mime.h
--- a/libsofia-sip-ua/msg/sofia-sip/msg_mime.h	2011-03-11 16:49:18.000000000 +0200
+++ b/libsofia-sip-ua/msg/sofia-sip/msg_mime.h	2017-12-07 23:26:01.068846587 +0200
@@ -235,7 +235,11 @@
 SOFIAPUBVAR char const msg_mime_version_1_0[];
 
 /** MIME multipart parser table identifier. @HIDE */
+#ifndef _MSC_VER
 #define MSG_MULTIPART_PROTOCOL_TAG   ((void *)0x4d494d45)	/* 'MIME' */
+#else
+#define MSG_MULTIPART_PROTOCOL_TAG   ((void *)(UINT_PTR)0x4d494d45)	/* 'MIME' */
+#endif
 
 SOFIA_END_DECLS
 
diff -ur a/libsofia-sip-ua/msg/sofia-sip/msg_parser.h b/libsofia-sip-ua/msg/sofia-sip/msg_parser.h
--- a/libsofia-sip-ua/msg/sofia-sip/msg_parser.h	2011-03-11 16:49:18.000000000 +0200
+++ b/libsofia-sip-ua/msg/sofia-sip/msg_parser.h	2017-12-07 23:26:01.080846651 +0200
@@ -185,6 +185,34 @@
 SOFIAPUBFUN issize_t msg_parse_next_field(su_home_t *home, msg_header_t *prev,
 					  char *s, isize_t slen);
 
+#define msg_parse_next_field_without_recursion() {				\
+		msg_header_t *prev = h;									\
+		msg_hclass_t *hc = prev->sh_class;						\
+		char *end = s + slen;									\
+																\
+		if (*s && *s != ',')									\
+			return -1;											\
+																\
+		if (msg_header_update_params(prev->sh_common, 0) < 0)	\
+			return -1;											\
+																\
+		while (*s == ',')										\
+			*s = '\0', s += span_lws(s + 1) + 1;				\
+																\
+		if (*s == 0)											\
+			return 0;											\
+																\
+		h = msg_header_alloc(home, hc, 0);						\
+		if (!h)													\
+			return -1;											\
+																\
+		prev->sh_succ = h, h->sh_prev = &prev->sh_succ;			\
+		prev->sh_next = h;										\
+		slen = end - s;											\
+	}															
+
+
+
 /** Terminate encoding. @HI */
 #define MSG_TERM_E(p, e) ((p) < (e) ? (p)[0] = '\0' : '\0')
 
diff -ur a/libsofia-sip-ua/msg/test_msg.c b/libsofia-sip-ua/msg/test_msg.c
--- a/libsofia-sip-ua/msg/test_msg.c	2011-03-11 16:49:18.000000000 +0200
+++ b/libsofia-sip-ua/msg/test_msg.c	2017-12-07 23:25:59.392837497 +0200
@@ -606,7 +606,7 @@
   msg_status_t *status;
   msg_content_location_t *location;
   msg_content_language_t *language;
-  msg_accept_language_t *en, *se;
+  msg_accept_language_t *se;
   msg_separator_t *separator;
   msg_payload_t *payload;
 
@@ -614,9 +614,7 @@
 
   msg = read_msg("GET a-life HTTP/1.1" CRLF
 		 "Content-Length: 6" CRLF
-		 "Accept-Encoding: bzip2" CRLF
 		 "Accept-Language: en;q=0.8, fi, se ; q = 0.6" CRLF
-		 "Accept-Encoding: gzip" CRLF
 		 "Foo: bar" CRLF
 		 CRLF
 		 "test" CRLF);
@@ -673,14 +671,6 @@
     TEST(vi, 0);
   }
 
-  /* Test msg_fragment_clear_chain() */
-  en = tst->msg_accept_language;
-  TEST_1(en->aa_common->h_data != NULL);
-  msg_fragment_clear_chain((msg_header_t *)en->aa_next->aa_next);
-  TEST_1(en->aa_common->h_data == NULL);
-  TEST_1(en->aa_next->aa_common->h_data == NULL);
-  TEST_1(en->aa_next->aa_next->aa_common->h_data == NULL);
-
   msg_destroy(msg);
 
   /* Bug #2624: */
@@ -1294,8 +1284,7 @@
   TEST_1(mp->mp_data);
   TEST(memcmp(mp->mp_data, CRLF "--" "LaGqGt4BI6Ho" CRLF, mp->mp_len), 0);
   TEST_1(mp->mp_common->h_data);
-  TEST_M(mp->mp_common->h_data, CRLF "--" "LaGqGt4BI6Ho" "  " CRLF,
-	 mp->mp_common->h_len);
+  //  TEST_M(mp->mp_common->h_data, CRLF "--" "LaGqGt4BI6Ho" "  " CRLF,	 mp->mp_common->h_len);
 
   TEST_1(pl = mp->mp_payload); TEST_1(pl->pl_data);
   TEST_SIZE(strlen("part 1" CRLF), pl->pl_len);
diff -ur a/libsofia-sip-ua/nea/nea_server.c b/libsofia-sip-ua/nea/nea_server.c
--- a/libsofia-sip-ua/nea/nea_server.c	2011-03-11 16:49:18.000000000 +0200
+++ b/libsofia-sip-ua/nea/nea_server.c	2017-12-07 23:25:59.460837865 +0200
@@ -41,7 +41,11 @@
 
 #include "nea_debug.h"
 
+#ifndef _MSC_VER
 #define NONE ((void *)- 1)
+#else
+#define NONE ((void *)(INT_PTR)- 1)
+#endif
 
 #define SU_ROOT_MAGIC_T      struct nea_server_s
 #define SU_MSG_ARG_T         tagi_t
@@ -420,12 +424,12 @@
     throttle = min_throttle;
 
   if (!url) {
-    SU_DEBUG_5(("nea_server_create(): invalid url\n"));
+    SU_DEBUG_5(("nea_server_create(): invalid url\n" VA_NONE));
     return NULL;
   }
 
   if (min_expires > expires || expires > max_expires) {
-    SU_DEBUG_5(("nea_server_create(): invalid expiration range\n"));
+    SU_DEBUG_5(("nea_server_create(): invalid expiration range\n" VA_NONE));
     return NULL;
   }
 
@@ -546,7 +550,7 @@
 			int retry_after)
 {
   nea_sub_t *s;
-  int status = 200;
+//  int status = 200;
   int in_callback;
 
   if (nes == NULL)
@@ -572,8 +576,8 @@
 		   TAG_IF(!retry_after, NEATAG_REASON("deactivated")),
 		   TAG_IF(retry_after, NEATAG_RETRY_AFTER(retry_after)),
 		   TAG_END());
-    else
-      status = 180;
+    //else
+      //status = 180;
   }
 
   nes->nes_in_callback = in_callback;
diff -ur a/libsofia-sip-ua/nta/check_nta.c b/libsofia-sip-ua/nta/check_nta.c
--- a/libsofia-sip-ua/nta/check_nta.c	2011-03-11 16:49:18.000000000 +0200
+++ b/libsofia-sip-ua/nta/check_nta.c	2017-12-07 23:25:59.484837995 +0200
@@ -108,13 +108,10 @@
   suite = suite_create("Unit tests for nta (Sofia-SIP Transaction Engine)");
 
   suite_add_tcase(suite, check_nta_api_1_0());
-
   suite_add_tcase(suite, check_nta_client_2_0());
   suite_add_tcase(suite, check_nta_client_2_1());
   suite_add_tcase(suite, check_nta_client_2_2());
 
-  suite_add_tcase(suite, check_nta_server_3_0());
-
   runner = srunner_create(suite);
 
   if (xml)
@@ -464,8 +461,6 @@
 				      NTATAG_NO_DIALOG(1),
 				      TAG_END());
 
-  s2sip->sut.contact = nta_agent_contact(s2->nta);
-
   return s2->nta;
 }
 
diff -ur a/libsofia-sip-ua/nta/check_nta.h b/libsofia-sip-ua/nta/check_nta.h
--- a/libsofia-sip-ua/nta/check_nta.h	2011-03-11 16:49:18.000000000 +0200
+++ b/libsofia-sip-ua/nta/check_nta.h	2017-12-07 23:25:59.484837995 +0200
@@ -126,11 +126,8 @@
 void s2_nta_teardown(void);
 
 TCase *check_nta_api_1_0(void);
-
 TCase *check_nta_client_2_0(void);
 TCase *check_nta_client_2_1(void);
 TCase *check_nta_client_2_2(void);
 
-TCase *check_nta_server_3_0(void);
-
 #endif
Only in b/libsofia-sip-ua/nta: exit77.c
diff -ur a/libsofia-sip-ua/nta/Makefile.am b/libsofia-sip-ua/nta/Makefile.am
--- a/libsofia-sip-ua/nta/Makefile.am	2011-03-11 16:49:18.000000000 +0200
+++ b/libsofia-sip-ua/nta/Makefile.am	2017-12-07 23:25:59.516838169 +0200
@@ -8,7 +8,7 @@
 # ----------------------------------------------------------------------
 # Header paths
 
-INCLUDES = 		-I$(srcdir)/../ipt -I../ipt \
+AM_CPPFLAGS = 		-I$(srcdir)/../ipt -I../ipt \
 			-I$(srcdir)/../msg -I../msg \
 			-I$(srcdir)/../sip -I../sip \
 			-I$(srcdir)/../bnf -I../bnf \
@@ -26,7 +26,7 @@
 noinst_LTLIBRARIES = 	libnta.la
 
 check_PROGRAMS = 	check_nta test_nta_api test_nta portbind
-dist_noinst_SCRIPTS =	run_check_nta run_test_nta_api run_test_nta
+dist_noinst_SCRIPTS =	run_test_nta_api run_test_nta
 
 TESTS =			run_check_nta run_test_nta_api run_test_nta
 
@@ -69,16 +69,14 @@
 
 if HAVE_CHECK
 
-check_nta_SOURCES =	check_nta.h \
+check_nta_SOURCES =	check_nta.c check_nta.h \
 			check_nta_api.c \
-			check_nta_client.c \
-			check_nta_server.c \
-			check_nta.c
+			check_nta_client.c
 
 check_nta_LDADD = 	${LDADD} @CHECK_LIBS@
 
 else
-check_nta_SOURCES = 	$(top_srcdir)/s2check/exit77.c
+check_nta_SOURCES = 	exit77.c
 endif
 
 # ----------------------------------------------------------------------
@@ -94,4 +92,4 @@
 include $(top_srcdir)/rules/sofia.am
 
 # Generate list of nta tags
-TAG_DLL_FLAGS = 	LIST=nta_tag_list
\ No newline at end of file
+TAG_DLL_FLAGS = 	LIST=nta_tag_list
diff -ur a/libsofia-sip-ua/nta/nta.c b/libsofia-sip-ua/nta/nta.c
--- a/libsofia-sip-ua/nta/nta.c	2011-03-11 16:49:18.000000000 +0200
+++ b/libsofia-sip-ua/nta/nta.c	2017-12-07 23:25:59.532838256 +0200
@@ -47,7 +47,9 @@
  */
 
 #include "config.h"
-
+#ifdef HAVE_ZLIB_COMPRESS
+#include <zlib.h>
+#endif
 #include <sofia-sip/su_string.h>
 
 /** @internal SU message argument structure type */
@@ -104,8 +106,11 @@
 static char const __func__[] = "nta";
 #endif
 
+#ifndef _MSC_VER
 #define NONE ((void *)-1)
-
+#else
+#define NONE ((void *)(INT_PTR)-1)
+#endif
 /* ------------------------------------------------------------------------- */
 
 /** Resolving order */
@@ -146,9 +151,10 @@
   nta_update_magic_t   *sa_update_magic;
   nta_update_tport_f   *sa_update_tport;
 
-  su_time_t             sa_now;	 /**< Timestamp in microsecond resolution. */
+  nta_error_magic_t   *sa_error_magic;
+  nta_error_tport_f   *sa_error_tport;
+
   uint32_t              sa_next; /**< Timestamp for next agent_timer. */
-  uint32_t              sa_millisec; /**< Timestamp in milliseconds. */
 
   msg_mclass_t const   *sa_mclass;
   uint32_t sa_flags;		/**< SIP message flags */
@@ -231,10 +237,14 @@
   unsigned sa_tport_tcp : 1;	/**< Transports support TCP. */
   unsigned sa_tport_sctp : 1;	/**< Transports support SCTP. */
   unsigned sa_tport_tls : 1;	/**< Transports support TLS. */
+  unsigned sa_tport_ws : 1;	    /**< Transports support WS. */
+  unsigned sa_tport_wss : 1;	    /**< Transports support WSS. */
 
   unsigned sa_use_naptr : 1;	/**< Use NAPTR lookup */
   unsigned sa_use_srv : 1;	/**< Use SRV lookup */
 
+  unsigned sa_srv_503 : 1;     /**<  SRV: choice another destination on 503 RFC 3263 */
+  
   unsigned sa_tport_threadpool:1; /**< Transports use threadpool */
 
   unsigned sa_rport:1;		/**< Use rport at client */
@@ -371,6 +381,7 @@
 				 * Request missing @To tag matches
 				 * a tagged leg even after tagging.
 				 */
+  unsigned leg_compressed:1;
   unsigned:0;
   nta_request_f    *leg_callback;
   nta_leg_magic_t  *leg_magic;
@@ -442,6 +453,7 @@
   unsigned irq_must_100rel:1;	/**< 100rel is required */
   unsigned irq_extra_100:1;	/**< 100 Trying should be sent */
   unsigned irq_tag_set:1;	/**< Tag is not from request */
+  unsigned irq_compressed:1;
   unsigned :0;
 
   tp_name_t             irq_tpn[1];
@@ -764,8 +776,8 @@
  *
  * @sa <sofia-sip/su_debug.h>, #su_log_global, #SOFIA_DEBUG
  */
-#if DOXYGEN_ONLY
-char const NTA_DEBUG[]; /* dummy declaration for Doxygen */
+#ifdef DOXYGEN
+extern char const NTA_DEBUG[]; /* dummy declaration for Doxygen */
 #endif
 
 #ifndef SU_DEBUG
@@ -902,6 +914,7 @@
     agent->sa_timestamp       = 0;
     agent->sa_use_naptr       = 1;
     agent->sa_use_srv         = 1;
+    agent->sa_srv_503         = 1;
     agent->sa_auto_comp       = 0;
     agent->sa_server_rport    = 1;
 
@@ -1231,15 +1244,12 @@
 
   agent->sa_next = 0;
 
-  agent->sa_now = stamp;
-  agent->sa_millisec = now;
   agent->sa_in_timer = 1;
 
+
   _nta_outgoing_timer(agent);
   _nta_incoming_timer(agent);
 
-  /* agent->sa_now is used only if sa_millisec != 0 */
-  agent->sa_millisec = 0;
   agent->sa_in_timer = 0;
 
   /* Calculate next timeout */
@@ -1270,17 +1280,15 @@
 
   if (next == latest) {
     /* Do not set timer? */
-    SU_DEBUG_9(("nta: timer not set\n"));
-    assert(!agent->sa_out.completed->q_head);
-    assert(!agent->sa_out.trying->q_head);
-    assert(!agent->sa_out.inv_calling->q_head);
-    assert(!agent->sa_out.re_list);
-    assert(!agent->sa_in.inv_confirmed->q_head);
-    assert(!agent->sa_in.preliminary->q_head);
-    assert(!agent->sa_in.completed->q_head);
-    assert(!agent->sa_in.inv_completed->q_head);
-    assert(!agent->sa_in.re_list);
-    return;
+	/* check it there are still things queued, if there are, that means everything scheduled is > 15 days in the future */
+    /* in this case, we had a large time shift, we should schedule for 15 days in the future (which is probably still before now) */
+	/* and this should sort itself out on the next run through */
+    if ( !agent->sa_out.completed->q_head && !agent->sa_out.trying->q_head && !agent->sa_out.inv_calling->q_head &&
+		 !agent->sa_out.re_list && !agent->sa_in.inv_confirmed->q_head && !agent->sa_in.preliminary->q_head &&
+		 !agent->sa_in.completed->q_head && !agent->sa_in.inv_completed->q_head && !agent->sa_in.re_list ) {
+		SU_DEBUG_9(("nta: timer not set\n" VA_NONE));
+		return;
+	}
   }
 
   if (next == now) if (++next == 0) ++next;
@@ -1324,12 +1332,12 @@
   if (offset == 0)
     return 0;
 
-  if (agent->sa_millisec) /* Avoid expensive call to su_now() */
-    now = agent->sa_now, ms = agent->sa_millisec;
-  else
-    now = su_now(), ms = su_time_ms(now);
+  now = su_now();
+  ms = su_time_ms(now);
+
+  next = ms + offset;
 
-  next = ms + offset; if (next == 0) next = 1;
+  if (next == 0) next = 1;
 
   if (agent->sa_in_timer)	/* Currently executing timer */
     return next;
@@ -1354,9 +1362,6 @@
 static
 su_time_t agent_now(nta_agent_t const *agent)
 {
-  if (agent && agent->sa_millisec != 0)
-    return agent->sa_now;
-  else
     return su_now();
 }
 
@@ -1473,6 +1478,7 @@
   int use_timestamp   = agent->sa_timestamp;
   int use_naptr       = agent->sa_use_naptr;
   int use_srv         = agent->sa_use_srv;
+  int srv_503         = agent->sa_srv_503;
   void *smime         = agent->sa_smime;
   uint32_t flags      = agent->sa_flags;
   int rport           = agent->sa_rport;
@@ -1537,6 +1543,7 @@
 	      /* If threadpool is enabled, start a separate "reaper thread" */
 	      TPTAG_THRPSIZE_REF(threadpool),
 #endif
+              NTATAG_SRV_503_REF(srv_503),
 	      TAG_END());
   nC = tl_gets(tags,
 	       NTATAG_TIMER_C_REF(timer_c),
@@ -1671,7 +1678,7 @@
     progress = 60 * 1000;
   agent->sa_progress = progress;
 
-  if (server_rport > 2)
+  if (server_rport > 3)
     server_rport = 1;
   else if (server_rport < 0)
     server_rport = 1;
@@ -1695,6 +1702,7 @@
   agent->sa_timestamp = use_timestamp != 0;
   agent->sa_use_naptr = use_naptr != 0;
   agent->sa_use_srv = use_srv != 0;
+  agent->sa_srv_503 = srv_503 != 0;
   agent->sa_smime = smime;
   agent->sa_flags = flags & MSG_FLG_USERMASK;
   agent->sa_rport = rport != 0;
@@ -1818,6 +1826,7 @@
 	     NTATAG_USE_NAPTR(agent->sa_use_naptr),
 	     NTATAG_USE_SRV(agent->sa_use_srv),
 	     NTATAG_USE_TIMESTAMP(agent->sa_timestamp),
+	     NTATAG_SRV_503(agent->sa_srv_503),
 	     TAG_END());
 }
 
@@ -2035,22 +2044,24 @@
   char prefix[14];		/**< Prefix for SRV domains */
   char service[10];		/**< NAPTR service */
 }
-#define SIPDNS_TRANSPORTS (4)
+#define SIPDNS_TRANSPORTS (6)
 const sipdns_tports[SIPDNS_TRANSPORTS] = {
   { "udp",  "5060", "_sip._udp.",  "SIP+D2U"  },
   { "tcp",  "5060", "_sip._tcp.",  "SIP+D2T"  },
-  { "sctp", "5060", "_sip._sctp.", "SIP+D2S" },
-  { "tls",  "5061", "_sips._tcp.", "SIPS+D2T"  },
+  { "sctp", "5060", "_sip._sctp.", "SIP+D2S"  },
+  { "tls",  "5061", "_sips._tcp.", "SIPS+D2T" },
+  { "ws",   "5080",   "_sips._ws.",  "SIP+D2W"  },
+  { "wss",  "5081",  "_sips._wss.", "SIPS+D2W" },
 };
 
 static char const * const tports_sip[] =
   {
-    "udp", "tcp", "sctp", NULL
+	"udp", "tcp", "sctp", "ws", NULL
   };
 
 static char const * const tports_sips[] =
   {
-    "tls", NULL
+	  "tls", "wss", "ws", NULL
   };
 
 static tport_stack_class_t nta_agent_class[1] =
@@ -2133,6 +2144,7 @@
   char const * const * tports = tports_sip;
   int error;
   ta_list ta;
+  char *tps[9] = {0};
 
   if (self == NULL) {
     su_seterrno(EINVAL);
@@ -2152,7 +2164,7 @@
     if (url_string_p(uri))
       SU_DEBUG_1(("nta: %s: invalid bind URL\n", uri->us_str));
     else
-      SU_DEBUG_1(("nta: invalid bind URL\n"));
+      SU_DEBUG_1(("nta: invalid bind URL\n" VA_NONE));
     su_seterrno(EINVAL);
     return -1;
   }
@@ -2178,7 +2190,7 @@
   if (url->url_params) {
     if (url_param(url->url_params, "transport", tp, sizeof(tp)) > 0) {
       if (strchr(tp, ',')) {
-	int i; char *t, *tps[9];
+		  int i; char *t;
 
 	/* Split tp into transports */
 	for (i = 0, t = tp; t && i < 8; i++) {
@@ -2239,19 +2251,19 @@
   /* XXX - when to use maddr? */
   if ((agent_init_via(self, tport_primaries(self->sa_tports), 0)) < 0) {
     error = su_errno();
-    SU_DEBUG_1(("nta: cannot create Via headers\n"));
+    SU_DEBUG_1(("nta: cannot create Via headers\n" VA_NONE));
     goto error;
   }
   else
-    SU_DEBUG_9(("nta: Via fields initialized\n"));
+    SU_DEBUG_9(("nta: Via fields initialized\n" VA_NONE));
 
   if ((agent_init_contact(self)) < 0) {
     error = su_errno();
-    SU_DEBUG_1(("nta: cannot create Contact header\n"));
+    SU_DEBUG_1(("nta: cannot create Contact header\n" VA_NONE));
     goto error;
   }
   else
-    SU_DEBUG_9(("nta: Contact header created\n"));
+    SU_DEBUG_9(("nta: Contact header created\n" VA_NONE));
 
   su_free(self->sa_home, url);
   ta_end(ta);
@@ -2269,14 +2281,13 @@
 {
   self->sa_tports =
     tport_tcreate(self, nta_agent_class, self->sa_root,
-		  TPTAG_SDWN_ERROR(0),
 		  TPTAG_IDLE(1800000),
 		  TAG_NEXT(tags));
 
   if (!self->sa_tports)
     return -1;
 
-  SU_DEBUG_9(("nta: master transport created\n"));
+  SU_DEBUG_9(("nta: master transport created\n" VA_NONE));
 
   return 0;
 }
@@ -2301,10 +2312,12 @@
   self->sa_tport_tcp = 0;
   self->sa_tport_sctp = 0;
   self->sa_tport_tls = 0;
+  self->sa_tport_ws = 0;
+  self->sa_tport_wss = 0;
 
   /* Set via fields for the tports */
   for (tp = primaries; tp; tp = tport_next(tp)) {
-    int maddr, first_via;
+    int maddr;
     tp_name_t tpn[1];
     char const *comp = NULL;
 
@@ -2333,11 +2346,13 @@
       self->sa_tport_tcp = 1;
     else if (su_casematch(tpn->tpn_proto, "sctp"))
       self->sa_tport_sctp = 1;
+    else if (su_casematch(tpn->tpn_proto, "ws"))
+      self->sa_tport_ws = 1;
+    else if (su_casematch(tpn->tpn_proto, "wss"))
+      self->sa_tport_wss = 1;
 
     if (tport_has_tls(tp)) self->sa_tport_tls = 1;
 
-    first_via = 1;
-
     ai = tport_get_address(tp);
 
     for (; ai; ai = ai->ai_next) {
@@ -2585,7 +2600,7 @@
     clear = 1, v->v_port = via->v_port;
 
   if (clear)
-    msg_fragment_clear_chain((msg_header_t *)v);
+    msg_fragment_clear(v->v_common);
 
   return 0;
 }
@@ -2676,8 +2691,12 @@
 
   tpn->tpn_ident = NULL;
 
-  if (tpn->tpn_proto)
+  if (tpn->tpn_proto) {
+	  if (su_casematch(url->url_scheme, "sips") && su_casematch(tpn->tpn_proto, "ws")) {
+		  tpn->tpn_proto = "wss";
+	  }
     return 1;
+  }
 
   if (su_casematch(url->url_scheme, "sips"))
     tpn->tpn_proto = "tls";
@@ -2698,6 +2717,10 @@
 	  "nta_agent: tport: %s%s%s\n",
 	  remote ? remote : "", remote ? ": " : "",
 	  su_strerror(errcode));
+
+  if (agent->sa_error_tport) {
+    agent->sa_error_tport(agent->sa_error_magic, agent, tport);
+  }
 }
 
 /** Handle updated transport addresses */
@@ -2733,6 +2756,18 @@
 				sip_via_t *, tport_t*);
 static void agent_recv_garbage(nta_agent_t*, msg_t*, tport_t*);
 
+#if HAVE_SOFIA_SRESOLV
+static void outgoing_resolve(nta_outgoing_t *orq,
+			     int explicit_transport,
+			     enum nta_res_order_e order);
+su_inline void outgoing_cancel_resolver(nta_outgoing_t *orq);
+su_inline void outgoing_destroy_resolver(nta_outgoing_t *orq);
+static int outgoing_other_destinations(nta_outgoing_t const *orq);
+static int outgoing_try_another(nta_outgoing_t *orq);
+#else
+#define outgoing_other_destinations(orq) (0)
+#define outgoing_try_another(orq) (0)
+#endif
 
 /** Handle incoming message. */
 static
@@ -2744,8 +2779,6 @@
 {
   sip_t *sip = sip_object(msg);
 
-  agent->sa_millisec = su_time_ms(agent->sa_now = now);
-
   if (sip && sip->sip_request) {
     agent_recv_request(agent, msg, sip, tport);
   }
@@ -2755,9 +2788,72 @@
   else {
     agent_recv_garbage(agent, msg, tport);
   }
+}
+
+#ifdef HAVE_ZLIB_COMPRESS
+int sip_content_encoding_Xflate(msg_t *msg, sip_t *sip, int inflate, int check)
+{
+	char const *method_name;
+	unsigned cseq = sip->sip_cseq ? sip->sip_cseq->cs_seq : 0;
+	int ok = !check;
+
+	if (!sip->sip_payload) {
+		return 0;
+	}
 
-  agent->sa_millisec = 0;
+	if (sip->sip_request) {
+		method_name = sip->sip_request->rq_method_name;
+	} else if (sip->sip_cseq) {
+		method_name = sip->sip_cseq->cs_method_name;
+	} else {
+		method_name = "Unknown";
+	}
+
+	if (!ok) {
+		if (sip->sip_content_encoding && sip->sip_content_encoding->k_items) {
+			const char *val = sip->sip_content_encoding->k_items[0];
+			if (val && (!strcasecmp(val, "gzip") || !strcasecmp(val, "deflate"))) {
+				ok = 1;
+			}
+		}
+	}
+
+	if (ok) {
+		unsigned long n = 0;
+		void *decoded = NULL;
+		const char *id = "N/A";
+		const char *orig_payload = sip->sip_payload->pl_data;
+
+		n = sip->sip_payload->pl_len * 10;
+		  
+		decoded = su_alloc(msg_home(msg), n);
+		assert(decoded);
+
+		if (inflate) {
+			uncompress(decoded, &n, (void *)sip->sip_payload->pl_data, (unsigned long)sip->sip_payload->pl_len);
+		} else {
+			compress(decoded, &n, (void *)sip->sip_payload->pl_data, (unsigned long)sip->sip_payload->pl_len);
+		}
+		  
+		sip->sip_payload = sip_payload_create(msg_home(msg), decoded, n);
+		sip->sip_content_encoding = sip_content_encoding_make(msg_home(msg), "deflate");
+
+		if (sip->sip_call_id) {
+			id = sip->sip_call_id->i_id;
+		}
+
+		if (inflate) {
+			SU_DEBUG_1(("nta: %s (%u) (%s) Inflating compressed body:\n%s\n", method_name, cseq, id, (char *)decoded));
+		} else {
+			SU_DEBUG_1(("nta: %s (%u) (%s) Deflating compressed body:\n%s\n", method_name, cseq, id, orig_payload));
+		}
+
+		return 1;
+	}
+ 
+  return 0;
 }
+#endif
 
 /** @internal Handle incoming requests. */
 static
@@ -2773,6 +2869,7 @@
   url_t url[1];
   unsigned cseq = sip->sip_cseq ? sip->sip_cseq->cs_seq : 0;
   int insane, errors, stream;
+  unsigned compressed = 0;
 
   agent->sa_stats->as_recv_msg++;
   agent->sa_stats->as_recv_request++;
@@ -2895,6 +2992,10 @@
     return;
   }
 
+#ifdef HAVE_ZLIB_COMPRESS
+  compressed = sip_content_encoding_Xflate(msg, sip, 1, 1);
+#endif
+
   /* First, try existing incoming requests */
   irq = incoming_find(agent, sip, sip->sip_via,
 		      agent->sa_merge_482 &&
@@ -2949,7 +3050,7 @@
   url->url_params = NULL;
   agent_aliases(agent, url, tport); /* canonize urls */
 
-  if ((leg = leg_find(agent,
+  if (method != sip_method_subscribe && (leg = leg_find(agent,
 		      method_name, url,
 		      sip->sip_call_id,
 		      sip->sip_from->a_tag,
@@ -2957,6 +3058,7 @@
     /* Try existing dialog */
     SU_DEBUG_5(("nta: %s (%u) %s\n",
 		method_name, cseq, "going to existing leg"));
+	leg->leg_compressed = compressed;
     leg_recv(leg, msg, sip, tport);
     return;
   }
@@ -2965,6 +3067,7 @@
     /* Dialogless legs - let application process transactions statefully */
     SU_DEBUG_5(("nta: %s (%u) %s\n",
 		method_name, cseq, "going to a dialogless leg"));
+	leg->leg_compressed = compressed;
     leg_recv(leg, msg, sip, tport);
   }
   else if (!agent->sa_is_stateless && (leg = agent->sa_default_leg)) {
@@ -2980,6 +3083,7 @@
     else {
       SU_DEBUG_5(("nta: %s (%u) %s\n",
 		  method_name, cseq, "going to a default leg"));
+	  leg->leg_compressed = compressed;
       leg_recv(leg, msg, sip, tport);
     }
   }
@@ -3065,8 +3169,6 @@
       hostport[rlen] = '\0';
     }
 
-    msg_fragment_clear_chain((msg_header_t *)v);
-
     msg_header_replace_param(msg_home(msg), v->v_common,
 			     su_strdup(msg_home(msg), received));
     SU_DEBUG_5(("nta: Via check: %s\n", received));
@@ -3083,7 +3185,12 @@
     rport = su_sprintf(msg_home(msg), "rport=%u", ntohs(from->su_port));
     msg_header_replace_param(msg_home(msg), v->v_common, rport);
   }
-  else if (agent->sa_server_rport == 2) {
+  else if (agent->sa_server_rport == 2 ||
+		   (agent->sa_server_rport == 3 && sip && sip->sip_user_agent &&
+			sip->sip_user_agent->g_string &&
+			(!strncasecmp(sip->sip_user_agent->g_string, "Polycom", 7) ||
+			 !strncasecmp(sip->sip_user_agent->g_string, "KIRK Wireless Server", 20) ||
+			 !strncasecmp(sip->sip_user_agent->g_string, "ADTRAN_Total_Access", 19)))) {
     rport = su_sprintf(msg_home(msg), "rport=%u", ntohs(from->su_port));
     msg_header_replace_param(msg_home(msg), v->v_common, rport);
   }
@@ -3181,6 +3288,9 @@
     sip->sip_cseq ? sip->sip_cseq->cs_method_name : "<UNKNOWN>";
   uint32_t cseq = sip->sip_cseq ? sip->sip_cseq->cs_seq : 0;
   nta_outgoing_t *orq;
+  su_home_t *home;
+  char const *branch = NONE;
+
 
   agent->sa_stats->as_recv_msg++;
   agent->sa_stats->as_recv_response++;
@@ -3247,13 +3357,33 @@
 
   /* XXX - should check if msg should be discarded based on via? */
 
+#ifdef HAVE_ZLIB_COMPRESS
+  sip_content_encoding_Xflate(msg, sip, 1, 1);
+#endif
+
   if ((orq = outgoing_find(agent, msg, sip, sip->sip_via))) {
     SU_DEBUG_5(("nta: %03d %s %s\n",
 		status, phrase, "is going to a transaction"));
-    if (outgoing_recv(orq, status, msg, sip) == 0)
+      /* RFC3263 4.3 "503 error response" */
+      if(agent->sa_srv_503 && status == 503 && outgoing_other_destinations(orq)) {
+              SU_DEBUG_5(("%s(%p): <%03d> for <%s>, %s\n", "nta", (void *)orq, status, method, "try next after timeout"));
+              home = msg_home(msg);
+              if (agent->sa_is_stateless)
+                    branch = stateless_branch(agent, msg, sip, orq->orq_tpn);
+              else
+                    branch = stateful_branch(home, agent);
+
+             orq->orq_branch = branch;
+             orq->orq_via_branch = branch;
+             outgoing_try_another(orq);
+             return;
+      }						
+      		
+     if (outgoing_recv(orq, status, msg, sip) == 0)
       return;
   }
 
+
   agent->sa_stats->as_trless_response++;
 
   if ((orq = agent->sa_default_outgoing)) {
@@ -3790,8 +3920,10 @@
   return 0;
 
  err:
-  msg_destroy(amsg);
+
   msg_destroy(bmsg);
+  msg_destroy(amsg);
+
   return -1;
 }
 
@@ -3898,7 +4030,7 @@
     if (rq->rq_url->url_params) {
       rq->rq_url->url_params =
 	url_strip_param_string((char *)rq->rq_url->url_params, "method");
-      msg_fragment_clear(rq->rq_common);
+      sip_fragment_clear(rq->rq_common);
     }
 
     if (rq->rq_url->url_headers) {
@@ -3909,8 +4041,7 @@
 	  return -1;
 	msg_header_parse_str(msg, (msg_pub_t*)sip, s);
       }
-      rq->rq_url->url_headers = NULL;
-      msg_fragment_clear(rq->rq_common);
+      rq->rq_url->url_headers = NULL, sip_fragment_clear(rq->rq_common);
     }
   }
 
@@ -3928,7 +4059,7 @@
     sip_from_tag(home, sip->sip_from, leg->leg_local->a_tag);
 
   if (sip->sip_from && !sip->sip_from->a_tag) {
-    msg_fragment_clear(sip->sip_from->a_common);
+    sip_fragment_clear(sip->sip_from->a_common);
     sip_from_add_param(home, sip->sip_from,
 		       nta_agent_newtag(home, "tag=%s", leg->leg_agent));
   }
@@ -3995,7 +4126,18 @@
 static int leg_callback_default(nta_leg_magic_t*, nta_leg_t*,
 				nta_incoming_t*, sip_t const *);
 #define HTABLE_HASH_LEG(leg) ((leg)->leg_hash)
+
+#ifdef __clang__
+#pragma clang diagnostic push
+#pragma clang diagnostic ignored "-Wunused-function"
+#endif
+
 HTABLE_BODIES_WITH(leg_htable, lht, nta_leg_t, HTABLE_HASH_LEG, size_t, hash_value_t);
+
+#ifdef __clang__
+#pragma clang diagnostic pop
+#endif
+
 su_inline
 hash_value_t hash_istring(char const *, char const *, hash_value_t);
 
@@ -4127,7 +4269,7 @@
   if (i == NONE) /* Magic value, used for compatibility */
     no_dialog = 1;
 
-  if (!(leg = su_home_clone(agent->sa_home, sizeof(*leg))))
+  if (!(leg = su_home_clone(NULL, sizeof(*leg))))
     return NULL;
   home = leg->leg_home;
 
@@ -4356,7 +4498,8 @@
 static
 void leg_free(nta_agent_t *sa, nta_leg_t *leg)
 {
-  su_free(sa->sa_home, leg);
+	//su_free(sa->sa_home, leg);
+	su_home_unref((su_home_t *)leg);
 }
 
 /** Return application context for the leg */
@@ -4716,6 +4859,7 @@
     return;
   }
 
+  irq->irq_compressed = leg->leg_compressed;
   irq->irq_in_callback = 1;
   status = incoming_callback(leg, irq, sip);
   irq->irq_in_callback = 0;
@@ -4750,6 +4894,7 @@
     nta_incoming_destroy(irq);
 }
 
+#if 0
 /**Compare two SIP from/to fields.
  *
  * @retval nonzero if matching.
@@ -4766,6 +4911,7 @@
       su_strcmp(a->url_port, b->url_port) ||
       su_strcmp(a->url_user, b->url_user);
 }
+#endif
 
 /** Get a leg by dialog.
  *
@@ -5289,7 +5435,7 @@
     }
     irq->irq_branch  = sip->sip_via->v_branch;
     irq->irq_reliable_tp = tport_is_reliable(tport);
-    irq->irq_extra_100 = 1; /* Sending extra 100 trying true by default */
+    irq->irq_extra_100 = 0; /* Sending extra 100 trying false by default */
 
     if (sip->sip_timestamp)
       irq->irq_timestamp = sip_timestamp_copy(home, sip->sip_timestamp);
@@ -6030,7 +6176,7 @@
   if (irq->irq_status >= 100) {
     SU_DEBUG_5(("nta: re-received %s request, retransmitting %u reply\n",
 		sip->sip_request->rq_method_name, irq->irq_status));
-    incoming_retransmit_reply(irq, tport);
+	 incoming_retransmit_reply(irq, tport);
   }
   else if (irq->irq_agent->sa_extra_100 &&
            irq->irq_extra_100) {
@@ -6515,6 +6661,12 @@
     return -1;
   }
 
+#ifdef HAVE_ZLIB_COMPRESS
+  if (irq->irq_compressed) {
+	  sip_content_encoding_Xflate(msg, sip, 0, 0);
+  }
+#endif
+
   if (irq->irq_must_100rel && !sip->sip_rseq && status > 100 && status < 200) {
     /* This nta_reliable_t object will be destroyed by PRACK or timeout */
     if (nta_reliable_mreply(irq, NULL, NULL, msg))
@@ -6809,7 +6961,7 @@
 static void
 _nta_incoming_timer(nta_agent_t *sa)
 {
-  uint32_t now = sa->sa_millisec;
+  uint32_t now = su_time_ms(su_now());
   nta_incoming_t *irq, *irq_next;
   size_t retransmitted = 0, timeout = 0, terminated = 0, destroyed = 0;
   size_t unconfirmed =
@@ -6826,6 +6978,9 @@
 
   /* Handle retry queue */
   while ((irq = sa->sa_in.re_list)) {
+
+	  now = su_time_ms(su_now());
+
     if ((int32_t)(irq->irq_retry - now) > 0)
       break;
     if (retransmitted >= timer_max_retransmit)
@@ -6883,6 +7038,8 @@
   }
 
   while ((irq = sa->sa_in.final_failed->q_head)) {
+	  
+
     incoming_remove(irq);
     irq->irq_final_failed = 0;
 
@@ -6914,6 +7071,8 @@
     assert(irq->irq_status < 200);
     assert(irq->irq_timeout);
 
+	now = su_time_ms(su_now());
+
     if ((int32_t)(irq->irq_timeout - now) > 0)
       break;
     if (timeout >= timer_max_timeout)
@@ -6934,6 +7093,8 @@
     assert(irq->irq_timeout);
     assert(irq->irq_method == sip_method_invite);
 
+	now = su_time_ms(su_now());
+
     if ((int32_t)(irq->irq_timeout - now) > 0 ||
 	timeout >= timer_max_timeout ||
 	terminated >= timer_max_terminate)
@@ -6962,6 +7123,8 @@
     assert(irq->irq_status >= 200);
     assert(irq->irq_method == sip_method_invite);
 
+	now = su_time_ms(su_now());
+
     if ((int32_t)(irq->irq_timeout - now) > 0 ||
 	terminated >= timer_max_terminate)
       break;
@@ -6984,6 +7147,8 @@
     assert(irq->irq_timeout);
     assert(irq->irq_method != sip_method_invite);
 
+	now = su_time_ms(su_now());	
+
     if ((int32_t)(irq->irq_timeout - now) > 0 ||
 	terminated >= timer_max_terminate)
       break;
@@ -7003,6 +7168,7 @@
   }
 
   for (irq = sa->sa_in.terminated->q_head; irq; irq = irq_next) {
+	  
     irq_next = irq->irq_next;
     if (irq->irq_destroyed)
       incoming_free_queue(rq, irq);
@@ -7056,9 +7222,18 @@
 
 #define HTABLE_HASH_ORQ(orq) ((orq)->orq_hash)
 
+#ifdef __clang__
+#pragma clang diagnostic push
+#pragma clang diagnostic ignored "-Wunused-function"
+#endif
+
 HTABLE_BODIES_WITH(outgoing_htable, oht, nta_outgoing_t, HTABLE_HASH_ORQ,
 		   size_t, hash_value_t);
 
+#ifdef __clang__
+#pragma clang diagnostic pop
+#endif
+
 static int outgoing_features(nta_agent_t *agent, nta_outgoing_t *orq,
 			      msg_t *msg, sip_t *sip,
 			      tagi_t *tags);
@@ -7113,19 +7288,6 @@
 			       nta_outgoing_t *request,
 			       sip_t const *sip);
 
-#if HAVE_SOFIA_SRESOLV
-static void outgoing_resolve(nta_outgoing_t *orq,
-			     int explicit_transport,
-			     enum nta_res_order_e order);
-su_inline void outgoing_cancel_resolver(nta_outgoing_t *orq);
-su_inline void outgoing_destroy_resolver(nta_outgoing_t *orq);
-static int outgoing_other_destinations(nta_outgoing_t const *orq);
-static int outgoing_try_another(nta_outgoing_t *orq);
-#else
-#define outgoing_other_destinations(orq) (0)
-#define outgoing_try_another(orq) (0)
-#define outgoing_cancel_resolver(orq) ((void)0)
-#endif
 
 /** Create a default outgoing transaction.
  *
@@ -7686,8 +7848,12 @@
   sip = sip_object(msg);
   home = msg_home(msg);
 
+#ifdef HAVE_ZLIB_COMPRESS
+  sip_content_encoding_Xflate(msg, sip_object(msg), 0, 1);
+#endif
+
   if (!sip->sip_request || sip_complete_message(msg) < 0) {
-    SU_DEBUG_3(("nta: outgoing_create: incomplete request\n"));
+    SU_DEBUG_3(("nta: outgoing_create: incomplete request\n" VA_NONE));
     return NULL;
   }
 
@@ -7780,7 +7946,7 @@
   if (tpn) {
     /* CANCEL or ACK to [3456]XX */
     invalid = tport_name_dup(home, orq->orq_tpn, tpn);
-#if HAVE_SOFIA_SRESOLV
+#if 0 //HAVE_SOFIA_SRESOLV
     /* We send ACK or CANCEL only if original request was really sent */
     assert(tport_name_is_resolved(orq->orq_tpn));
 #endif
@@ -7808,7 +7974,7 @@
     if (invalid >= 0) {
       explicit_transport = invalid > 0;
       resolved = tport_name_is_resolved(orq->orq_tpn);
-      msg_fragment_clear(sip->sip_request->rq_common);
+      sip_fragment_clear(sip->sip_request->rq_common);
     }
     orq->orq_url = url_hdup(home, sip->sip_request->rq_url);
   }
@@ -7832,7 +7998,7 @@
     else
       branch = su_sprintf(home, "branch=%s", branch);
   }
-  else if (orq->orq_user_via && sip->sip_via->v_branch)
+  else if (orq->orq_user_via && sip->sip_via->v_branch && orq->orq_method != sip_method_invite )
     branch = su_sprintf(home, "branch=%s", sip->sip_via->v_branch);
   else if (stateless)
     branch = stateless_branch(agent, msg, sip, orq->orq_tpn);
@@ -7874,7 +8040,7 @@
 	}
       }
       else {
-	SU_DEBUG_1(("outgoing_create: ACK without INVITE\n"));
+	SU_DEBUG_1(("outgoing_create: ACK without INVITE\n" VA_NONE));
 	assert(!"INVITE found for ACK");
       }
     }
@@ -7961,11 +8127,11 @@
     outgoing_send_via(orq, tp);
   }
   else if (orq->orq_sips) {
-    SU_DEBUG_3(("nta outgoing create: no secure transport\n"));
+    SU_DEBUG_3(("nta outgoing create: no secure transport\n" VA_NONE));
     outgoing_reply(orq, SIP_416_UNSUPPORTED_URI, 1);
   }
   else {
-    SU_DEBUG_3(("nta outgoing create: no transport protocol\n"));
+    SU_DEBUG_3(("nta outgoing create: no transport protocol\n" VA_NONE));
     outgoing_reply(orq, 503, "No transport", 1);
   }
 }
@@ -7987,7 +8153,7 @@
   if (old_tp) tport_unref(old_tp);
 
   if (outgoing_insert_via(orq, agent_tport_via(tp)) < 0) {
-    SU_DEBUG_3(("nta outgoing create: cannot insert Via line\n"));
+    SU_DEBUG_3(("nta outgoing create: cannot insert Via line\n" VA_NONE));
     outgoing_reply(orq, 503, "Cannot insert Via", 1);
     return;
   }
@@ -8175,9 +8341,12 @@
 
   if (orq->orq_method == sip_method_ack)
     ;
-  else if (!orq->orq_reliable)
-    outgoing_set_timer(orq, agent->sa_t1); /* Timer A/E */
-  else if (orq->orq_try_tcp_instead && !tport_is_connected(tp))
+  else if (!orq->orq_reliable) {
+    /* race condition on initial t1 timer timeout, set minimum initial timeout to 1000ms */
+	unsigned t1_timer = agent->sa_t1;
+	if (t1_timer < 1000) t1_timer = 1000;
+    outgoing_set_timer(orq, t1_timer); /* Timer A/E */
+  } else if (orq->orq_try_tcp_instead && !tport_is_connected(tp))
     outgoing_set_timer(orq, agent->sa_t4); /* Timer N3 */
 }
 
@@ -8196,7 +8365,7 @@
   tp = tport_by_name(orq->orq_agent->sa_tports, tpn);
   if (tp && tp != orq->orq_tport) {
     sip_t *sip = sip_object(orq->orq_request);
-    msg_fragment_clear_chain((msg_header_t *)sip->sip_via);
+    sip_fragment_clear(sip->sip_via->v_common);
     sip->sip_via->v_protocol = sip_transport_tcp;
 
     SU_DEBUG_5(("nta: %s (%u) too large for UDP, trying TCP\n",
@@ -8243,7 +8412,7 @@
   if (tp && tp != orq->orq_tport) {
     sip_t *sip = sip_object(orq->orq_request);
 
-    msg_fragment_clear_chain((msg_header_t *)sip->sip_via);
+    sip_fragment_clear(sip->sip_via->v_common);
     sip->sip_via->v_protocol = sip_transport_udp;
 
     SU_DEBUG_5(("nta: %s (%u) TCP %s, trying UDP\n",
@@ -8289,6 +8458,14 @@
       return;
     }
   }
+  else if (error == 0) {
+    /*
+     * Server closed connection. RFC3261:
+     * "there is no coupling between TCP connection state and SIP
+     * processing."
+     */
+    return;
+  }
 
   if (outgoing_other_destinations(orq)) {
     outgoing_print_tport_error(orq, 5, "trying alternative server after ",
@@ -8435,7 +8612,7 @@
 	       nta_outgoing_t *orq)
 {
   if (orq->orq_queue == queue) {
-    assert(queue->q_timeout == 0);
+	//assert(queue->q_timeout == 0);
     return;
   }
 
@@ -8669,7 +8846,7 @@
 static void
 _nta_outgoing_timer(nta_agent_t *sa)
 {
-  uint32_t now = sa->sa_millisec;
+  uint32_t now = su_time_ms(su_now());
   nta_outgoing_t *orq;
   outgoing_queue_t rq[1];
   size_t retransmitted = 0, terminated = 0, timeout = 0, destroyed;
@@ -8683,6 +8860,9 @@
   outgoing_queue_init(sa->sa_out.free = rq, 0);
 
   while ((orq = sa->sa_out.re_list)) {
+
+	  now = su_time_ms(su_now());
+
     if ((int32_t)(orq->orq_retry - now) > 0)
       break;
     if (retransmitted >= timer_max_retransmit)
@@ -8890,8 +9070,6 @@
       return outgoing_terminate(orq);
   }
 
-  outgoing_cancel_resolver(orq);
-
   if (orq->orq_method == sip_method_invite) {
     if (orq->orq_queue != orq->orq_agent->sa_out.inv_completed)
       outgoing_queue(orq->orq_agent->sa_out.inv_completed, orq); /* Timer D */
@@ -8995,8 +9173,6 @@
 {
   orq->orq_terminated = 1;
 
-  outgoing_cancel_resolver(orq);
-
   if (!orq->orq_destroyed) {
     outgoing_queue(orq->orq_agent->sa_out.terminated, orq);
     return 0;
@@ -9163,8 +9339,7 @@
 
     if (status < 200) {
       outgoing_send(cancel, 0);
-      if (outgoing_complete(orq))
-	return 0;
+      outgoing_complete(orq);
     }
     else {
       outgoing_reply(cancel, SIP_481_NO_TRANSACTION, 0);
@@ -9187,7 +9362,7 @@
     if (orq->orq_destroyed && 200 <= status && status < 300) {
       if (orq->orq_uas && su_strcasecmp(sip->sip_to->a_tag, orq->orq_tag) != 0) {
         /* Orphan 200 Ok to INVITE. ACK and BYE it */
-        SU_DEBUG_5(("nta: Orphan 200 Ok send ACK&BYE\n"));
+		  SU_DEBUG_5(("nta: Orphan 200 Ok send ACK&BYE %p\n", (void *)orq));
         return nta_msg_ackbye(sa, msg);
       }
       return -1;  /* Proxy statelessly (RFC3261 section 16.11) */
@@ -9249,7 +9424,7 @@
 	    return outgoing_duplicate(orq, msg, sip);
 
           /* Orphan 200 Ok to INVITE. ACK and BYE it */
-          SU_DEBUG_5(("nta: Orphan 200 Ok send ACK&BYE"));
+          SU_DEBUG_5(("nta: Orphan 200 Ok send ACK&BYE" VA_NONE));
           return nta_msg_ackbye(sa, msg);
 	}
       }
@@ -9261,7 +9436,9 @@
     /* Non-INVITE */
     if (orq->orq_queue == sa->sa_out.trying ||
 	orq->orq_queue == sa->sa_out.resolving) {
-      assert(orq->orq_status < 200);
+	  /* hacked by freeswitch, this is being hit by options 404 status with 404 orq->orq_status and orq_destroyed = 1, orq_completed = 1 */  
+	  /*      assert(orq->orq_status < 200); */
+	  if (orq->orq_status >= 200) {msg_destroy(msg); return 0;}
 
       if (status < 200) {
 	/* @RFC3261 17.1.2.1:
@@ -9274,23 +9451,15 @@
          */
  	if (!orq->orq_reliable)
 	  orq->orq_interval = sa->sa_t2;
-
-#if notyet		       /* Destination has been already flushed */
-	if (orq->orq_queue == sa->sa_out.resolving) {
-	  /* A response from (previously resolved) destination? */
-	  outgoing_cancel_resolver(orq);
-	  outgoing_trying(orq);
-	}
-#endif
       }
-      else if (outgoing_complete(orq)) {
-	msg_destroy(msg);	/* Transaction was terminated and destroyed */
-	return 0;
-      }
-      else {
+      else if (!outgoing_complete(orq)) {
 	if (orq->orq_sigcomp_zap && orq->orq_tport && orq->orq_cc)
 	  agent_zap_compressor(orq->orq_agent, orq->orq_cc);
       }
+      else /* outgoing_complete */ {
+	msg_destroy(msg);
+	return 0;
+      }
     }
     else {
       /* Already completed or terminated */
@@ -9909,9 +10078,6 @@
 {
   struct sipdns_resolver *sr = orq->orq_resolver;
 
-  if (orq->orq_completed)
-    return 0;
-
   if (sr == NULL) {
     outgoing_resolving_error(orq, SIP_500_INTERNAL_SERVER_ERROR);
     return 0;
@@ -9960,12 +10126,7 @@
 static int
 outgoing_other_destinations(nta_outgoing_t const *orq)
 {
-  struct sipdns_resolver *sr;
-
-  if (orq->orq_completed)
-    return 0;
-
-  sr = orq->orq_resolver;
+  struct sipdns_resolver *sr = orq->orq_resolver;
 
   if (!sr)
     return 0;
@@ -10074,7 +10235,9 @@
 {
   struct sipdns_resolver *sr = orq->orq_resolver;
 
-  if (sr && sr->sr_query)    /* Cancel resolver query */
+  assert(orq->orq_resolver);
+
+  if (sr->sr_query)    /* Cancel resolver query */
       sres_query_bind(sr->sr_query, NULL, NULL), sr->sr_query = NULL;
 }
 
@@ -10085,8 +10248,7 @@
 
   assert(orq->orq_resolver);
 
-  if (sr->sr_query)    /* Cancel resolver query */
-    sres_query_bind(sr->sr_query, NULL, NULL), sr->sr_query = NULL;
+  outgoing_cancel_resolver(orq);
 
   su_free(orq->orq_agent->sa_home, sr);
 
@@ -10745,9 +10907,6 @@
   else
     sr->sr_current = NULL;
 
-  if (orq->orq_completed)
-    return;
-
   if (rlen > 0) {
     orq->orq_resolved = 1;
     orq->orq_tpn->tpn_host = results[0];
@@ -11038,7 +11197,6 @@
 	if (rel->rel_rseq == rack->ra_response)
 	  return (nta_reliable_t  *)rel;
 
-      return NULL;
     }
   }
 
@@ -11760,6 +11918,18 @@
   return 0;
 }
 
+/** Bind transport error callback */
+int nta_agent_bind_tport_error(nta_agent_t *agent,
+				nta_error_magic_t *magic,
+				nta_error_tport_f *callback)
+{
+  if (!agent)
+    return su_seterrno(EFAULT), -1;
+  agent->sa_error_magic = magic;
+  agent->sa_error_tport = callback;
+  return 0;
+}
+
 /** Check if public transport binding is in progress */
 int nta_agent_tport_is_updating(nta_agent_t *agent)
 {
diff -ur a/libsofia-sip-ua/nta/nta_check.c b/libsofia-sip-ua/nta/nta_check.c
--- a/libsofia-sip-ua/nta/nta_check.c	2011-03-11 16:49:18.000000000 +0200
+++ b/libsofia-sip-ua/nta/nta_check.c	2017-12-07 23:25:59.532838256 +0200
@@ -248,7 +248,9 @@
   if (!sip->sip_content_encoding ||
       !sip->sip_content_encoding->k_items ||
       !sip->sip_content_encoding->k_items[0] ||
-      !sip->sip_content_encoding->k_items[0][0])
+      !sip->sip_content_encoding->k_items[0][0] ||
+	  !strcasecmp(sip->sip_content_encoding->k_items[0], "gzip") ||
+	  !strcasecmp(sip->sip_content_encoding->k_items[0], "deflate"))
     acceptable_encoding = 1;
 
   if (acceptable_type && acceptable_encoding)
diff -ur a/libsofia-sip-ua/nta/nta_tag.c b/libsofia-sip-ua/nta/nta_tag.c
--- a/libsofia-sip-ua/nta/nta_tag.c	2011-03-11 16:49:18.000000000 +0200
+++ b/libsofia-sip-ua/nta/nta_tag.c	2017-12-07 23:25:59.548838343 +0200
@@ -1470,6 +1470,29 @@
  */
 tag_typedef_t ntatag_use_srv = BOOLTAG_TYPEDEF(srv);
 
+/**@def NTATAG_SRV_503(x)
+ *
+ * If true, try to use another destination from SRV records on 503 response. RFC3263
+ *
+ * The application can disable NTA from using a new route after 503
+ *
+ * @par Used with
+ *    nua_create(), nua_set_params(), agent_recv_response(),
+ *    nta_agent_create(), nta_agent_set_params()
+ *
+ * @par Parameter type
+ *    boolean: true (non-zero or non-NULL pointer)
+ *          or false (zero or NULL pointer)
+ *
+ * @par Values
+ *    - true - enable new destination on 503
+ *    - false - still use the same destination after timeout
+ *
+ * @sa @RFC3263
+ */
+tag_typedef_t ntatag_srv_503 = BOOLTAG_TYPEDEF(srv_503);
+
+
 /**@def NTATAG_RSEQ(x)
  *
  * @RSeq value for nta_outgoing_prack().
diff -ur a/libsofia-sip-ua/nta/portbind.c b/libsofia-sip-ua/nta/portbind.c
--- a/libsofia-sip-ua/nta/portbind.c	2011-03-11 16:49:18.000000000 +0200
+++ b/libsofia-sip-ua/nta/portbind.c	2017-12-07 23:25:59.552838365 +0200
@@ -93,20 +93,12 @@
   int af;
   su_socket_t s;
   socklen_t salen;
-  union {
-    struct sockaddr sa[1];
-    struct sockaddr_in sin[1];
-    struct sockaddr_storage ss[1];
-#if HAVE_SIN6
-    struct sockaddr_in6 sin6[1];
-#endif
-  } addr;
-  struct sockaddr_storage *ss = addr.ss;
-  struct sockaddr *sa = addr.sa;
-  struct sockaddr_in *sin = addr.sin;
+  struct sockaddr_storage ss[1];
+  struct sockaddr *sa = (void *)ss;
+  struct sockaddr_in *sin = (void *)ss;
 #if HAVE_SIN6
   int o_ip6 = 0, o_ip4 = 0;
-  struct sockaddr_in6 *sin6 = addr.sin6;
+  struct sockaddr_in6 *sin6 = (void *)ss;
 #endif
 
   for (argv++; *argv && **argv == '-';) {
@@ -159,7 +151,7 @@
   af = AF_INET;
 #endif
 
-  memset(ss, 0, sizeof *ss);
+  memset(ss, 0, sizeof ss);
 
   if (!o_tcp || !o_udp || !o_sctp || !o_protocol)
     o_tcp = o_udp = 1;
@@ -226,15 +218,11 @@
     }
 
     if (portno == 0) {
-      union {
-	struct sockaddr sa[1];
-	struct sockaddr_in sin[1];
-	struct sockaddr_storage ss[1];
-      } addr;
-      struct sockaddr *sa = addr.sa;
-      struct sockaddr_in *sin = addr.sin;
+      struct sockaddr_storage ss[1];
+      struct sockaddr *sa = (void *)ss;
+      struct sockaddr_in *sin = (void *)ss;
 
-      salen = sizeof addr;
+      salen = sizeof *ss;
       if (getsockname(s, sa, &salen) == -1) {
 	fprintf(stderr, "%s: getsockname(): %s\n", name, strerror(errno));
 	exit(1);
diff -ur a/libsofia-sip-ua/nta/sofia-sip/nta_tag.h b/libsofia-sip-ua/nta/sofia-sip/nta_tag.h
--- a/libsofia-sip-ua/nta/sofia-sip/nta_tag.h	2011-03-11 16:49:18.000000000 +0200
+++ b/libsofia-sip-ua/nta/sofia-sip/nta_tag.h	2017-12-07 23:26:01.124846890 +0200
@@ -393,6 +393,12 @@
 NTA_DLL extern tag_typedef_t ntatag_use_srv_ref;
 #define NTATAG_USE_SRV_REF(x) ntatag_use_srv_ref, tag_bool_vr(&(x))
 
+NTA_DLL extern tag_typedef_t ntatag_srv_503;
+#define NTATAG_SRV_503(x) ntatag_srv_503, tag_bool_v((x))
+
+NTA_DLL extern tag_typedef_t ntatag_srv_503_ref;
+#define NTATAG_SRV_503_REF(x) ntatag_srv_503_ref, tag_bool_vr(&(x))
+
 NTA_DLL extern tag_typedef_t ntatag_rseq;
 #define NTATAG_RSEQ(x)    ntatag_rseq, tag_uint_v((x))
 
diff -ur a/libsofia-sip-ua/nta/sofia-sip/nta_tport.h b/libsofia-sip-ua/nta/sofia-sip/nta_tport.h
--- a/libsofia-sip-ua/nta/sofia-sip/nta_tport.h	2011-03-11 16:49:18.000000000 +0200
+++ b/libsofia-sip-ua/nta/sofia-sip/nta_tport.h	2017-12-07 23:26:01.128846912 +0200
@@ -54,6 +54,11 @@
 #endif
 typedef NTA_UPDATE_MAGIC_T nta_update_magic_t;
 
+#ifndef NTA_ERROR_MAGIC_T
+#define NTA_ERROR_MAGIC_T void
+#endif
+typedef NTA_ERROR_MAGIC_T nta_error_magic_t;
+
 struct sigcomp_compartment;
 struct sigcomp_udvm;
 
@@ -77,11 +82,18 @@
 
 typedef void nta_update_tport_f(nta_update_magic_t *, nta_agent_t *);
 
+typedef void nta_error_tport_f(nta_error_magic_t *, nta_agent_t *, tport_t *);
+
 SOFIAPUBFUN
 int nta_agent_bind_tport_update(nta_agent_t *agent,
 				nta_update_magic_t *magic,
 				nta_update_tport_f *);
 
+SOFIAPUBFUN
+int nta_agent_bind_tport_error(nta_agent_t *agent,
+				nta_error_magic_t *magic,
+			    nta_error_tport_f *callback);
+
 SOFIA_END_DECLS
 
 #endif /* !defined NTA_TPORT_H */
diff -ur a/libsofia-sip-ua/nth/Makefile.am b/libsofia-sip-ua/nth/Makefile.am
--- a/libsofia-sip-ua/nth/Makefile.am	2011-03-11 16:49:18.000000000 +0200
+++ b/libsofia-sip-ua/nth/Makefile.am	2017-12-07 23:25:59.624838755 +0200
@@ -8,7 +8,7 @@
 # ----------------------------------------------------------------------
 # Header paths
 
-INCLUDES = 	-I$(srcdir)/../ipt -I../ipt \
+AM_CPPFLAGS = 	-I$(srcdir)/../ipt -I../ipt \
 		-I$(srcdir)/../iptsec -I../iptsec \
 		-I$(srcdir)/../msg -I../msg \
 		-I$(srcdir)/../bnf -I../bnf \
@@ -27,8 +27,6 @@
 
 TESTS = 		test_nth
 
-CLEANFILES =		tmp_sippasswd.*
-
 # ----------------------------------------------------------------------
 # Rules for building the targets
 
diff -ur a/libsofia-sip-ua/nth/nth_client.c b/libsofia-sip-ua/nth/nth_client.c
--- a/libsofia-sip-ua/nth/nth_client.c	2011-03-11 16:49:18.000000000 +0200
+++ b/libsofia-sip-ua/nth/nth_client.c	2017-12-07 23:25:59.636838820 +0200
@@ -243,9 +243,19 @@
 HTABLE_PROTOS_WITH(hc_htable, hct, nth_client_t, uintptr_t, size_t);
 
 #define HTABLE_HASH_CLIENT(hc) ((uintptr_t)(hc)->hc_tport)
+
+#ifdef __clang__
+#pragma clang diagnostic push
+#pragma clang diagnostic ignored "-Wunused-function"
+#endif
+
 HTABLE_BODIES_WITH(hc_htable, hct, nth_client_t, HTABLE_HASH_CLIENT,
 		   uintptr_t, size_t);
 
+#ifdef __clang__
+#pragma clang diagnostic pop
+#endif
+
 static url_string_t const *hc_request_complete(nth_client_t * hc,
 					       msg_t *msg, http_t * http,
 					       http_method_t method,
@@ -911,7 +921,7 @@
 
   if (msg_serialize(msg, http) < 0) {
     assert(hc->hc_tport);
-    SU_DEBUG_3(("nth client create: invalid message"));
+    SU_DEBUG_3(("nth client create: invalid message" VA_NONE));
     return -1;
   }
 
diff -ur a/libsofia-sip-ua/nth/nth_server.c b/libsofia-sip-ua/nth/nth_server.c
--- a/libsofia-sip-ua/nth/nth_server.c	2011-03-11 16:49:18.000000000 +0200
+++ b/libsofia-sip-ua/nth/nth_server.c	2017-12-07 23:25:59.640838842 +0200
@@ -200,9 +200,6 @@
 static server_t *server_create(url_t const *url,
 			       tag_type_t tag, tag_value_t value, ...);
 void server_destroy(server_t *srv);
-su_inline int server_timer_init(server_t *srv);
-static void server_timer(su_root_magic_t *rm, su_timer_t *timer, server_t *srv);
-su_inline uint32_t server_now(server_t const *srv);
 static void server_request(server_t *srv, tport_t *tport, msg_t *msg,
 				    void *arg, su_time_t now);
 static nth_site_t **site_get_host(nth_site_t **, char const *host, char const *port);
@@ -312,20 +309,20 @@
   is_path = url->url_path != NULL;
 
   if (is_host && is_path) {
-    SU_DEBUG_3(("nth_site_create(): virtual host and path simultanously\n"));
+    SU_DEBUG_3(("nth_site_create(): virtual host and path simultanously\n" VA_NONE));
     errno = EINVAL;
     goto error;
   }
 
   if (!parent && !is_host) {
-    SU_DEBUG_3(("nth_site_create(): host is required\n"));
+    SU_DEBUG_3(("nth_site_create(): host is required\n" VA_NONE));
     errno = EINVAL;
     goto error;
   }
 
   if (parent) {
     if (!parent->site_isdir) {
-      SU_DEBUG_3(("nth_site_create(): invalid parent resource \n"));
+      SU_DEBUG_3(("nth_site_create(): invalid parent resource \n" VA_NONE));
       errno = EINVAL;
       goto error;
     }
@@ -775,44 +772,6 @@
   su_home_unref(srv->srv_home);
 }
 
-/** Initialize server timer. */
-su_inline
-int server_timer_init(server_t *srv)
-{
-  if (0) {
-    srv->srv_timer = su_timer_create(su_root_task(srv->srv_root), SERVER_TICK);
-    return su_timer_set(srv->srv_timer, server_timer, srv);
-  }
-  return 0;
-}
-
-/**
- * Server timer routine.
- */
-static
-void server_timer(su_root_magic_t *rm, su_timer_t *timer, server_t *srv)
-{
-  uint32_t now;
-
-  su_timer_set(timer, server_timer, srv);
-
-  now = su_time_ms(su_now()); now += now == 0; srv->srv_now = now;
-
-  /* Xyzzy */
-
-  srv->srv_now = 0;
-}
-
-/** Get current timestamp in milliseconds */
-su_inline
-uint32_t server_now(server_t const *srv)
-{
-  if (srv->srv_now)
-    return srv->srv_now;
-  else
-    return su_time_ms(su_now());
-}
-
 /** Process incoming request message */
 static
 void server_request(server_t *srv,
@@ -995,7 +954,7 @@
   if (tport_tqsend(tport, response, NULL,
 		   TPTAG_CLOSE_AFTER(close),
 		   TAG_END()) == -1) {
-    SU_DEBUG_3(("server_reply(): cannot queue response\n"));
+    SU_DEBUG_3(("server_reply(): cannot queue response\n" VA_NONE));
     tport_shutdown(tport, 2);
   }
 
diff -ur a/libsofia-sip-ua/nua/check_nua.c b/libsofia-sip-ua/nua/check_nua.c
--- a/libsofia-sip-ua/nua/check_nua.c	2011-03-11 16:49:18.000000000 +0200
+++ b/libsofia-sip-ua/nua/check_nua.c	2017-12-07 23:25:59.668838994 +0200
@@ -43,7 +43,6 @@
 #include <sofia-sip/msg_addr.h>
 #include <sofia-sip/su_log.h>
 #include <sofia-sip/su_tagarg.h>
-#include <sofia-sip/su_tag_io.h>
 #include <sofia-sip/su_alloc.h>
 #include <sofia-sip/su_string.h>
 #include <sofia-sip/sresolv.h>
@@ -55,8 +54,6 @@
 #include <limits.h>
 #include <time.h>
 
-static int s2_nua_print_events;
-
 static void usage(int exitcode)
 {
   fprintf(exitcode ? stderr : stdout,
@@ -79,9 +76,6 @@
   if (getenv("CHECK_NUA_VERBOSE"))
     s2_start_stop = strtoul(getenv("CHECK_NUA_VERBOSE"), NULL, 10);
 
-  if (getenv("CHECK_NUA_EVENTS"))
-    s2_nua_print_events = 1;
-
   for (i = 1; argv[i]; i++) {
     if (su_strnmatch(argv[i], "--xml=", strlen("--xml="))) {
       xml = argv[i] + strlen("--xml=");
@@ -148,8 +142,6 @@
 
 int s2_nua_thread = 0;
 
-su_nanotime_t s2_nua_started;
-
 unsigned s2_default_registration_duration = 3600;
 
 char const s2_auth_digest_str[] =
@@ -290,27 +282,6 @@
   e->nh = nua_handle_ref(nh);
   e->data = nua_event_data(e->event);
 
-  e->sip = sip_object(e->data->e_msg);
-
-  if (s2_nua_print_events) {
-    su_nanotime_t now;
-    char timestamp[32];
-
-    su_nanotime(&now);
-
-    if (s2_nua_started == 0) s2_nua_started = now;
-
-    now -= s2_nua_started; now /= 1000000;
-
-    snprintf(timestamp, sizeof timestamp, "%03u.%03u",
-	     (unsigned)(now / 1000), (unsigned)(now % 1000));
-
-    fprintf(stderr, "%s: event %s status %u %s\n",
-	    timestamp, nua_event_name(event), status, phrase);
-
-    tl_print(stderr, "", tags);
-  }
-
   for (prev = &s2->events; *prev; prev = &(*prev)->next)
     ;
 
@@ -366,8 +337,6 @@
   /* enable/disable multithreading */
   su_root_threading(s2base->root, s2_nua_thread);
 
-  su_nanotime(&s2_nua_started);
-
   ta_start(ta, tag, value);
   s2->nua =
     nua_create(s2base->root,
diff -ur a/libsofia-sip-ua/nua/check_nua.h b/libsofia-sip-ua/nua/check_nua.h
--- a/libsofia-sip-ua/nua/check_nua.h	2011-03-11 16:49:18.000000000 +0200
+++ b/libsofia-sip-ua/nua/check_nua.h	2017-12-07 23:25:59.672839015 +0200
@@ -45,7 +45,6 @@
     struct event *next, **prev;
     nua_saved_event_t event[1];
     nua_handle_t *nh;
-    sip_t *sip;
     nua_event_data_t const *data;
     su_time_t when;
   } *events;
diff -ur a/libsofia-sip-ua/nua/check_register.c b/libsofia-sip-ua/nua/check_register.c
--- a/libsofia-sip-ua/nua/check_register.c	2011-03-11 16:49:18.000000000 +0200
+++ b/libsofia-sip-ua/nua/check_register.c	2017-12-07 23:25:59.680839059 +0200
@@ -877,9 +877,171 @@
   return tc;
 }
 
+/* ---------------------------------------------------------------------- */
+
+static struct dialog *dialog = NULL;
+
+static void registrar_setup(void)
+{
+  struct event *event;
+  tagi_t const *t;
+  sip_contact_t *m;
+
+  dialog = su_home_new(sizeof *dialog); fail_if(!dialog);
+
+  nua = s2_nua_setup("register",
+		     NUTAG_APPL_METHOD("REGISTER"),
+		     NUTAG_ALLOW("REGISTER"),
+		     NUTAG_PROXY(SIP_NONE),
+		     TAG_END());
+
+  nua_get_params(nua, TAG_ANY(), TAG_END());
+  event = s2_wait_for_event(nua_r_get_params, 200);
+  fail_unless(event != NULL);
+
+  t = tl_find(event->data->e_tags, ntatag_contact);
+  fail_unless(t != NULL);
+  m = sip_contact_dup(dialog->home, (sip_contact_t *)t->t_value);
+  fail_unless(m != NULL);
+
+  s2sip->sut.contact = m;
+}
+
+static void registrar_thread_setup(void)
+{
+  s2_nua_thread = 1;
+  registrar_setup();
+}
+
+static void registrar_threadless_setup(void)
+{
+  s2_nua_thread = 1;
+  registrar_setup();
+}
+
+static void registrar_teardown(void)
+{
+  s2_teardown_started("registrar");
+  nua_shutdown(nua);
+  fail_unless_event(nua_r_shutdown, 200);
+  s2_nua_teardown();
+}
+
+static void add_registrar_fixtures(TCase *tc, int threading)
+{
+  void (*setup)(void);
+
+  if (threading)
+    setup = registrar_thread_setup;
+  else
+    setup = registrar_threadless_setup;
+
+  tcase_add_checked_fixture(tc, setup, registrar_teardown);
+}
+
+START_TEST(registrar_1_4_0)
+{
+  struct event *event;
+  nua_handle_t *nh;
+  struct message *response;
+
+  S2_CASE("1.4.0", "Registrar", "Test receiving a REGISTER");
+
+  fail_if(s2_sip_request_to(dialog, SIP_METHOD_REGISTER, NULL,
+			    SIPTAG_FROM_STR("<sip:tst@example.com>"),
+			    SIPTAG_TO_STR("<sip:tst@example.com>"),
+			    TAG_END()));
+
+  event = s2_wait_for_event(nua_i_register, 100);
+  fail_unless(event != NULL);
+  nh = event->nh; fail_if(!nh);
+
+  nua_respond(nh, 200, "Ok",
+	      NUTAG_WITH_SAVED(event->event),
+	      TAG_END());
+
+  response = s2_sip_wait_for_response(200, SIP_METHOD_REGISTER);
+  fail_if(!response);
+  s2_sip_free_message(response);
+
+  nua_handle_destroy(nh);
+}
+END_TEST
+
+START_TEST(registrar_1_4_1)
+{
+  struct event *event;
+  nua_handle_t *nh;
+  struct message *response;
+
+  S2_CASE("1.4.1", "Registrar", "Test receiving a REGISTER via TCP");
+
+  fail_if(s2_sip_request_to(dialog, SIP_METHOD_REGISTER, s2sip->tcp.tport,
+			    SIPTAG_FROM_STR("<sip:tst@example.com>"),
+			    SIPTAG_TO_STR("<sip:tst@example.com>"),
+			    TAG_END()));
+
+  event = s2_wait_for_event(nua_i_register, 100);
+  fail_if(!event);
+  nh = event->nh; fail_if(!nh);
+
+  nua_respond(nh, 200, "Ok",
+	      NUTAG_WITH_SAVED(event->event),
+	      TAG_END());
+
+  response = s2_sip_wait_for_response(200, SIP_METHOD_REGISTER);
+  fail_if(!response);
+  tport_shutdown(response->tport, 2);
+  s2_sip_free_message(response);
+
+  event = s2_wait_for_event(nua_i_media_error, 0);
+  fail_if(!event);
+  nua_handle_destroy(nh);
+
+  fail_if(s2_sip_request_to(dialog, SIP_METHOD_REGISTER, s2sip->tcp.tport,
+			    SIPTAG_FROM_STR("<sip:tst@example.com>"),
+			    SIPTAG_TO_STR("<sip:tst@example.com>"),
+			    TAG_END()));
+
+  event = s2_wait_for_event(nua_i_register, 100);
+  fail_if(!event);
+  nh = event->nh; fail_if(!nh);
+
+  nua_respond(nh, 200, "Ok",
+	      NUTAG_WITH_SAVED(event->event),
+	      TAG_END());
+
+  response = s2_sip_wait_for_response(200, SIP_METHOD_REGISTER);
+  fail_if(!response);
+  nua_handle_destroy(nh);
+
+  s2_step();
+  s2_step();
+  s2_step();
+
+  tport_shutdown(response->tport, 2);
+  s2_sip_free_message(response);
+}
+END_TEST
+
+TCase *registrar_tcase(int threading)
+{
+  TCase *tc = tcase_create("1.4 - REGISTER server");
+
+  add_registrar_fixtures(tc, threading);
+
+  tcase_add_test(tc, registrar_1_4_0);
+  tcase_add_test(tc, registrar_1_4_1);
+
+  tcase_set_timeout(tc, 10);
+
+  return tc;
+}
+
 void check_register_cases(Suite *suite, int threading)
 {
   suite_add_tcase(suite, register_tcase(threading));
   suite_add_tcase(suite, pingpong_tcase(threading));
+  suite_add_tcase(suite, registrar_tcase(threading));
 }
 
diff -ur a/libsofia-sip-ua/nua/check_session.c b/libsofia-sip-ua/nua/check_session.c
--- a/libsofia-sip-ua/nua/check_session.c	2011-03-11 16:49:18.000000000 +0200
+++ b/libsofia-sip-ua/nua/check_session.c	2017-12-07 23:25:59.684839080 +0200
@@ -1570,57 +1570,6 @@
 }
 END_TEST
 
-START_TEST(call_2_4_6)
-{
-  nua_handle_t *nh;
-  struct message *invite, *prack;
-  int with_sdp;
-
-  S2_CASE("2.4.6", "Call with 100rel and delayed offer",
-	  "NUA sends INVITE without SDP offer, "
-	  "receives 183 with SDP offer, sends PRACK with SDP answer, receives 200 for it, "
-	  "receives 180, sends PRACK, receives 200 for it, "
-          "receives 200, send ACK.");
-
-  nh = nua_handle(nua, NULL, SIPTAG_TO(s2sip->aor), TAG_END());
-
-  invite = invite_sent_by_nua(nh, SOATAG_DELAYED_OFFER_ENABLE(1),
-                                  SOATAG_USER_SDP_STR("m=audio 5008 RTP/AVP 8 0" CRLF
-                                                      "m=video 5010 RTP/AVP 34" CRLF),
-                                  TAG_END());
-
-  soa_generate_offer(soa, 1, NULL);
-
-  prack = respond_with_100rel(invite, dialog, with_sdp = 1,
-			      SIP_183_SESSION_PROGRESS,
-			      TAG_END());
-  process_answer(prack);
-  s2_sip_respond_to(prack, dialog, SIP_200_OK, TAG_END());
-  s2_sip_free_message(prack), prack = NULL;
-  fail_unless(s2_check_callstate(nua_callstate_proceeding));
-  fail_unless_event(nua_r_prack, 200);
-
-  prack = respond_with_100rel(invite, dialog, with_sdp = 0,
-			      SIP_180_RINGING,
-			      TAG_END());
-  s2_sip_respond_to(prack, dialog, SIP_200_OK, TAG_END());
-  s2_sip_free_message(prack), prack = NULL;
-  fail_unless(s2_check_callstate(nua_callstate_proceeding));
-  fail_unless_event(nua_r_prack, 200);
-
-  s2_sip_respond_to(invite, dialog, SIP_200_OK, TAG_END());
-  s2_sip_free_message(invite);
-  fail_unless_event(nua_r_invite, 200);
-
-  fail_unless(s2_check_callstate(nua_callstate_ready));
-  fail_unless(s2_sip_check_request(SIP_METHOD_ACK));
-
-  bye_to_nua(nh, TAG_END());
-
-  nua_handle_destroy(nh);
-}
-END_TEST
-
 TCase *invite_100rel_tcase(int threading)
 {
   TCase *tc = tcase_create("2.4 - INVITE with 100rel");
@@ -1631,7 +1580,6 @@
     tcase_add_test(tc, call_2_4_3);
     tcase_add_test(tc, call_2_4_4);
     tcase_add_test(tc, call_2_4_5);
-    tcase_add_test(tc, call_2_4_6);
   }
   return tc;
 }
diff -ur a/libsofia-sip-ua/nua/check_simple.c b/libsofia-sip-ua/nua/check_simple.c
--- a/libsofia-sip-ua/nua/check_simple.c	2011-03-11 16:49:18.000000000 +0200
+++ b/libsofia-sip-ua/nua/check_simple.c	2017-12-07 23:25:59.684839080 +0200
@@ -244,7 +244,7 @@
 
   fail_if(s2_sip_request_to(dialog, SIP_METHOD_NOTIFY, NULL,
 			SIPTAG_EVENT(subscribe->sip->sip_event),
-			SIPTAG_SUBSCRIPTION_STATE_STR("terminated;reason=timeout"),
+			SIPTAG_SUBSCRIPTION_STATE_STR("terminated;reason=tiemout"),
 			SIPTAG_CONTENT_TYPE_STR(event_mime_type),
 			SIPTAG_PAYLOAD_STR(event_state),
 			TAG_END()));
@@ -397,51 +397,6 @@
 }
 END_TEST
 
-START_TEST(subscribe_6_1_5)
-{
-  nua_handle_t *nh;
-  struct event *notify;
-  sip_via_t *vorig = s2_sip_tport_via(s2sip->udp.tport);
-  sip_via_t via[2];
-  char *v0_params[8] = {}, *v1_params[8] = {};
-  char branch0[32], branch1[32];
-
-  S2_CASE("6.1.5", "Via handling in response to NOTIFY",
-	  "NUA sends SUBSCRIBE, waits for NOTIFY, sends un-SUBSCRIBE");
-
-  nh = nua_handle(nua, NULL, SIPTAG_TO(s2sip->aor), TAG_END());
-  nua_subscribe(nh, SIPTAG_EVENT_STR(event_type), TAG_END());
-
-  s2_sip_msg_flags = MSG_FLG_COMMA_LISTS|MSG_FLG_COMPACT;
-
-  fail_if(vorig == NULL);
-
-  via[0] = *vorig;
-  via[0].v_host = "example.org";
-  via[0].v_params = (void *)v0_params;
-  snprintf(v0_params[0] = branch0, sizeof branch0,
-	   "branch=z9hG4bK%lx", ++s2sip->tid);
-
-  fail_if(vorig == NULL);
-
-  via[1] = *vorig;
-  via[1].v_params = (void *)v1_params;
-  snprintf(v1_params[0] = branch1, sizeof branch1,
-	   "branch=z9hG4bK%lx", ++s2sip->tid);
-
-  notify = subscription_by_nua(nh, nua_substate_embryonic,
-			       SIPTAG_VIA(via + 1),
-			       SIPTAG_VIA(via + 0),
-			       TAG_END());
-
-  s2_sip_msg_flags = 0;
-
-  s2_free_event(notify);
-  unsubscribe_by_nua(nh, TAG_END());
-  nua_handle_destroy(nh);
-}
-END_TEST
-
 TCase *subscribe_tcase(int threading)
 {
   TCase *tc = tcase_create("6.1 - Basic SUBSCRIBE_");
@@ -455,7 +410,6 @@
     tcase_add_test(tc, subscribe_6_1_2);
     tcase_add_test(tc, subscribe_6_1_3);
     tcase_add_test(tc, subscribe_6_1_4);
-    tcase_add_test(tc, subscribe_6_1_5);
   }
   return tc;
 }
@@ -877,135 +831,6 @@
 
 /* ====================================================================== */
 
-START_TEST(message_6_4_1)
-{
-  nua_handle_t *nh;
-  struct message *message;
-  struct event *response;
-
-  S2_CASE("6.4.1", "SIMPLE MESSAGE",
-	  "Send MESSAGE");
-
-  nh = nua_handle(nua, NULL, SIPTAG_TO(s2sip->aor), TAG_END());
-  nua_message(nh,
-	      SIPTAG_CONTENT_TYPE_STR("text/plain"),
-	      SIPTAG_PAYLOAD_STR("hello"),
-	      TAG_END());
-  message = s2_sip_wait_for_request(SIP_METHOD_MESSAGE);
-  s2_sip_respond_to(message, NULL, SIP_202_ACCEPTED, TAG_END());
-  s2_sip_free_message(message);
-  response = s2_wait_for_event(nua_r_message, 202);
-  s2_free_event(response);
-
-  nua_handle_destroy(nh);
-}
-END_TEST
-
-START_TEST(message_6_4_2)
-{
-  nua_handle_t *nh;
-  struct message *message;
-  struct event *response;
-
-  S2_CASE("6.4.2", "MESSAGE with 302/305",
-	  "Send MESSAGE");
-
-  nh = nua_handle(nua, NULL, SIPTAG_TO(s2sip->aor), TAG_END());
-
-  nua_message(nh,
-	      SIPTAG_CONTENT_TYPE_STR("text/plain"),
-	      SIPTAG_PAYLOAD_STR("hello"),
-	      TAG_END());
-  message = s2_sip_wait_for_request(SIP_METHOD_MESSAGE);
-  s2_sip_respond_to(message, NULL, SIP_302_MOVED_TEMPORARILY,
-		    SIPTAG_CONTACT_STR("<sip:302ed@example.com>"),
-		    TAG_END());
-  s2_sip_free_message(message);
-
-  response = s2_wait_for_event(nua_r_message, 100);
-  s2_free_event(response);
-
-  message = s2_sip_wait_for_request(SIP_METHOD_MESSAGE);
-  fail_unless(message->sip->sip_request->rq_url->url_user != NULL);
-  fail_if(strcmp(message->sip->sip_request->rq_url->url_user, "302ed"));
-  s2_sip_respond_to(message, NULL, SIP_305_USE_PROXY,
-		    SIPTAG_CONTACT_STR("<sip:routed@example.com;lr>"),
-		    TAG_END());
-  s2_sip_free_message(message);
-
-  response = s2_wait_for_event(nua_r_message, 100);
-  s2_free_event(response);
-
-  message = s2_sip_wait_for_request(SIP_METHOD_MESSAGE);
-  fail_unless(message->sip->sip_route != NULL);
-  fail_unless(message->sip->sip_route->r_url->url_user != NULL);
-  fail_if(strcmp(message->sip->sip_route->r_url->url_user, "routed"));
-  s2_sip_respond_to(message, NULL, SIP_200_OK, TAG_END());
-  s2_sip_free_message(message);
-
-  response = s2_wait_for_event(nua_r_message, 200);
-  s2_free_event(response);
-
-  /* ---------------------------------------------------------------------- */
-
-  nua_message(nh,
-	      NUTAG_AUTO302(0),
-	      SIPTAG_CONTENT_TYPE_STR("text/plain"),
-	      SIPTAG_PAYLOAD_STR("hello 2"),
-	      TAG_END());
-
-  message = s2_sip_wait_for_request(SIP_METHOD_MESSAGE);
-  s2_sip_respond_to(message, NULL, SIP_302_MOVED_TEMPORARILY,
-		    SIPTAG_CONTACT_STR("<sip:not302ed@example.com>"),
-		    TAG_END());
-  s2_sip_free_message(message);
-
-  response = s2_wait_for_event(nua_r_message, 302);
-
-  fail_unless(response->sip && response->sip->sip_contact);
-  nua_message(nh,
-	      NUTAG_URL(response->sip->sip_contact->m_url),
-	      NUTAG_AUTO305(0),
-	      SIPTAG_CONTENT_TYPE_STR("text/plain"),
-	      SIPTAG_PAYLOAD_STR("hello 2"),
-	      TAG_END());
-
-  s2_free_event(response);
-
-  message = s2_sip_wait_for_request(SIP_METHOD_MESSAGE);
-  fail_unless(message->sip->sip_request->rq_url->url_user != NULL);
-  fail_if(strcmp(message->sip->sip_request->rq_url->url_user, "not302ed"));
-  s2_sip_respond_to(message, NULL, SIP_305_USE_PROXY,
-		    SIPTAG_CONTACT_STR("<sip:not-routed@example.com>"),
-		    TAG_END());
-  s2_sip_free_message(message);
-
-  response = s2_wait_for_event(nua_r_message, 305);
-  s2_free_event(response);
-
-  nua_handle_destroy(nh);
-}
-END_TEST
-
-static TCase *message_tcase(int threading)
-{
-  TCase *tc = tcase_create(threading ?
-			   "6.4 - MESSAGE (MT)" :
-			   "6.4 - MESSAGE");
-  void (*simple_setup)(void);
-
-  simple_setup = threading ? simple_thread_setup : simple_threadless_setup;
-  tcase_add_checked_fixture(tc, simple_setup, simple_teardown);
-
-  tcase_add_test(tc, message_6_4_1);
-  tcase_add_test(tc, message_6_4_2);
-
-  return tc;
-}
-
-
-/* ====================================================================== */
-
 /* Test case template */
 
 START_TEST(empty)
@@ -1041,7 +866,6 @@
   suite_add_tcase(suite, subscribe_tcase(threading));
   suite_add_tcase(suite, fetch_tcase(threading));
   suite_add_tcase(suite, notifier_tcase(threading));
-  suite_add_tcase(suite, message_tcase(threading));
 
   if (0)			/* Template */
     suite_add_tcase(suite, empty_tcase(threading));
diff -ur a/libsofia-sip-ua/nua/Makefile.am b/libsofia-sip-ua/nua/Makefile.am
--- a/libsofia-sip-ua/nua/Makefile.am	2011-03-11 16:49:18.000000000 +0200
+++ b/libsofia-sip-ua/nua/Makefile.am	2017-12-07 23:25:59.692839124 +0200
@@ -45,7 +45,16 @@
 
 COVERAGE_INPUT = 	$(libnua_la_SOURCES) $(include_sofia_HEADERS)
 
-LDADD = 		libnua.la  \
+# ----------------------------------------------------------------------
+
+check_nua_SOURCES = 	check_nua.c check_nua.h \
+			check_session.c check_register.c \
+			check_etsi.c check_simple.c
+
+check_nua_LDADD = 	$(nua_libs) ${top_builddir}/s2check/libs2.a \
+			@CHECK_LIBS@
+
+nua_libs = 		libnua.la  \
 			../iptsec/libiptsec.la \
 			../ipt/libipt.la \
 			../nea/libnea.la \
@@ -63,15 +72,6 @@
 			../su/libsu.la
 
 # ----------------------------------------------------------------------
-
-check_nua_SOURCES = 	check_nua.c check_nua.h \
-			check_session.c check_register.c \
-			check_etsi.c check_simple.c
-
-check_nua_LDADD = 	$(LDADD) ${top_builddir}/s2check/libs2.a \
-			@CHECK_LIBS@
-
-# ----------------------------------------------------------------------
 # Install and distribution rules
 
 EXTRA_DIST =		nua.docs $(BUILT_SOURCES)
@@ -79,8 +79,9 @@
 # ----------------------------------------------------------------------
 # Sofia specific rules
 
+LDADD = 
 include $(top_srcdir)/rules/sofia.am
 
-INCLUDES = ${INTERNAL_INCLUDES} -I$(top_srcdir)/s2check
+AM_CPPFLAGS = ${INTERNAL_INCLUDES} -I$(top_srcdir)/s2check
 
 TAG_DLL_FLAGS =		LIST=nua_tag_list
diff -ur a/libsofia-sip-ua/nua/nua.c b/libsofia-sip-ua/nua/nua.c
--- a/libsofia-sip-ua/nua/nua.c	2011-03-11 16:49:18.000000000 +0200
+++ b/libsofia-sip-ua/nua/nua.c	2017-12-07 23:25:59.704839188 +0200
@@ -89,7 +89,7 @@
  * @param root            Pointer to a root object
  * @param callback        Pointer to event callback function
  * @param magic           Pointer to callback context
- * @param tag,Â value,Â ... List of tagged parameters
+ * @param tag,Â value, ... List of tagged parameters
  *
  * @retval !=NULL a pointer to a @nua stack object
  * @retval NULL upon an error
diff -ur a/libsofia-sip-ua/nua/nua_client.c b/libsofia-sip-ua/nua/nua_client.c
--- a/libsofia-sip-ua/nua/nua_client.c	2011-03-11 16:49:18.000000000 +0200
+++ b/libsofia-sip-ua/nua/nua_client.c	2017-12-07 23:25:59.716839254 +0200
@@ -63,7 +63,9 @@
 
 #include <sofia-sip/su_wait.h>
 
+#if 0
 su_inline int can_redirect(sip_contact_t const *m, sip_method_t method);
+#endif
 
 /**@internal
  *
@@ -174,7 +176,7 @@
 
       if (tags) {
 	nua_move_signal(cr->cr_signal, nh->nh_nua->nua_signal);
-	if (cr->cr_signal) {
+	if (cr->cr_signal[0]) {
 	  /* Steal reference from signal */
 	  cr->cr_owner = e->e_nh, e->e_nh = NULL;
 	  cr->cr_tags = tags;
@@ -837,6 +839,9 @@
   if (!sip->sip_user_agent && NH_PGET(nh, user_agent))
     sip_add_make(msg, sip, sip_user_agent_class, NH_PGET(nh, user_agent));
 
+  if (!sip->sip_via && NH_PGET(nh, via))
+    sip_add_make(msg, sip, sip_via_class, NH_PGET(nh, via));
+
   /** Any node implementing one or more event packages SHOULD include an
    * appropriate @AllowEvents header indicating all supported events in
    * all methods which initiate dialogs and their responses (such as
@@ -875,6 +880,11 @@
     if (ds->ds_ltarget && !cr->cr_has_contact)
       sip_add_dup(msg, sip, (sip_header_t *)ds->ds_ltarget);
 
+	/*
+	  FS-4102 
+	  It was decided to comment out this code because it does not appear to make sense
+	  Dec 22, 2016
+
     if (nua_registration_add_contact_to_request(nh, msg, sip,
 						cr->cr_contactize &&
 						!cr->cr_has_contact &&
@@ -883,6 +893,8 @@
       msg_destroy(msg);
       return -1;
     }
+	*/
+
   }
 
   cr->cr_wait_for_cred = 0;
@@ -1059,11 +1071,15 @@
     sip_method_t method = cr->cr_method;
     int terminated, graceful = 1;
 
-    if (status < 700)
-      terminated = sip_response_terminates_dialog(status, method, &graceful);
-    else
-      /* XXX - terminate usage by all internal error responses */
-      terminated = 0, graceful = 1;
+    if (status < 700) {
+		terminated = sip_response_terminates_dialog(status, method, &graceful);
+		if (terminated && !cr->cr_initial) {
+			terminated = 0, graceful = 1;
+		}
+	} else {
+		/* XXX - terminate usage by all internal error responses */
+		terminated = 0, graceful = 1;
+	}
 
     if (terminated < 0)
       cr->cr_terminated = terminated;
@@ -1124,15 +1140,10 @@
 {
   nua_handle_t *nh = cr->cr_owner;
   nta_outgoing_t *orq;
-
+#if 0
   if (status == 302 || status == 305) {
     sip_route_t r[1];
 
-    if (status == 302 && !NH_PGET(nh, auto302))
-      return 0;
-    if (status == 305 && !NH_PGET(nh, auto305))
-      return 0;
-
     if (!can_redirect(sip->sip_contact, cr->cr_method))
       return 0;
 
@@ -1155,7 +1166,7 @@
       break;
     }
   }
-
+#endif
 
   if (status == 423) {
     unsigned my_expires = 0;
@@ -1176,6 +1187,14 @@
     }
   }
 
+  if (status == 403) {
+	  if (nh->nh_auth) {
+		  /* Bad username/password */
+		  SU_DEBUG_7(("nua(%p): bad credentials, clearing them\n", (void *)nh));
+		  auc_clear_credentials(&nh->nh_auth, NULL, NULL);
+	  }
+  }
+
   if ((status == 401 && sip->sip_www_authenticate) ||
       (status == 407 && sip->sip_proxy_authenticate)) {
     int server = 0, proxy = 0;
@@ -1196,12 +1215,12 @@
       cr->cr_challenged = 1;
 
       if (invalid) {
-	/* Bad username/password */
-	SU_DEBUG_7(("nua(%p): bad credentials, clearing them\n", (void *)nh));
-	auc_clear_credentials(&nh->nh_auth, NULL, NULL);
-      }
-      else if (auc_has_authorization(&nh->nh_auth))
-	return nua_client_restart(cr, 100, "Request Authorized by Cache");
+		  /* Bad username/password */
+		  SU_DEBUG_7(("nua(%p): bad credentials, clearing them\n", (void *)nh));
+		  auc_clear_credentials(&nh->nh_auth, NULL, NULL);
+      } else if (auc_has_authorization(&nh->nh_auth)) {
+		  return nua_client_restart(cr, 100, "Request Authorized by Cache");
+	  }
 
       orq = cr->cr_orq, cr->cr_orq = NULL;
 
@@ -1214,10 +1233,13 @@
       return 1;
     }
   }
-
-  if (500 <= status && status < 600 &&
+  /* GriGiu : RFC-3261 status supported Retry-After */
+  if ( (status == 404 || status == 413 || status == 480 || status == 486 ||
+	   status == 500 || status == 503 ||
+	   status == 600 || status == 603) &&
       sip->sip_retry_after &&
-      sip->sip_retry_after->af_delta < 32) {
+	  NH_PGET(nh, retry_after_enable) &&
+      sip->sip_retry_after->af_delta < 3200) {
     su_timer_t *timer;
     char phrase[18];		/* Retry After XXXX\0 */
 
@@ -1239,12 +1261,14 @@
     nua_client_report(cr, 100, phrase, NULL, orq, NULL);
     nta_outgoing_destroy(orq);
     cr->cr_status = 0, cr->cr_phrase = NULL;
+
     return 1;
   }
 
   return 0;  /* This was a final response that cannot be restarted. */
 }
 
+#if 0
 su_inline
 int can_redirect(sip_contact_t const *m, sip_method_t method)
 {
@@ -1260,6 +1284,7 @@
   }
   return 0;
 }
+#endif
 
 /** @internal Add authorization data */
 static int nh_authorize(nua_handle_t *nh, tag_type_t tag, tag_value_t value, ...)
@@ -1575,10 +1600,6 @@
   for (; cr; cr = cr->cr_next) {
     if (cr->cr_method == sip_method_cancel)
       continue;
-
-    if (invite
-	? cr->cr_method == sip_method_invite
-	: cr->cr_method != sip_method_invite)
       break;
   }
 
diff -ur a/libsofia-sip-ua/nua/nua_common.c b/libsofia-sip-ua/nua/nua_common.c
--- a/libsofia-sip-ua/nua/nua_common.c	2011-03-11 16:49:18.000000000 +0200
+++ b/libsofia-sip-ua/nua/nua_common.c	2017-12-07 23:25:59.724839297 +0200
@@ -109,7 +109,8 @@
 
   assert(nua->nua_home);
 
-  if ((nh = su_home_clone(nua->nua_home, sizeof(*nh)))) {
+  //if ((nh = su_home_clone(nua->nua_home, sizeof(*nh)))) {
+  if ((nh = su_home_new(sizeof(*nh)))) {
     nh->nh_valid = nua_valid_handle_cookie;
     nh->nh_nua = nua;
     nh->nh_magic = hmagic;
@@ -171,10 +172,16 @@
 		   char const *file, unsigned line,
 		   char const *function)
 {
-  if (nh)
-    SU_DEBUG_0(("%p - nua_handle_ref() => "MOD_ZU" by %s:%u: %s()\n",
-		nh, su_home_refcount((su_home_t *)nh) + 1, file, line, by));
-  return (nua_handle_t *)su_home_ref((su_home_t *)nh);
+
+#if (HAVE_MEMLEAK_LOG == 1) 
+	if (nh)
+		SU_DEBUG_0(("%p - nua_handle_ref() => "MOD_ZU" by %s:%u: %s()\n",
+					nh, su_home_refcount((su_home_t *)nh) + 1, file, line, function));
+	return (nua_handle_t *)su_home_ref((su_home_t *)nh);
+#else
+
+	return (nua_handle_t *)_su_home_ref_by((su_home_t *)nh, file, line, function);
+#endif
 }
 
 int
@@ -182,26 +189,23 @@
 		    char const *file, unsigned line,
 		    char const *function)
 {
-  if (nh) {
-    size_t refcount = su_home_refcount((su_home_t *)nh) - 1;
-    int freed =  su_home_unref((su_home_t *)nh);
-    if (freed) refcount = 0;
-    SU_DEBUG_0(("%p - nua_handle_unref() => "MOD_ZU" by %s:%u: %s()\n",
-		nh, refcount, file, line, by));
-    return freed;
-  }
 
-  return 0;
-}
+#if (HAVE_MEMLEAK_LOG == 1)
 
-nua_handle_t *nua_handle_ref(nua_handle_t *nh)
-{
-  return _nua_handle_ref_by(nh, "<app>", 0, "<app>")
-}
+	if (nh) {
+		size_t refcount = su_home_refcount((su_home_t *)nh) - 1;
+		int freed =  su_home_unref((su_home_t *)nh);
+
+		if (freed) refcount = 0;
+		SU_DEBUG_0(("%p - nua_handle_unref() => "MOD_ZU" by %s:%u: %s()\n",
+					nh, refcount, file, line, function));
+		return freed;
+	}
 
-int nua_handle_unref(nua_handle_t *nh)
-{
-  return _nua_handle_unref_by(nh, "<app>", 0, "<app>")
+	return 0;
+#else
+	return _su_home_unref_by((su_home_t *)nh, file, line, function);
+#endif
 }
 
 #else
diff -ur a/libsofia-sip-ua/nua/nua_dialog.c b/libsofia-sip-ua/nua/nua_dialog.c
--- a/libsofia-sip-ua/nua/nua_dialog.c	2011-03-11 16:49:18.000000000 +0200
+++ b/libsofia-sip-ua/nua/nua_dialog.c	2017-12-07 23:25:59.728839319 +0200
@@ -53,7 +53,12 @@
 #include <sofia-sip/su_debug.h>
 
 #ifndef NONE
+
+#ifndef _MSC_VER
 #define NONE ((void *)-1)
+#else
+#define NONE ((void *)(INT_PTR)-1)
+#endif
 #endif
 
 /* ======================================================================== */
@@ -149,6 +154,7 @@
     sip = NULL;			/* Redirected */
 
   if (sip == NULL) {
+    nr->nr_via = NULL, su_free(own, old->nr_via);
     nr->nr_allow = NULL, su_free(own, old->nr_allow);
     nr->nr_accept = NULL, su_free(own, old->nr_accept);
     nr->nr_require = NULL, su_free(own, old->nr_require);
@@ -177,6 +183,11 @@
     su_free(own, old->nr_supported);
   }
 
+  if (sip->sip_via) {
+    nr->nr_via = sip_via_dup(own, sip->sip_via);
+    su_free(own, old->nr_via);
+  }
+
   if (sip->sip_user_agent) {
     nr->nr_user_agent = sip_user_agent_dup(own, sip->sip_user_agent);
     su_free(own, old->nr_user_agent);
@@ -368,11 +379,14 @@
 			   nua_client_request_t *cr0,
 			   nua_server_request_t *sr0)
 {
+	int unref = 0;
+	nua_dialog_usage_t *du = NULL;
+
   if (*at) {
-    nua_dialog_usage_t *du = *at;
     sip_event_t const *o = NULL;
     nua_client_request_t *cr, *cr_next;
     nua_server_request_t *sr, *sr_next;
+    du = *at;
 
     *at = du->du_next;
 
@@ -404,8 +418,7 @@
       }
     }
 
-    su_home_unref(own);
-    su_free(own, du);
+	unref = 1;
   }
 
   /* Zap dialog if there are no more usages */
@@ -414,11 +427,20 @@
   else if (ds->ds_usage == NULL) {
     nua_dialog_remove(own, ds, NULL);
     ds->ds_has_events = 0;
+	if (unref) {
+		su_home_unref(own);
+		su_free(own, du);
+	}
     return;
   }
   else {
     nua_dialog_log_usage(own, ds);
   }
+
+  if (unref) {
+    su_home_unref(own);
+    su_free(own, du);
+  }
 }
 
 static
diff -ur a/libsofia-sip-ua/nua/nua_dialog.h b/libsofia-sip-ua/nua/nua_dialog.h
--- a/libsofia-sip-ua/nua/nua_dialog.h	2011-03-11 16:49:18.000000000 +0200
+++ b/libsofia-sip-ua/nua/nua_dialog.h	2017-12-07 23:25:59.732839340 +0200
@@ -83,6 +83,7 @@
 					 */
 
   struct nua_dialog_peer_info {
+    sip_via_t        *nr_via;
     sip_allow_t      *nr_allow;
     sip_accept_t     *nr_accept;
     sip_require_t    *nr_require;
diff -ur a/libsofia-sip-ua/nua/nua.docs b/libsofia-sip-ua/nua/nua.docs
--- a/libsofia-sip-ua/nua/nua.docs	2011-03-11 16:49:18.000000000 +0200
+++ b/libsofia-sip-ua/nua/nua.docs	2017-12-07 23:25:59.712839232 +0200
@@ -1045,16 +1045,16 @@
      :                           |        |	     |		|
      :                           |      (10) 2XX   (11) 3XX 4XX |
      :      +-------------+      |        |   /BYE   |	5XX 6XX |
-     :      |             |      V        |          |   /-     |
-     + - - >| TERMINATING |<--------------+          |	        |
-            |             |                          |          |
-            +-------------+			     |	        |
-                  |        			     | 		|
-                (12) [23456]XX to BYE/-		     | 		|
-                  |             		     | 		|
-                  V             		     | 		|
-            +------------+             		     | 		|
-            | TERMINATED |<--------------------------+----------+
+     :      |             |      V        V          |   /-     |
+     + - - >| TERMINATING |<-------------------------+	        |
+            |             |                                     |
+            +-------------+			      	        |
+                  |        			      		|
+                (12) [23456]XX to BYE/-		      		|
+                  |             		      		|
+                  V             		      		|
+            +------------+             		      		|
+            | TERMINATED |<-------------------------------------+
             +------------+
 @endcode
 
@@ -1168,7 +1168,7 @@
     <td>proceeding</td>
 </tr>
 <tr><td>C8a</td>
-    <td>calling</td>
+    <td>proceeding</td>
     <td>nua_bye()</td>
     <td>CANCEL</td>
     <td rowspan=2>terminating*</td>
@@ -1220,12 +1220,12 @@
 <tr><td>C11</td>
     <td>terminating*</td>
     <td>3XX 4XX<br>5XX 6XX<br>to INVITE</td>
-    <td>-</td>
-    <td>terminated</td>
+    <td>BYE</td>
+    <td>terminating</td>
     <td>-</td>
     <td>
    The @b INVITE transaction is completed without a call being created. The
-   call state transitions to terminated state.
+   call state transitions to normal terminating state.
 </td></tr>
 
 <tr><td>C12</td>
diff -ur a/libsofia-sip-ua/nua/nua_event_server.c b/libsofia-sip-ua/nua/nua_event_server.c
--- a/libsofia-sip-ua/nua/nua_event_server.c	2011-03-11 16:49:18.000000000 +0200
+++ b/libsofia-sip-ua/nua/nua_event_server.c	2017-12-07 23:25:59.736839362 +0200
@@ -199,7 +199,7 @@
   int substate = sn->sn_state;
   int status; char const *phrase;
 
-  SET_STATUS1(SIP_200_OK);
+  SET_STATUS(200, sip_200_OK);
 
   /* OK. In nhp (nua_handle_preferences_t) structure we have the
      current default action (or state) for incoming
@@ -218,10 +218,10 @@
       substate = nua_substate_pending;
 
     if (substate == nua_substate_terminated) {
-      what = "rejected"; SET_STATUS1(SIP_403_FORBIDDEN);
+      what = "rejected"; SET_STATUS(403, sip_403_Forbidden);
     }
     else if (substate == nua_substate_pending) {
-      what = "pending"; SET_STATUS1(SIP_202_ACCEPTED);
+      what = "pending"; SET_STATUS(202, sip_202_Accepted);
     }
     else {
       what = "active";
diff -ur a/libsofia-sip-ua/nua/nua_notifier.c b/libsofia-sip-ua/nua/nua_notifier.c
--- a/libsofia-sip-ua/nua/nua_notifier.c	2011-03-11 16:49:18.000000000 +0200
+++ b/libsofia-sip-ua/nua/nua_notifier.c	2017-12-07 23:25:59.748839427 +0200
@@ -257,10 +257,10 @@
   }
   else {
     /* Refresh existing subscription */
-    if (su_strmatch(event, "refer"))
+	  if (su_strmatch(event, "refer")){
       expires = NH_PGET(nh, refer_expires);
 
-    SR_STATUS1(sr, SIP_200_OK);
+	  SR_STATUS1(sr, SIP_200_OK);}
   }
 
   nu = nua_dialog_usage_private(du);
@@ -428,12 +428,16 @@
  * @sa @RFC3265, #nua_i_subscribe, #nua_i_refer, NUTAG_ALLOW_EVENTS()
  */
 
+#if 0
 static int nua_notify_client_init(nua_client_request_t *cr,
 				  msg_t *, sip_t *,
 				  tagi_t const *tags);
+
+
 static int nua_notify_client_init_etag(nua_client_request_t *cr,
 				       msg_t *msg, sip_t *sip,
 				       tagi_t const *tags);
+
 static int nua_notify_client_request(nua_client_request_t *cr,
 				     msg_t *, sip_t *,
 				     tagi_t const *tags);
@@ -442,7 +446,8 @@
 				    sip_t const *sip,
 				    nta_outgoing_t *orq,
 				    tagi_t const *tags);
-
+#endif
+#if 0
 static nua_client_methods_t const nua_notify_client_methods = {
   SIP_METHOD_NOTIFY,		/* crm_method, crm_method_name */
   0,				/* crm_extra */
@@ -460,6 +465,25 @@
   nua_notify_client_report,	/* crm_report */
   NULL,				/* crm_complete */
 };
+#endif
+
+nua_client_methods_t const nua_notify_client_methods = {
+  SIP_METHOD_NOTIFY,		/* crm_method, crm_method_name */
+  0,				/* crm_extra */
+  {				/* crm_flags */
+    /* create_dialog */ 1,
+    /* in_dialog */ 1,
+    /* target refresh */ 1
+  },
+  NULL,				/* crm_template */
+  NULL,		/* crm_init */
+  NULL,	/* crm_send */
+  NULL,				/* crm_check_restart */
+  NULL,				/* crm_recv */
+  NULL,				/* crm_preliminary */
+  NULL,				/* crm_report */
+  NULL,				/* crm_complete */
+};
 
 /**@internal Send NOTIFY. */
 int nua_stack_notify(nua_t *nua,
@@ -469,7 +493,7 @@
 {
   return nua_client_create(nh, e, &nua_notify_client_methods, tags);
 }
-
+#if 0
 static int nua_notify_client_init(nua_client_request_t *cr,
 				  msg_t *msg, sip_t *sip,
 				  tagi_t const *tags)
@@ -704,7 +728,7 @@
       if (sr->sr_usage == du) {
 	/* If subscribe has not been responded, don't terminate usage by NOTIFY */
 	sr->sr_terminating = 1;
-	nua_client_set_terminating(cr, 0);
+	// nua_client_set_terminating(cr, 0);
 	break;
       }
     }
@@ -715,7 +739,7 @@
 
   return nua_base_client_request(cr, msg, sip, tags);
 }
-
+#endif
 /** @NUA_EVENT nua_r_notify
  *
  * Response to an outgoing @b NOTIFY request.
@@ -747,7 +771,7 @@
  *
  * @END_NUA_EVENT
  */
-
+#if 0
 static int nua_notify_client_report(nua_client_request_t *cr,
 				    int status, char const *phrase,
 				    sip_t const *sip,
@@ -782,7 +806,7 @@
 
   return 0;
 }
-
+#endif
 
 static void nua_notify_usage_refresh(nua_handle_t *nh,
 				     nua_dialog_state_t *ds,
@@ -827,10 +851,10 @@
 				     nua_dialog_usage_t *du)
 {
   struct notifier_usage *nu = nua_dialog_usage_private(du);
-  nua_client_request_t *cr = du->du_cr;
+  //nua_client_request_t *cr = du->du_cr;
 
   nu->nu_substate = nua_substate_terminated;
-
+#if 0
   if (cr) {
     SU_DEBUG_5(("%s(%p, %p, %p): using existing cr=%p\n",
 		"nua_notify_usage_shutdown",
@@ -852,7 +876,7 @@
 			   TAG_END()) >= 0)
       return 0;
   }
-
+#endif
   nua_dialog_usage_remove(nh, ds, du, NULL, NULL);
   return 200;
 }
@@ -976,13 +1000,14 @@
 static
 int nua_refer_server_report(nua_server_request_t *sr, tagi_t const *tags)
 {
-  nua_handle_t *nh = sr->sr_owner;
+	//nua_handle_t *nh = sr->sr_owner;
   struct notifier_usage *nu = nua_dialog_usage_private(sr->sr_usage);
   sip_t const *sip = sr->sr_request.sip;
   sip_referred_by_t *by = sip->sip_referred_by, default_by[1];
   sip_event_t const *o = sr->sr_usage->du_event;
   enum nua_substate substate = nua_substate_terminated;
-  int initial = sr->sr_initial, retval;
+  //int initial = sr->sr_initial, retval;
+  int retval;
 
   if (nu) {
     if (!sr->sr_terminating)
@@ -1005,13 +1030,14 @@
   if (retval >= 2 || nu == NULL)
     return retval;
 
+#if 0
   if (initial)
     nua_stack_post_signal(nh,
 			  nua_r_notify,
 			  SIPTAG_EVENT(o),
 			  SIPTAG_CONTENT_TYPE_STR("message/sipfrag"),
 			  SIPTAG_PAYLOAD_STR("SIP/2.0 100 Trying\r\n"),
-			  TAG_END());
-
+		  TAG_END());
+#endif
   return retval;
 }
diff -ur a/libsofia-sip-ua/nua/nua_params.c b/libsofia-sip-ua/nua/nua_params.c
--- a/libsofia-sip-ua/nua/nua_params.c	2011-03-11 16:49:18.000000000 +0200
+++ b/libsofia-sip-ua/nua/nua_params.c	2017-12-07 23:25:59.760839492 +0200
@@ -139,6 +139,7 @@
   NHP_SET(nhp, only183_100rel, 0);
   NHP_SET(nhp, auto_answer, 0);
   NHP_SET(nhp, auto_ack, 1);
+  NHP_SET(nhp, timer_autorequire, 1);
   NHP_SET(nhp, invite_timeout, 120);
 
   nhp->nhp_session_timer = 1800;
@@ -156,13 +157,11 @@
   NHP_SET(nhp, callee_caps, 0);
   NHP_SET(nhp, service_route_enable, 1);
   NHP_SET(nhp, path_enable, 1);
+  NHP_SET(nhp, retry_after_enable, 1);
 
   NHP_SET(nhp, refer_expires, 300);
   NHP_SET(nhp, refer_with_id, 1);
 
-  NHP_SET(nhp, auto302, 1);
-  NHP_SET(nhp, auto305, 1);
-
   NHP_SET(nhp, substate, nua_substate_active);
   NHP_SET(nhp, sub_expires, 3600);
 
@@ -297,6 +296,7 @@
  *   NUTAG_ONLY183_100REL() \n
  *   NUTAG_OUTBOUND() \n
  *   NUTAG_PATH_ENABLE() \n
+ *   NUTAG_RETRY_AFTER_ENABLE() \n
  *   NUTAG_PROXY() (aka NTATAG_DEFAULT_PROXY()) \n
  *   NUTAG_REFER_EXPIRES() \n
  *   NUTAG_REFER_WITH_ID() \n
@@ -419,6 +419,7 @@
  *   NUTAG_ONLY183_100REL() \n
  *   NUTAG_OUTBOUND() \n
  *   NUTAG_PATH_ENABLE() \n
+ *   NUTAG_RETRY_AFTER_ENABLE() \n
  *   NUTAG_PROXY() (aka NTATAG_DEFAULT_PROXY()) \n
  *   NUTAG_REFER_EXPIRES() \n
  *   NUTAG_REFER_WITH_ID() \n
@@ -744,13 +745,9 @@
     else if (tag == nutag_autoack) {
       NHP_SET(nhp, auto_ack, value != 0);
     }
-    /* NUTAG_AUTO302(auto302) */
-    else if (tag == nutag_auto302) {
-      NHP_SET(nhp, auto302, value != 0);
-    }
-    /* NUTAG_AUTO305(auto305) */
-    else if (tag == nutag_auto305) {
-      NHP_SET(nhp, auto305, value != 0);
+    /* NUTAG_TIMER_AUTOREQUIRE(timer_autorequire) */
+    else if (tag == nutag_timer_autorequire) {
+      NHP_SET(nhp, timer_autorequire, value != 0);
     }
     /* NUTAG_INVITE_TIMER(invite_timeout) */
     else if (tag == nutag_invite_timer) {
@@ -807,6 +804,10 @@
     else if (tag == nutag_path_enable) {
       NHP_SET(nhp, path_enable, value != 0);
     }
+    /* NUTAG_RETRY_AFTER_ENABLE(retry_after_enable) */
+    else if (tag == nutag_retry_after_enable) {
+      NHP_SET(nhp, retry_after_enable, value != 0);
+    }
     /* NUTAG_AUTH_CACHE(auth_cache) */
     else if (tag == nutag_auth_cache) {
       if (value >= 0 && value < (tag_value_t)_nua_auth_cache_invalid)
@@ -968,6 +969,16 @@
 	value = 0;
       NHP_SET_STR(nhp, organization, value);
     }
+    /* SIPTAG_VIA(via) */
+    else if (tag == siptag_via) {
+      NHP_SET_STR_BY_HEADER(nhp, via, value);
+    }
+    /* SIPTAG_VIA_STR(via_str) */
+    else if (tag == siptag_via_str) {
+      if (value == -1)
+	value = 0;
+      NHP_SET_STR(nhp, via, value);
+    }
     /* NUTAG_REGISTRAR(registrar) */
     else if (tag == nutag_registrar) {
       NHP_SET_STR_BY_URL(nhp, char, registrar, value);
@@ -1145,6 +1156,7 @@
   NHP_ZAP_OVERRIDEN(old, dst, msg_header_free, allow_events);
   NHP_ZAP_OVERRIDEN(old, dst, su_free, user_agent);
   NHP_ZAP_OVERRIDEN(old, dst, su_free, organization);
+  NHP_ZAP_OVERRIDEN(old, dst, su_free, via);
   NHP_ZAP_OVERRIDEN(old, dst, su_free, m_display);
   NHP_ZAP_OVERRIDEN(old, dst, su_free, m_username);
   NHP_ZAP_OVERRIDEN(old, dst, su_free, m_params);
@@ -1236,6 +1248,14 @@
     else if (t->t_tag == nutag_sips_url) {
       url = (url_string_t *)t->t_value;
     }
+    /* NUTAG_WS_URL_REF(url) */
+    else if (t->t_tag == nutag_ws_url) {
+      url = (url_string_t *)t->t_value;
+    }
+    /* NUTAG_WSS_URL_REF(url) */
+    else if (t->t_tag == nutag_wss_url) {
+      url = (url_string_t *)t->t_value;
+    }
   }
 
   su_home_auto(tmphome, sizeof tmphome);
@@ -1302,6 +1322,8 @@
 
   if (t->t_tag == nutag_url ||
       t->t_tag == nutag_sips_url ||
+      t->t_tag == nutag_ws_url ||
+      t->t_tag == nutag_wss_url ||
       t->t_tag == nutag_identity)
     return 0;
 
@@ -1489,6 +1511,7 @@
  *   NUTAG_ONLY183_100REL() \n
  *   NUTAG_OUTBOUND() \n
  *   NUTAG_PATH_ENABLE() \n
+ *   NUTAG_RETRY_AFTER_ENABLE() \n
  *   NUTAG_REFER_EXPIRES() \n
  *   NUTAG_REFER_WITH_ID() \n
  *   NUTAG_REFRESH_WITHOUT_SDP() \n
@@ -1647,6 +1670,7 @@
      TIF(NUTAG_ONLY183_100REL, only183_100rel),
      TIF(NUTAG_AUTOANSWER, auto_answer),
      TIF(NUTAG_AUTOACK, auto_ack),
+     TIF(NUTAG_TIMER_AUTOREQUIRE, timer_autorequire),
      TIF(NUTAG_INVITE_TIMER, invite_timeout),
 
      TIFD(NUTAG_SESSION_TIMER, session_timer),
@@ -1663,13 +1687,11 @@
      TIF(NUTAG_MEDIA_FEATURES, media_features),
      TIF(NUTAG_SERVICE_ROUTE_ENABLE, service_route_enable),
      TIF(NUTAG_PATH_ENABLE, path_enable),
+     TIF(NUTAG_RETRY_AFTER_ENABLE, retry_after_enable),
      TIF(NUTAG_AUTH_CACHE, auth_cache),
      TIF(NUTAG_REFER_EXPIRES, refer_expires),
      TIF(NUTAG_REFER_WITH_ID, refer_with_id),
 
-     TIF(NUTAG_AUTO302, auto302),
-     TIF(NUTAG_AUTO305, auto305),
-
      TIF(NUTAG_SUBSTATE, substate),
      TIF(NUTAG_SUB_EXPIRES, sub_expires),
 
@@ -1687,6 +1709,9 @@
      TIF_SIP(SIPTAG_ORGANIZATION, organization),
      TIF(SIPTAG_ORGANIZATION_STR, organization),
 
+     TIF_SIP(SIPTAG_VIA, via),
+     TIF(SIPTAG_VIA_STR, via),
+
      TIF(NUTAG_INITIAL_ROUTE, initial_route),
      TIF_STR(NUTAG_INITIAL_ROUTE_STR, initial_route),
 
diff -ur a/libsofia-sip-ua/nua/nua_params.h b/libsofia-sip-ua/nua/nua_params.h
--- a/libsofia-sip-ua/nua/nua_params.h	2011-03-11 16:49:18.000000000 +0200
+++ b/libsofia-sip-ua/nua/nua_params.h	2017-12-07 23:25:59.760839492 +0200
@@ -109,10 +109,12 @@
 
   /** Always include id with Event: refer */
   unsigned         nhp_refer_with_id:1;
-  /** Redirect automatically with 302 responses */
-  unsigned         nhp_auto302:1;
-  /** Redirect automatically with 305 responses */
-  unsigned         nhp_auto305:1;
+
+  unsigned         nhp_timer_autorequire:1;
+
+  /** Enable Retry-After */
+  unsigned         nhp_retry_after_enable:1;
+
   unsigned:0;
 
   /* Default lifetime for implicit subscriptions created by REFER */
@@ -131,6 +133,7 @@
   sip_allow_events_t *nhp_allow_events;
   char const         *nhp_user_agent;
   char const         *nhp_organization;
+  char const         *nhp_via;
 
   char const         *nhp_m_display;
   char const         *nhp_m_username;
@@ -185,16 +188,13 @@
     unsigned nhb_path_enable:1;
     unsigned nhb_auth_cache:1;
     unsigned nhb_refer_with_id:1;
-    unsigned nhb_auto302:1;
-    unsigned nhb_auto305:1;
     unsigned nhb_refer_expires:1;
     unsigned nhb_substate:1;
     unsigned nhb_sub_expires:1;
     unsigned nhb_keepalive:1;
-    unsigned :0;		/* at most 32 bits before this point */
-
     unsigned nhb_keepalive_stream:1;
     unsigned nhb_registrar:1;
+    unsigned :0;		/* at most 32 bits before this point */
 
     unsigned nhb_allow:1;
     unsigned nhb_supported:1;
@@ -202,6 +202,7 @@
     unsigned nhb_allow_events:1;
     unsigned nhb_user_agent:1;
     unsigned nhb_organization:1;
+    unsigned nhb_via:1;
 
     unsigned nhb_m_display:1;
     unsigned nhb_m_username:1;
@@ -212,6 +213,8 @@
     unsigned nhb_appl_method:1;
     unsigned nhb_initial_route:1;
     unsigned nhb_proxy:1;
+    unsigned nhb_timer_autorequire:1;
+    unsigned nhb_retry_after_enable:1;
     unsigned :0;
   } set_bits;
     unsigned set_unsigned[2];
@@ -220,7 +223,7 @@
 
 #define nhp_set nhp_set_.set_bits
 
-/** @internal Global preferences for nua. */
+/** Global preferences for nua. */
 struct nua_global_preferences {
   /** Network detection: NONE, INFORMAL, TRY_FULL */
   signed int ngp_detect_network_updates:3;
diff -ur a/libsofia-sip-ua/nua/nua_publish.c b/libsofia-sip-ua/nua/nua_publish.c
--- a/libsofia-sip-ua/nua/nua_publish.c	2011-03-11 16:49:18.000000000 +0200
+++ b/libsofia-sip-ua/nua/nua_publish.c	2017-12-07 23:25:59.768839536 +0200
@@ -413,7 +413,7 @@
 	if (!ex || ex->ex_delta == 0)
 	  SET_STATUS(900, "Received Invalid Expiration Time");
 	else
-	  SET_STATUS1(NUA_ERROR_AT(__FILE__, __LINE__));
+	  SET_STATUS(900, _NUA_INTERNAL_ERROR_AT(__FILE__, __LINE__));
       }
       else
 	nua_dialog_usage_set_refresh(du, ex->ex_delta);
diff -ur a/libsofia-sip-ua/nua/nua_register.c b/libsofia-sip-ua/nua/nua_register.c
--- a/libsofia-sip-ua/nua/nua_register.c	2011-03-11 16:49:18.000000000 +0200
+++ b/libsofia-sip-ua/nua/nua_register.c	2017-12-07 23:25:59.776839579 +0200
@@ -49,6 +49,7 @@
 #include <sofia-sip/sip_status.h>
 
 #define NTA_UPDATE_MAGIC_T   struct nua_s
+#define NTA_ERROR_MAGIC_T   struct nua_s
 
 #include "nua_stack.h"
 
@@ -94,6 +95,8 @@
 
 void nua_registration_set_ready(nua_registration_t *nr, int ready);
 
+static void nua_registration_release_tport(nua_registration_t *nr);
+
 /* ====================================================================== */
 /* REGISTER usage */
 
@@ -221,12 +224,8 @@
   nr->nr_compartment = NULL;
 #endif
 
-  if (nr->nr_error_report_id)
-    tport_release(nr->nr_tport, nr->nr_error_report_id, NULL, NULL, nr, 0);
-
-  if (nr->nr_tport)
-    tport_unref(nr->nr_tport), nr->nr_tport = NULL;
-
+  nua_registration_release_tport(nr);
+  
   ds->ds_has_register = 0;	/* There can be only one */
 }
 
@@ -703,11 +702,10 @@
 
   return 0;
 }
-
-static
-int nua_register_client_request(nua_client_request_t *cr,
-				msg_t *msg, sip_t *sip,
-				tagi_t const *tags)
+			
+static int nua_register_client_request(nua_client_request_t *cr,
+				       msg_t *msg, sip_t *sip,
+				       tagi_t const *tags)
 {
   nua_handle_t *nh = cr->cr_owner;
   nua_dialog_usage_t *du = cr->cr_usage;
@@ -780,14 +778,12 @@
       /* Remove the expire parameters from contacts */
       msg_header_remove_param(m->m_common, "expires");
     }
-    else if (nr && nr->nr_min_expires) {
-      unsigned long exp = strtoul(m->m_expires, 0, 10);
-      if (exp != 0 && exp < nr->nr_min_expires) {
-        if (min_expires == NULL)
-          min_expires = su_sprintf(msg_home(msg), "expires=%lu",
-                                   nr->nr_min_expires);
-        msg_header_replace_param(msg_home(msg), m->m_common, min_expires);
-      }
+    else if (nr && nr->nr_min_expires &&
+	     strtoul(m->m_expires, 0, 10) < nr->nr_min_expires) {
+      if (min_expires == NULL)
+	min_expires = su_sprintf(msg_home(msg), "expires=%lu",
+				 nr->nr_min_expires);
+      msg_header_replace_param(msg_home(msg), m->m_common, min_expires);
     }
   }
 
@@ -967,12 +963,8 @@
 
     /* cache persistant connection for registration */
     if (tport && tport != nr->nr_tport) {
-      if (nr->nr_error_report_id) {
-	if (tport_release(nr->nr_tport, nr->nr_error_report_id, NULL, NULL, nr, 0) < 0)
-	  SU_DEBUG_1(("nua_register: tport_release() failed\n"));
-	nr->nr_error_report_id = 0;
-      }
-      tport_unref(nr->nr_tport);
+	  nua_registration_release_tport(nr);
+
       nr->nr_tport = tport;
 
       if (tport_is_secondary(tport)) {
@@ -995,15 +987,8 @@
     outbound_stop_keepalive(nr->nr_ob);
 
     /* release the persistant transport for registration */
-    if (nr->nr_tport) {
-      if (nr->nr_error_report_id) {
-	if (tport_release(nr->nr_tport, nr->nr_error_report_id, NULL, NULL, nr, 0) < 0)
-	  SU_DEBUG_1(("nua_register: tport_release() failed\n"));
-	nr->nr_error_report_id = 0;
-      }
+    nua_registration_release_tport(nr);
 
-      tport_unref(nr->nr_tport), nr->nr_tport = NULL;
-    }
     nua_registration_set_ready(nr, 0);
   }
 
@@ -1011,6 +996,22 @@
   return nua_base_client_response(cr, status, phrase, sip, NULL);
 }
 
+/* Release the persistant transport for registration. */
+static void nua_registration_release_tport(nua_registration_t *nr)
+{
+  if (nr->nr_tport == NULL)
+    return;
+
+  if (nr->nr_error_report_id) {
+    if (tport_release(nr->nr_tport, nr->nr_error_report_id,
+		      NULL, NULL, nr, 0) < 0)
+      SU_DEBUG_1(("nua_register: tport_release() failed\n"));
+    nr->nr_error_report_id = 0;
+  }
+
+  tport_unref(nr->nr_tport), nr->nr_tport = NULL;
+}
+
 static
 void nua_register_connection_closed(tp_stack_t *sip_stack,
 				    nua_registration_t *nr,
@@ -1030,7 +1031,7 @@
   pending = nr->nr_error_report_id;
 
   if (tport_release(tport, pending, NULL, NULL, nr, 0) < 0)
-    SU_DEBUG_1(("nua_register: tport_release() failed\n"));
+    SU_DEBUG_1(("nua_register: tport_release() failed\n" VA_NONE));
   nr->nr_error_report_id = 0;
 
   tpn = tport_name(nr->nr_tport);
@@ -1099,7 +1100,8 @@
   }
 
   /* Report that we have de-registered */
-  nua_stack_event(nua, nh, NULL, nua_r_register, NUA_ERROR_AT(__FILE__, __LINE__), NULL);
+  nua_stack_event(nua, nh, NULL, nua_r_register,
+		  NUA_ERROR_AT(__FILE__, __LINE__), NULL);
   nua_dialog_usage_remove(nh, ds, du, NULL, NULL);
 }
 
@@ -1140,6 +1142,7 @@
 #endif
 
 static void nua_stack_tport_update(nua_t *nua, nta_agent_t *nta);
+static void nua_stack_tport_error(nua_t *nua, nta_agent_t *nta, tport_t *tport);
 static int nua_registration_add_contact_and_route(nua_handle_t *nh,
 						  nua_registration_t *nr,
 						  msg_t *msg,
@@ -1151,12 +1154,16 @@
 nua_stack_init_transport(nua_t *nua, tagi_t const *tags)
 {
   url_string_t const *contact1 = NULL, *contact2 = NULL;
+  url_string_t const *contact3 = NULL, *contact4 = NULL;
   char const *name1 = "sip", *name2 = "sip";
+  char const *name3 = "sip", *name4 = "sip";
   char const *certificate_dir = NULL;
 
   tl_gets(tags,
           NUTAG_URL_REF(contact1),
           NUTAG_SIPS_URL_REF(contact2),
+          NUTAG_WS_URL_REF(contact3),
+          NUTAG_WSS_URL_REF(contact4),
           NUTAG_CERTIFICATE_DIR_REF(certificate_dir),
           TAG_END());
 
@@ -1175,6 +1182,18 @@
        : contact2->us_url->url_type == url_sips))
     name2 = "sips";
 
+  if (contact3 &&
+      (url_is_string(contact3)
+       ? su_casenmatch(contact3->us_str, "sips:", 5)
+       : contact3->us_url->url_type == url_sips))
+    name3 = "sips";
+
+  if (contact4 &&
+      (url_is_string(contact4)
+       ? su_casenmatch(contact4->us_str, "sips:", 5)
+       : contact4->us_url->url_type == url_sips))
+    name4 = "sips";
+
   if (!contact1 /* && !contact2 */) {
     if (nta_agent_add_tport(nua->nua_nta, NULL,
 			    TPTAG_IDENT("sip"),
@@ -1192,7 +1211,7 @@
 			    TPTAG_PUBLIC(tport_type_stun), /* use stun */
 			    TPTAG_CERTIFICATE(certificate_dir),
 			    TAG_NEXT(nua->nua_args)) < 0) {
-      SU_DEBUG_0(("nua: error initializing STUN transport\n"));
+      SU_DEBUG_0(("nua: error initializing STUN transport\n" VA_NONE));
     }
 #endif
   }
@@ -1209,6 +1228,20 @@
 			    TPTAG_CERTIFICATE(certificate_dir),
 			    TAG_NEXT(nua->nua_args)) < 0)
       return -1;
+
+    if (contact3 &&
+	nta_agent_add_tport(nua->nua_nta, contact3,
+			    TPTAG_IDENT(name3),
+			    TPTAG_CERTIFICATE(certificate_dir),
+			    TAG_NEXT(nua->nua_args)) < 0)
+      return -1;
+
+    if (contact4 &&
+	nta_agent_add_tport(nua->nua_nta, contact4,
+			    TPTAG_IDENT(name4),
+			    TPTAG_CERTIFICATE(certificate_dir),
+			    TAG_NEXT(nua->nua_args)) < 0)
+      return -1;
   }
 
 
@@ -1219,6 +1252,7 @@
 }
 
 #if 0
+{
   /* Store network detector param value */
   if (agent->sa_nw_updates == 0)
     agent->sa_nw_updates = nw_updates;
@@ -1227,9 +1261,25 @@
   unsigned nw_updates = 0;
 
   su_network_changed_t *sa_nw_changed;
-
+}
 #endif
 
+static void
+nua_stack_close_tports(nua_t *nua)
+{
+  nua_registration_t **nr_list, **nr_next;
+
+  for (nr_list = &nua->nua_registrations;
+       *nr_list;
+       nr_list = nr_next) {
+    nr_next = &(*nr_list)->nr_next;
+
+    nua_registration_release_tport(*nr_list);
+  }
+
+  nta_agent_close_tports(nua->nua_nta);
+}
+
 static
 void nua_network_changed_cb(nua_t *nua, su_root_t *root)
 {
@@ -1246,7 +1296,7 @@
   case NUA_NW_DETECT_TRY_FULL:
 
     /* 1) Shutdown all tports */
-    nta_agent_close_tports(nua->nua_nta);
+    nua_stack_close_tports(nua);
 
     /* 2) Create new tports */
     if (nua_stack_init_transport(nua, nua->nua_args) < 0)
@@ -1343,7 +1393,9 @@
     }
   }
 
-  nta_agent_bind_tport_update(nua->nua_nta, (nta_update_magic_t *)nua, nua_stack_tport_update);
+  nta_agent_bind_tport_update(nua->nua_nta, (nta_update_magic_t *)nua,
+			      nua_stack_tport_update);
+  nta_agent_bind_tport_error(nua->nua_nta, (nta_error_magic_t *)nua, nua_stack_tport_error);
 
   return 0;
 }
@@ -1449,6 +1501,12 @@
 }
 
 static
+void nua_stack_tport_error(nua_t *nua, nta_agent_t *nta, tport_t *tport)
+{
+  return;
+}
+
+static
 void nua_stack_tport_update(nua_t *nua, nta_agent_t *nta)
 {
 #if 0
@@ -1881,14 +1939,14 @@
 				     nta_incoming_t *irq,
 				     sip_t const *sip)
 {
-  sip_call_id_t *i;
+  //sip_call_id_t *i;
   nua_registration_t *nr;
 
   if (!outbound_targeted_request(sip))
     return 0;
 
   /* Process by outbound... */
-  i = sip->sip_call_id;
+  //i = sip->sip_call_id;
 
   for (nr = list; nr; nr = nr->nr_next) {
     outbound_t *ob = nr->nr_ob;
diff -ur a/libsofia-sip-ua/nua/nua_registrar.c b/libsofia-sip-ua/nua/nua_registrar.c
--- a/libsofia-sip-ua/nua/nua_registrar.c	2011-03-11 16:49:18.000000000 +0200
+++ b/libsofia-sip-ua/nua/nua_registrar.c	2017-12-07 23:25:59.776839579 +0200
@@ -39,6 +39,9 @@
 
 #include <assert.h>
 
+#define TP_CLIENT_T struct nua_handle_s
+#define TP_STACK_T struct nta_agent_s
+
 #include <sofia-sip/su_string.h>
 #include <sofia-sip/sip_protos.h>
 #include <sofia-sip/sip_status.h>
@@ -49,6 +52,79 @@
 
 #include "nua_stack.h"
 
+#include <sofia-sip/tport.h>
+#include <sofia-sip/nta_tport.h>
+
+/* ---------------------------------------------------------------------- */
+/* Registrar usage */
+
+struct registrar_usage
+{
+  tport_t *tport;		 /**<  */
+  int pending;			 /**< Waiting for tport to close */
+};
+
+static char const *nua_registrar_usage_name(nua_dialog_usage_t const *du)
+{
+  return "registrar";
+}
+
+static int nua_registrar_usage_add(nua_handle_t *nh,
+				   nua_dialog_state_t *ds,
+				   nua_dialog_usage_t *du)
+{
+  return 0;
+}
+
+static void nua_registrar_usage_remove(nua_handle_t *nh,
+				       nua_dialog_state_t *ds,
+				       nua_dialog_usage_t *du,
+				       nua_client_request_t *cr,
+				       nua_server_request_t *sr)
+{
+  struct registrar_usage *ru;
+
+  ru = nua_dialog_usage_private(du);
+
+  if (ru->pending)
+    tport_release(ru->tport, ru->pending, NULL, NULL, nh, 0), ru->pending = 0;
+
+  tport_unref(ru->tport), ru->tport = NULL;
+}
+
+static void nua_registrar_usage_refresh(nua_handle_t *nh,
+					nua_dialog_state_t *ds,
+					nua_dialog_usage_t *du,
+					sip_time_t now)
+{
+}
+
+/** Terminate registration usage.
+ *
+ * @retval >0  shutdown done
+ * @retval 0   shutdown in progress
+ * @retval <0  try again later
+ */
+static int nua_registrar_usage_shutdown(nua_handle_t *nh,
+					nua_dialog_state_t *ds,
+					nua_dialog_usage_t *du)
+{
+  return 1;
+}
+
+static nua_usage_class const nua_registrar_usage[1] = {
+  {
+    sizeof (struct registrar_usage), sizeof nua_registrar_usage,
+    nua_registrar_usage_add,
+    nua_registrar_usage_remove,
+    nua_registrar_usage_name,
+    nua_base_usage_update_params,
+    NULL,
+    nua_registrar_usage_refresh,
+    nua_registrar_usage_shutdown
+  }};
+
+
 /* ======================================================================== */
 /* REGISTER */
 
@@ -93,6 +169,9 @@
  * @END_NUA_EVENT
  */
 
+static int nua_registrar_server_preprocess(nua_server_request_t *sr);
+static int nua_registrar_server_report(nua_server_request_t *, tagi_t const *);
+
 nua_server_methods_t const nua_register_server_methods =
   {
     SIP_METHOD_REGISTER,
@@ -104,8 +183,80 @@
       0,			/* Do not add Contact */
     },
     nua_base_server_init,
-    nua_base_server_preprocess,
+    nua_registrar_server_preprocess,
     nua_base_server_params,
     nua_base_server_respond,
-    nua_base_server_report,
+    nua_registrar_server_report,
   };
+
+static void
+registrar_tport_error(nta_agent_t *nta, nua_handle_t *nh,
+		      tport_t *tp, msg_t *msg, int error)
+{
+  nua_dialog_state_t *ds = nh->nh_ds;
+  nua_dialog_usage_t *du;
+  struct registrar_usage *ru;
+
+  SU_DEBUG_3(("tport error %d: %s\n", error, su_strerror(error)));
+
+  du = nua_dialog_usage_get(ds, nua_registrar_usage, NULL);
+
+  if (du == NULL)
+    return;
+
+  ru = nua_dialog_usage_private(du);
+  if (ru->tport) {
+    tport_release(ru->tport, ru->pending, NULL, NULL, nh, 0), ru->pending = 0;
+    tport_unref(ru->tport), ru->tport = NULL;
+  }
+
+  nua_stack_event(nh->nh_nua, nh, NULL,
+		  nua_i_media_error, 500, "Transport error detected",
+		  NULL);
+}
+
+static int
+nua_registrar_server_preprocess(nua_server_request_t *sr)
+{
+  nua_handle_t *nh = sr->sr_owner;
+  nua_dialog_state_t *ds = sr->sr_owner->nh_ds;
+  nua_dialog_usage_t *du;
+  struct registrar_usage *ru;
+  tport_t *tport;
+
+  tport = nta_incoming_transport(nh->nh_nua->nua_nta, sr->sr_irq, sr->sr_request.msg);
+
+  if (!tport_is_tcp(tport)) {
+	  tport_unref(tport);
+	  return 0;
+  }
+
+  du = nua_dialog_usage_get(ds, nua_registrar_usage, NULL);
+  if (du == NULL)
+    du = nua_dialog_usage_add(nh, ds, nua_registrar_usage, NULL);
+
+  if (du == NULL)
+    return SR_STATUS1(sr, SIP_500_INTERNAL_SERVER_ERROR);
+
+  ru = nua_dialog_usage_private(du);
+
+  if (ru->tport && ru->tport != tport) {
+    tport_release(ru->tport, ru->pending, NULL, NULL, nh, 0), ru->pending = 0;
+    tport_unref(ru->tport), ru->tport = NULL;
+  }
+
+  ru->tport = tport;
+  ru->pending = tport_pend(tport, NULL, registrar_tport_error, nh);
+
+  tport_set_params(tport,
+		   TPTAG_SDWN_ERROR(1),
+		   TAG_END());
+
+  return 0;
+}
+
+static int
+nua_registrar_server_report(nua_server_request_t *sr, tagi_t const *tags)
+{
+  return nua_base_server_report(sr, tags);
+}
diff -ur a/libsofia-sip-ua/nua/nua_server.c b/libsofia-sip-ua/nua/nua_server.c
--- a/libsofia-sip-ua/nua/nua_server.c	2011-03-11 16:49:18.000000000 +0200
+++ b/libsofia-sip-ua/nua/nua_server.c	2017-12-07 23:25:59.784839623 +0200
@@ -158,14 +158,15 @@
     /* These must be in-dialog */
     sm = NULL;
   }
-  else if (initial && sip->sip_to->a_tag) {
+  else if (initial && sip->sip_to->a_tag && method != sip_method_subscribe) {
     /* RFC 3261 section 12.2.2:
 
        If the UAS wishes to reject the request because it does not wish to
        recreate the dialog, it MUST respond to the request with a 481
        (Call/Transaction Does Not Exist) status code and pass that to the
        server transaction.
-    */
+    */ /* we allow this on subscribes because we have disabled the built-in notify server and we need those messages in the application layer */
+	  
     if (method == sip_method_info)
       /* accept out-of-dialog info */; else
     if (method != sip_method_message || !NH_PGET(nh, win_messenger_enable))
@@ -260,11 +261,12 @@
   }
 
   if (sr->sr_status <= 100) {
-    SR_STATUS1(sr, SIP_100_TRYING);
+	  	  SR_STATUS1(sr, SIP_100_TRYING);
     if (method == sip_method_invite || sip->sip_timestamp) {
-      nta_incoming_treply(irq, SIP_100_TRYING,
-			  SIPTAG_USER_AGENT_STR(user_agent),
-			  TAG_END());
+		nta_incoming_treply(irq, SIP_100_TRYING,
+							SIPTAG_USER_AGENT_STR(user_agent),
+							TAG_END());
+
     }
   }
   else {
@@ -293,31 +295,43 @@
 
 void nua_server_request_destroy(nua_server_request_t *sr)
 {
+  nua_server_request_t *sr0 = NULL;
+
   if (sr == NULL)
     return;
 
   if (SR_HAS_SAVED_SIGNAL(sr))
     nua_destroy_signal(sr->sr_signal);
 
+  if (sr->sr_prev) {
+    /* Allocated from heap */
+    if ((*sr->sr_prev = sr->sr_next))
+      sr->sr_next->sr_prev = sr->sr_prev;
+	sr0 = sr;
+  }
+
   if (sr->sr_irq) {
+	nta_incoming_t *irq = sr->sr_irq;
     if (sr->sr_method == sip_method_bye && sr->sr_status < 200) {
       nta_incoming_treply(sr->sr_irq, SIP_200_OK, TAG_END());
     }
-    nta_incoming_destroy(sr->sr_irq), sr->sr_irq = NULL;
+	sr->sr_irq = NULL;
+    nta_incoming_destroy(irq);
   }
 
-  if (sr->sr_request.msg)
-    msg_destroy(sr->sr_request.msg), sr->sr_request.msg = NULL;
-
-  if (sr->sr_response.msg)
-    msg_destroy(sr->sr_response.msg), sr->sr_response.msg = NULL;
+  if (sr->sr_request.msg) {
+	msg_t *msg = sr->sr_request.msg;
+	sr->sr_request.msg = NULL;
+    msg_destroy(msg);
+  }
 
-  if (sr->sr_prev) {
-    /* Allocated from heap */
-    if ((*sr->sr_prev = sr->sr_next))
-      sr->sr_next->sr_prev = sr->sr_prev;
-    su_free(sr->sr_owner->nh_home, sr);
+  if (sr->sr_response.msg) {
+	msg_t *msg = sr->sr_response.msg;
+	sr->sr_response.msg = NULL;
+    msg_destroy(msg); 
   }
+
+  if (sr0) su_free(sr->sr_owner->nh_home, sr0);
 }
 
 /**@fn void nua_respond(nua_handle_t *nh, int status, char const *phrase, tag_type_t tag, tag_value_t value, ...);
@@ -509,7 +523,8 @@
 #endif
 
   if (sr->sr_response.msg == NULL) {
-    assert(sr->sr_status == 500);
+	  //assert(sr->sr_status == 500);
+	  SU_DEBUG_0(("sr without msg, sr_status=%u", sr->sr_status));
     goto internal_error;
   }
 
@@ -536,6 +551,10 @@
 	   sip_add_make(msg, sip, sip_organization_class,
 			NH_PGET(nh, organization)) < 0)
     ;
+  else if (!sip->sip_via && NH_PGET(nh, via) &&
+	   sip_add_make(msg, sip, sip_via_class,
+			NH_PGET(nh, via)) < 0)
+    ;
   else if (!sip->sip_allow && NH_PGET(nh, allow) &&
 	   sip_add_dup(msg, sip, (void *)NH_PGET(nh, allow)) < 0)
     ;
@@ -697,12 +716,11 @@
 
   if (initial && 300 <= status)
     terminated = 1;
+  else if (sr->sr_terminating && status < 300)
+    terminated = 1;
   else
     terminated = sip_response_terminates_dialog(status, sr->sr_method, NULL);
 
-  if (sr->sr_terminating & !terminated)
-    terminated = 1;
-
   if (usage && terminated)
     nua_dialog_usage_remove(nh, nh->nh_ds, usage, NULL, sr);
 
diff -ur a/libsofia-sip-ua/nua/nua_session.c b/libsofia-sip-ua/nua/nua_session.c
--- a/libsofia-sip-ua/nua/nua_session.c	2011-03-11 16:49:18.000000000 +0200
+++ b/libsofia-sip-ua/nua/nua_session.c	2017-12-07 23:25:59.792839666 +0200
@@ -44,6 +44,7 @@
 #include <sofia-sip/sip_status.h>
 #include <sofia-sip/sip_util.h>
 #include <sofia-sip/su_uniqueid.h>
+#include <sofia-sip/msg_mime_protos.h>
 
 #define NTA_INCOMING_MAGIC_T struct nua_server_request
 #define NTA_OUTGOING_MAGIC_T struct nua_client_request
@@ -269,8 +270,10 @@
       ss->ss_reporting = 0;
     }
 
-    if (cr == du->du_cr && cr->cr_orq)
+    if (cr == du->du_cr && cr->cr_orq) {
+      nua_client_request_unref(cr);
       continue;
+    }
 
     if (cr->cr_status < 200) {
       nua_stack_event(nh->nh_nua, nh,
@@ -369,7 +372,8 @@
 
 static int session_timer_add_headers(struct session_timer *t,
 				     int initial,
-				     msg_t *msg, sip_t *sip);
+					 msg_t *msg, sip_t *sip,
+					 nua_handle_t *nh);
 
 static void session_timer_negotiate(struct session_timer *t, int uas);
 
@@ -790,7 +794,7 @@
   /* Add session timer headers */
   if (session_timer_is_supported(ss->ss_timer))
     session_timer_add_headers(ss->ss_timer, ss->ss_state == nua_callstate_init,
-			      msg, sip);
+				  msg, sip, nh);
 
   ss->ss_100rel = NH_PGET(nh, early_media);
   ss->ss_precondition = sip_has_feature(sip->sip_require, "precondition");
@@ -800,11 +804,8 @@
   if (nh->nh_soa) {
     soa_init_offer_answer(nh->nh_soa);
 
-    if (soa_is_delayed_offer(nh->nh_soa))
-      offer_sent = 0;
-    else if (sip->sip_payload)
-      /* Kludge, we should probably use multipart */
-      offer_sent = 0;
+    if (sip->sip_payload)
+      offer_sent = 0;		/* XXX - kludge */
     else if (soa_generate_offer(nh->nh_soa, 0, NULL) < 0)
       return -1;
     else
@@ -946,14 +947,19 @@
   SU_DEBUG_5(("nua(%p): %s: %s %s in %u %s\n", \
 	      (void *)nh, cr->cr_method_name, (m), received, status, phrase))
 
+ retry:
+
   if (!ss || !sip || 300 <= status)
     /* Xyzzy */;
   else if (!session_get_description(sip, &sdp, &len))
     /* No SDP */;
   else if (cr->cr_answer_recv) {
     /* Ignore spurious answers after completing O/A */
-    LOG3("ignoring duplicate");
-    sdp = NULL;
+	  //LOG3("ignoring duplicate");
+	  //sdp = NULL;
+	  // we need to make sure its *actually* a dup, so we can't assume for now.
+	  cr->cr_answer_recv = 0;
+	  goto retry;
   }
   else if (cr->cr_offer_sent) {
     /* case 1: answer to our offer */
@@ -1241,6 +1247,7 @@
   int status = 200;
   char const *phrase = "OK", *reason = NULL;
   char const *invite_branch;
+  char const *pl_s = NULL;
 
   assert(cr->cr_orq);
   assert(cr->cr_method == sip_method_invite);
@@ -1252,6 +1259,11 @@
     goto error;
   }
 
+  tl_gets(tags,
+		  SIPTAG_PAYLOAD_STR_REF(pl_s),
+		  TAG_END());
+  
+
   assert(ds->ds_leg);
 
   msg = nta_outgoing_getrequest(cr->cr_orq);
@@ -1301,7 +1313,7 @@
     while (sip->sip_supported)
       sip_header_remove(msg, sip, (sip_header_t*)sip->sip_supported);
 
-    if (ss == NULL || ss->ss_state > nua_callstate_ready)
+    if (ss == NULL || ss->ss_state > nua_callstate_ready || pl_s)
       ;
     else if (cr->cr_offer_recv && !cr->cr_answer_sent) {
       if (nh->nh_soa == NULL) {
@@ -1537,10 +1549,12 @@
       nua_client_request_in_progress(cr))
     return;
 
+  if (ds->ds_cr) return; /* request queued */
+
   /* UPDATE has been queued */
-  for (cr = ds->ds_cr; cr; cr = cr->cr_next)
-    if (cr->cr_method == sip_method_update)
-      return;
+  //for (cr = ds->ds_cr; cr; cr = cr->cr_next)
+  //if (cr->cr_method == sip_method_update)
+  //  return;
 
   /* INVITE or UPDATE in progress on server side */
   for (sr = ds->ds_sr; sr; sr = sr->sr_next)
@@ -1550,6 +1564,7 @@
       return;
 
   if (ss->ss_timer->refresher == nua_remote_refresher) {
+    SU_DEBUG_3(("nua(%p): session almost expired, sending BYE before timeout.\n", (void *)nh));
     ss->ss_reason = "SIP;cause=408;text=\"Session timeout\"";
     nua_stack_bye(nh->nh_nua, nh, nua_r_bye, NULL);
     return;
@@ -1739,7 +1754,7 @@
   nua_client_request_t *cri;
   int offer_sent = 0, answer_sent = 0, retval;
   int status = 0; char const *phrase = "PRACK Sent";
-  uint32_t rseq = 0;
+  //uint32_t rseq = 0;
 
   if (du == NULL)		/* Call terminated */
     return nua_client_return(cr, SIP_481_NO_TRANSACTION, msg);
@@ -1750,8 +1765,8 @@
 
   cri = du->du_cr;
 
-  if (sip->sip_rack)
-    rseq = sip->sip_rack->ra_response;
+//  if (sip->sip_rack)
+//    rseq = sip->sip_rack->ra_response;
 
   if (cri->cr_offer_recv && !cri->cr_answer_sent) {
     if (nh->nh_soa == NULL)
@@ -1811,12 +1826,6 @@
     cr->cr_offer_sent = offer_sent;
     cr->cr_answer_sent = answer_sent;
 
-    if (cri->cr_offer_recv && answer_sent) {
-      cr->cr_answer_sent = 0;
-      cri->cr_offer_recv = 0;
-      cri->cr_answer_sent = 0;
-    }
-
     if (offer_sent)
       ss->ss_oa_sent = Offer;
     else if (answer_sent)
@@ -2117,7 +2126,7 @@
   msg_t *msg = sr->sr_response.msg;
   sip_t *sip = sr->sr_response.sip;
 
-  sip_t const *request = sr->sr_request.sip;
+  sip_t *request = (sip_t *) sr->sr_request.sip;
 
   if (!sr->sr_initial)
     sr->sr_usage = nua_dialog_usage_get(nh->nh_ds, nua_session_usage, NULL);
@@ -2138,6 +2147,54 @@
     /* XXX - soa should know what it supports */
     sip_add_dup(msg, sip, (sip_header_t *)a);
 
+	/* if we see there is a multipart content-type, 
+	   parse it into the sip structre and find the SDP and replace it 
+	   into the request as the requested content */
+	if (request->sip_content_type &&
+        su_casenmatch(request->sip_content_type->c_type, "multipart/", 10)) {
+		msg_multipart_t *mp, *mpp;
+
+		if (request->sip_multipart) {
+			mp = request->sip_multipart;
+		} else {
+			mp = msg_multipart_parse(nua_handle_home(nh),
+									 request->sip_content_type,
+									 (sip_payload_t *)request->sip_payload);
+			request->sip_multipart = mp;
+		}
+
+		if (mp) {
+			int sdp = 0;
+			
+			/* extract the SDP and set the primary content-type and payload to that SDP as if it was the only content so SOA will work */
+			for(mpp = mp; mpp; mpp = mpp->mp_next) {
+				if (mpp->mp_content_type && mpp->mp_content_type->c_type && 
+					mpp->mp_payload && mpp->mp_payload->pl_data && 
+					su_casenmatch(mpp->mp_content_type->c_type, "application/sdp", 15)) {
+
+					request->sip_content_type = msg_content_type_dup(nua_handle_home(nh), mpp->mp_content_type);
+					
+					if (request->sip_content_length) {
+						request->sip_content_length->l_length = mpp->mp_payload->pl_len;
+					}
+					
+					request->sip_payload->pl_data = su_strdup(nua_handle_home(nh), mpp->mp_payload->pl_data);
+					request->sip_payload->pl_len = mpp->mp_payload->pl_len;
+
+					sdp++;
+
+					break;
+				}
+			}
+
+			/* insist on the existance of a SDP in the content or refuse the request */
+			if (!sdp) {
+				return SR_STATUS1(sr, SIP_406_NOT_ACCEPTABLE);
+			}
+		}
+	}
+
+
     /* Make sure caller uses application/sdp without compression */
     if (nta_check_session_content(NULL, request, a, TAG_END())) {
       sip_add_make(msg, sip, sip_accept_encoding_class, "");
@@ -2390,7 +2447,7 @@
 			      NH_PGET(nh, min_se));
 
     if (session_timer_is_supported(ss->ss_timer))
-      session_timer_add_headers(ss->ss_timer, 0, msg, sip);
+	  session_timer_add_headers(ss->ss_timer, 0, msg, sip, nh);
   }
 
   return nua_base_server_respond(sr, tags);
@@ -2897,7 +2954,7 @@
   nua_session_usage_t *ss = nua_dialog_usage_private(sr->sr_usage);
   nua_server_request_t *sri = nta_incoming_magic(sr->sr_irq, NULL);
   int status = sr->sr_status; char const *phrase = sr->sr_phrase;
-  int offer_recv_or_answer_sent = sr->sr_offer_recv || sr->sr_answer_sent;
+  int offer_recv_or_answer_sent = sr->sr_offer_recv || sr->sr_answer_sent || sr->sr_offer_sent || sr->sr_answer_recv;
   int retval;
 
   retval = nua_base_server_report(sr, tags), sr = NULL; /* destroys sr */
@@ -2992,11 +3049,11 @@
     ref->ref_event = sip_event_dup(nh->nh_home, event);
 
   if (!nh_validate(nh->nh_nua, ref_handle)) {
-    SU_DEBUG_3(("nua: invalid NOTIFY_REFER handle\n"));
+    SU_DEBUG_3(("nua: invalid NOTIFY_REFER handle\n" VA_NONE));
     return -1;
   }
   else if (!ref->ref_event) {
-    SU_DEBUG_3(("nua: NOTIFY event missing\n"));
+    SU_DEBUG_3(("nua: NOTIFY event missing\n" VA_NONE));
     return -1;
   }
 
@@ -3308,7 +3365,7 @@
 
   if (session_timer_is_supported(ss->ss_timer))
     session_timer_add_headers(ss->ss_timer, ss->ss_state < nua_callstate_ready,
-			      msg, sip);
+				  msg, sip, nh);
 
   retval = nua_base_client_request(cr, msg, sip, NULL);
 
@@ -3499,8 +3556,9 @@
 	if ((overlap = sr0->sr_offer_recv && !sr0->sr_answer_sent))
 	  break;
 
-    if (nh->nh_soa && overlap)
-      return nua_server_retry_after(sr, 500, "Overlapping Offer/Answer", 1, 9);
+    if (nh->nh_soa && overlap) {
+		return nua_server_retry_after(sr, 500, "Overlapping Offer/Answer", 1, 9);
+	}
 
     if (nh->nh_soa &&
 	soa_set_remote_sdp(nh->nh_soa, NULL, sr->sr_sdp, sr->sr_sdp_len) < 0) {
@@ -3563,7 +3621,7 @@
       nua_server_request_t *sr0;
       int uas;
 
-      session_timer_add_headers(ss->ss_timer, 0, msg, sip);
+      session_timer_add_headers(ss->ss_timer, 0, msg, sip, nh);
 
       for (sr0 = nh->nh_ds->ds_sr; sr0; sr0 = sr0->sr_next)
 	if (sr0->sr_method == sip_method_invite)
@@ -3674,6 +3732,9 @@
 static int nua_bye_client_request(nua_client_request_t *cr,
 				  msg_t *msg, sip_t *sip,
 				  tagi_t const *tags);
+static int nua_bye_client_response(nua_client_request_t *cr,
+				      int status, char const *phrase,
+				      sip_t const *sip);
 static int nua_bye_client_report(nua_client_request_t *cr,
 				 int status, char const *phrase,
 				 sip_t const *sip,
@@ -3692,7 +3753,7 @@
   nua_bye_client_init,		/* crm_init */
   nua_bye_client_request,	/* crm_send */
   NULL,				/* crm_check_restart */
-  NULL,				/* crm_recv */
+  nua_bye_client_response,	/* crm_recv */
   NULL,				/* crm_preliminary */
   nua_bye_client_report,	/* crm_report */
   NULL,				/* crm_complete */
@@ -3771,6 +3832,18 @@
 
   return error;
 }
+static int nua_bye_client_response(nua_client_request_t *cr,
+				      int status, char const *phrase,
+				      sip_t const *sip) {
+
+  nua_dialog_usage_t *du = cr->cr_usage;
+  nua_session_usage_t *ss = nua_dialog_usage_private(du);
+
+  if (ss && ss->ss_reporting && status >= 900)
+    return 1;
+
+  return nua_base_client_response(cr, status, phrase, sip, NULL);
+}
 
 /** @NUA_EVENT nua_r_bye
  *
@@ -3938,7 +4011,7 @@
 
   retval = nua_base_server_report(sr, tags);
 
-  assert(2 <= retval && retval < 4);
+  //assert(2 <= retval && retval < 4);
 
 #if 0
   if (ss) {
@@ -4364,18 +4437,24 @@
 session_timer_add_headers(struct session_timer *t,
 			  int initial,
 			  msg_t *msg,
-			  sip_t *sip)
+			  sip_t *sip,
+			  nua_handle_t *nh)
 {
   unsigned long expires, min;
   sip_min_se_t min_se[1];
   sip_session_expires_t x[1];
   int uas;
+  int autorequire = 1;
 
   enum nua_session_refresher refresher = nua_any_refresher;
 
   static sip_param_t const x_params_uac[] = {"refresher=uac", NULL};
   static sip_param_t const x_params_uas[] = {"refresher=uas", NULL};
 
+  if ( !NH_PGET(nh, timer_autorequire) && NH_PISSET(nh, timer_autorequire)) {
+    autorequire = 0;
+  }
+
   if (!t->local.supported)
     return 0;
 
@@ -4424,14 +4503,13 @@
     return 1;
 
   sip_add_tl(msg, sip,
-	     TAG_IF(expires != 0, SIPTAG_SESSION_EXPIRES(x)),
-	     TAG_IF(min != 0
-		    /* Min-SE: 0 is optional with initial INVITE */
-		    || !initial,
-		    SIPTAG_MIN_SE(min_se)),
-	     TAG_IF(refresher == nua_remote_refresher && expires != 0,
-		    SIPTAG_REQUIRE_STR("timer")),
-	     TAG_END());
+			 TAG_IF(expires != 0, SIPTAG_SESSION_EXPIRES(x)),
+			 TAG_IF((!uas || sip->sip_status->st_status == 422) && (min != 0
+					/* Min-SE: 0 is optional with initial INVITE */
+					 || !initial),
+					SIPTAG_MIN_SE(min_se)),
+			 TAG_IF(autorequire && refresher == nua_remote_refresher && expires != 0, SIPTAG_REQUIRE_STR("timer")),
+			 TAG_END());
 
   return 1;
 }
@@ -4496,14 +4574,14 @@
     t->timer_set = 1;
   }
   else if (t->refresher == nua_remote_refresher) {
-    /* if the side not performing refreshes does not receive a
-       session refresh request before the session expiration, it SHOULD send
-       a BYE to terminate the session, slightly before the session
-       expiration.  The minimum of 32 seconds and one third of the session
-       interval is RECOMMENDED. */
+    /* RFC 4028 10.3 and 10.4: Send BYE before the session expires.
+       Increased interval from 2/3 to 9/10 of session expiration delay
+       because some endpoints won't UPDATE early enough with very short
+       sessions (e.g. 120). */
+
     unsigned interval = t->interval;
 
-    interval -= 32 > interval / 3 ? interval / 3 : 32;
+    interval -= 32 > interval / 10 ? interval / 10 : 32;
 
     nua_dialog_usage_set_refresh_range(du, interval, interval);
     t->timer_set = 1;
@@ -4514,12 +4592,6 @@
   }
 }
 
-su_inline int
-session_timer_has_been_set(struct session_timer const *t)
-{
-  return t->timer_set;
-}
-
 /* ======================================================================== */
 
 /** Get SDP from a SIP message.
diff -ur a/libsofia-sip-ua/nua/nua_stack.c b/libsofia-sip-ua/nua/nua_stack.c
--- a/libsofia-sip-ua/nua/nua_stack.c	2011-03-11 16:49:18.000000000 +0200
+++ b/libsofia-sip-ua/nua/nua_stack.c	2017-12-07 23:25:59.796839688 +0200
@@ -192,7 +192,7 @@
       dnh->nh_ds->ds_leg == NULL ||
       nta_agent_set_params(nua->nua_nta, NTATAG_UA(1), TAG_END()) < 0 ||
       nua_stack_init_transport(nua, nua->nua_args) < 0) {
-    SU_DEBUG_1(("nua: initializing SIP stack failed\n"));
+    SU_DEBUG_1(("nua: initializing SIP stack failed\n" VA_NONE));
     return -1;
   }
 
@@ -396,7 +396,9 @@
 		      e->e_msg ? sip_object(e->e_msg) : NULL,
 		      e->e_tags);
 
-    su_msg_destroy(frame->nf_saved);
+	if (su_msg_is_non_null(frame->nf_saved)) {
+		su_msg_destroy(frame->nf_saved);
+	}
     nua->nua_current = frame->nf_next;
   }
 
@@ -417,6 +419,23 @@
   return NULL;
 }
 
+
+su_msg_t *nua_current_msg(nua_t const *nua, int clear)
+{
+	if (nua && nua->nua_current && su_msg_is_non_null(nua->nua_current->nf_saved)) {
+		su_msg_t *r = nua->nua_current->nf_saved[0];
+		if (clear) {
+			nua->nua_current->nf_saved[0] = NULL;
+		}
+		return r;
+		//return su_msg_data(nua->nua_current->nf_saved)->ee_data->e_msg;
+		
+	}
+
+  return NULL;
+}
+
+
 /** Get request message from saved nua event. @NEW_1_12_4.
  *
  * @sa nua_save_event(), nua_respond(), NUTAG_WITH_SAVED(),
@@ -638,8 +657,10 @@
     nua_stack_respond(nua, nh, e->e_status, e->e_phrase, tags);
     break;
   case nua_r_destroy:
-    nua_stack_destroy_handle(nua, nh, tags);
-    su_msg_destroy(nua->nua_signal);
+	  if (!nh->nh_destroyed) {
+		  nua_stack_destroy_handle(nua, nh, tags);
+		  su_msg_destroy(nua->nua_signal);
+	  }
     return;
   default:
     break;
@@ -856,7 +877,7 @@
   if (status >= 200) {
     for (nh = nua->nua_handles; nh; nh = nh_next) {
       nh_next = nh->nh_next;
-      while (nh->nh_ds && nh->nh_ds->ds_usage) {
+      while (nh->nh_ds->ds_usage) {
 	nua_dialog_usage_remove(nh, nh->nh_ds, nh->nh_ds->ds_usage, NULL, NULL);
       }
     }
@@ -912,6 +933,10 @@
 
 void nua_stack_destroy_handle(nua_t *nua, nua_handle_t *nh, tagi_t const *tags)
 {
+  if (nh->nh_destroyed) {
+	  return;
+  }
+
   if (nh->nh_notifier)
     nua_stack_terminate(nua, nh, (enum nua_event_e)0, NULL);
 
@@ -949,6 +974,12 @@
 {
   assert(nh); assert(nh != nua->nua_dhandle);
 
+  if (nh->nh_destroyed) {
+	  return;
+  }
+
+  nh->nh_destroyed = 1;
+
   if (nh->nh_notifier)
     nea_server_destroy(nh->nh_notifier), nh->nh_notifier = NULL;
 
@@ -1065,7 +1096,7 @@
 					       su_home_t *home,
 					       int early_only)
 {
-  if (nh && nh->nh_ds && nh->nh_ds->ds_leg)
+  if (nh && nh->nh_ds->ds_leg)
     return nta_leg_make_replaces(nh->nh_ds->ds_leg, home, early_only);
   else
     return NULL;
diff -ur a/libsofia-sip-ua/nua/nua_stack.h b/libsofia-sip-ua/nua/nua_stack.h
--- a/libsofia-sip-ua/nua/nua_stack.h	2011-03-11 16:49:18.000000000 +0200
+++ b/libsofia-sip-ua/nua/nua_stack.h	2017-12-07 23:25:59.796839688 +0200
@@ -77,13 +77,17 @@
 
 typedef struct event_s event_t, nua_signal_data_t;
 
-/** @internal Extended event data. */
+/** Extended event data. */
 typedef struct nua_ee_data {
   nua_t *ee_nua;
   nua_event_data_t ee_data[1];
 } nua_ee_data_t;
 
+#ifndef _MSC_VER
 #define       NONE ((void *)-1)
+#else
+#define       NONE ((void *)(INT_PTR)-1)
+#endif
 
 typedef struct register_usage nua_registration_t;
 
@@ -146,6 +150,7 @@
   unsigned        nh_ref_by_user:1;	/**< Has user used the handle? */
   unsigned        nh_init:1;	        /**< Handle has been initialized */
   unsigned        nh_used_ptags:1;	/**< Ptags has been used */
+  unsigned        nh_destroyed:1;	/**< nh_destroy already called */
   unsigned :0;
 
   nua_dialog_state_t nh_ds[1];
@@ -334,6 +339,8 @@
 		    nua_event_t event, int status, char const *phrase,
 		    tagi_t const *tags);
 
+su_msg_t *nua_current_msg(nua_t const *nua, int clear);
+
 void nua_move_event(nua_saved_event_t a[1], nua_saved_event_t b[1]);
 
 nua_handle_t *nh_create_handle(nua_t *nua, nua_hmagic_t *hmagic, tagi_t *tags);
diff -ur a/libsofia-sip-ua/nua/nua_tag.c b/libsofia-sip-ua/nua/nua_tag.c
--- a/libsofia-sip-ua/nua/nua_tag.c	2011-03-11 16:49:18.000000000 +0200
+++ b/libsofia-sip-ua/nua/nua_tag.c	2017-12-07 23:25:59.812839775 +0200
@@ -44,13 +44,12 @@
 
 /** @page nua_api_overview NUA API Overview
  *
- * This page gives a short overview of the NUA API: different functions,
- * events, tags, and where and how they affect the workings of the NUA
- * engine.
+ * This page shortly overviews the NUA API: different functions, tags, and
+ * where and how they affect the working of NUA engine.
  *
  * The application and the NUA engine can pass various parameters between
  * them using tagged arguments. Tagged arguments can be used like named
- * arguments in higher-lever languages.
+ * arguments in higher-lever language.
  *
  * @par NUA Agent
  *
@@ -67,66 +66,54 @@
  * The agent-wide parameter can be later modified or obtained with
  * nua_set_params() and nua_get_params(), respectively.
  *
- * The #su_root_t mainloop integration uses:
+ * The #su_root_t mainloop integration uses
  * - su_root_create(), su_root_threading(),
- *   su_root_step(), su_root_run(), su_root_break()
+ *   su_root_poll(), su_root_run(), su_root_break()
  *
  * @par NUA Handles
- *
  * - nua_handle(), nua_get_hparams(), nua_set_hparams()
  * - nua_handle_home(), nua_handle_has_invite(), nua_handle_has_subscribe(),
  *   nua_handle_has_register(), nua_handle_has_active_call(),
  *   nua_handle_has_call_on_hold(), nua_handle_has_events(),
  *   nua_handle_has_registrations(), nua_handle_remote(), and
- *   nua_handle_local()
- *
- * Settings:
- * - See nua_set_hparams()
- *
- * There are a few "sticky" headers that are used
- *   on subsequent requests if included with any handle-specific call:
+ *   nua_handle_local().
+ * - Settings:
+ *   See nua_set_hparams(). There are a few "sticky" headers that are used
+ *   on subsequent requests if given on any handle-specific call:
  *   - @Contact, @UserAgent, @Supported, @Allow, @Organization
  *
  * @par Client Generating SIP Requests
- *
  * - nua_register(), nua_unregister(), nua_invite(), nua_cancel(),
  *   nua_ack(), nua_bye(), nua_options(), nua_refer(), nua_publish(),
  *   nua_unpublish(), nua_prack(), nua_info(), nua_update(), nua_message(),
  *   nua_subscribe(), nua_unsubscribe(), nua_notify(), nua_method()
  * - NUTAG_URL()
- *
  *  Settings:
  * - NUTAG_RETRY_COUNT(), NUTAG_PROXY(),
  *   NUTAG_INITIAL_ROUTE() and NUTAG_INITIAL_ROUTE_STR()
- * - NUTAG_ALLOW(), SIPTAG_ALLOW() and SIPTAG_ALLOW_STR()
+ * - NUTAG_ALLOW(), SIPTAG_ALLOW(), and SIPTAG_ALLOW_STR()
  * - NUTAG_SUPPORTED(), SIPTAG_SUPPORTED(), and SIPTAG_SUPPORTED_STR()
  * - NUTAG_USER_AGENT(), SIPTAG_USER_AGENT() and SIPTAG_USER_AGENT_STR()
  * - SIPTAG_ORGANIZATION() and SIPTAG_ORGANIZATION_STR()
- * - NUTAG_AUTO302(), NUTAG_AUTO305()
  *
  * @par Client Authenticating Requests
- *
  * - nua_authenticate(), #nua_r_authenticate
  * - NUTAG_AUTH(), NUTAG_AUTH_CACHE()
  *
  * @par Server Processing Received SIP Requests
- *
  * - nua_respond(), NUTAG_WITH_THIS(), NUTAG_WITH_SAVED(), NUTAG_WITH()
  * - #nua_i_invite, #nua_i_cancel, #nua_i_ack, #nua_i_bye,
  *   #nua_i_options, #nua_i_refer, #nua_i_publish, #nua_i_prack,
  *   #nua_i_info, #nua_i_update, #nua_i_message, #nua_i_subscribe,
  *   #nua_i_notify, #nua_i_method, #nua_i_register
- *
  *  Settings:
  * - NUTAG_APPL_METHOD(), NUTAG_PROXY()
  * - NUTAG_ALLOW(), SIPTAG_ALLOW(), and SIPTAG_ALLOW_STR()
  * - NUTAG_SUPPORTED(), SIPTAG_SUPPORTED(), and SIPTAG_SUPPORTED_STR()
  *
  * @par Registrations and Contact Header Generation
- *
  * - nua_register(), #nua_r_register(), #nua_i_outbound,
  *   nua_unregister(), and #nua_r_unregister
- *
  * Settings:
  * - NUTAG_CALLEE_CAPS()
  * - NUTAG_DETECT_NETWORK_UPDATES()
@@ -139,14 +126,13 @@
  * - NUTAG_M_USERNAME()
  * - NUTAG_OUTBOUND()
  * - NUTAG_PATH_ENABLE()
+ * - NUTAG_RETRY_AFTER_ENABLE()
  * - NUTAG_SERVICE_ROUTE_ENABLE()
- *
  * Specifications:
  * - @RFC3261 section 10, @RFC3327, @RFC3608, @RFC3680, @RFC3840,
  *   draft-ietf-sip-outbound, draft-ietf-sip-gruu-14
  *
  * @par INVITE Sessions and Call Model
- *
  * - nua_invite(), #nua_r_invite, #nua_i_invite
  * - nua_handle_has_active_call(), nua_handle_has_call_on_hold(),
  *   nua_handle_has_invite()
@@ -157,90 +143,70 @@
  *   NUTAG_OFFER_SENT(), NUTAG_OFFER_RECV(), NUTAG_ANSWER_RECV(), and
  *   NUTAG_ANSWER_SENT(), SOATAG_REMOTE_SDP(), SOATAG_REMOTE_SDP_STR(),
  *   SOATAG_LOCAL_SDP(), SOATAG_LOCAL_SDP_STR()
- *
  *  Settings:
  * - NUTAG_AUTOACK(), NUTAG_AUTOALERT(), NUTAG_AUTOANSWER(),
  *   NUTAG_ENABLEINVITE(), NUTAG_INVITE_TIMER(), NUTAG_MEDIA_ENABLE(),
  *   SOATAG_USER_SDP(), SOATAG_USER_SDP_STR(), SOATAG_CAPS_SDP(),
  *   SOATAG_CAPS_SDP_STR()
- *
  * Specifications:
  * - @RFC3261, @RFC3264
  *
  * @par In-Session Information requests
- *
  * - nua_info() #nua_r_info, #nua_i_info
- *
  * Settings:
- * - @ref NUTAG_ALLOW("INFO"), @ref NUTAG_APPL_METHOD("INFO")
+ * - NUTAG_ALLOW("INFO"), NUTAG_APPL_METHOD("INFO")
  *
  * @par SDP Processing
- *
  * - #nua_i_state, SOATAG_ACTIVE_AUDIO(), SOATAG_ACTIVE_VIDEO(),
  *   SOATAG_ACTIVE_IMAGE(), SOATAG_ACTIVE_CHAT(),
  *   SOATAG_REMOTE_SDP(), SOATAG_REMOTE_SDP_STR(),
  *   SOATAG_LOCAL_SDP(), SOATAG_LOCAL_SDP_STR()
- *
  * Settings:
  * - NUTAG_MEDIA_ENABLE(), NUTAG_SOA_NAME(), NUTAG_EARLY_ANSWER(),
  *   SOATAG_USER_SDP(), SOATAG_USER_SDP_STR(), SOATAG_CAPS_SDP(),
  *   SOATAG_CAPS_SDP_STR()
- *
  * Specifications:
  * - @RFC3264
  *
  * @par Call Model Extensions ("100rel" and "precondition")
- *
- * Early media:
+ * Early
  * - nua_prack(), #nua_r_prack, #nua_i_prack
  * - nua_update() #nua_r_update, #nua_i_update
- *
  * Settings:
  * - NUTAG_EARLY_MEDIA(), NUTAG_ONLY183_100REL()
- * - "100rel" or "precondition" in NUTAG_SUPPORTED() or SIPTAG_SUPPORTED()
- *
+ * - "100rel" or "precondition" in NUTAG_SUPPORTED()/SIPTAG_SUPPORTED()
  * Specifications:
  * - @RFC3262, @RFC3311, @RFC3312
  *
  * @par SIP Session Timers ("timer")
- *
  * Periodic refresh of SIP Session initiated with INVITE with re-INVITE or
  * UPDATE requests.
- *
  * Settings:
  * - NUTAG_MIN_SE(), NUTAG_SESSION_REFRESHER(),
  *   NUTAG_SESSION_TIMER(), NUTAG_UPDATE_REFRESH(),
  *   NUTAG_REFRESH_WITHOUT_SDP(),
- * - "timer" in NUTAG_SUPPORTED() or SIPTAG_SUPPORTED()
- *
+ * - "timer" in NUTAG_SUPPORTED()/SIPTAG_SUPPORTED()
  * Specifications:
  * - @RFC4028
  *
  * @par Caller Preferences and Callee Caps
- *
- * - Caller preferences in an @AcceptContact header in a INVITE requests
- * - Callee caps contained in a @Contact header in a REGISTER request
- *
+ * - Caller preferences in @AcceptContact header in a INVITE requests
+ * - Callee caps contained in @Contact header in a REGISTER request
  * Settings:
  * - NUTAG_CALLEE_CAPS(), NUTAG_MEDIA_FEATURES(),
  *   NUTAG_M_FEATURES()
- *
  * Specifications:
  * - @RFC3840, @RFC3841
  *
  * @par Instant Messaging
- *
  * - nua_message(), #nua_r_message, #nua_i_message
- *
  * Settings:
- * - @ref NUTAG_APPL_METHOD("MESSAGE"),
+ * - NUTAG_APPL_METHOD("MESSAGE"),
  *   NUTAG_ENABLEMESSAGE(), NUTAG_ENABLEMESSENGER()
- *
  * Specifications:
  * - @RFC3428
  *
  * @par Call Transfer
- *
  * - nua_refer(), #nua_r_refer, #nua_i_notify, SIPTAG_EVENT(),
  *   @ReferTo, SIPTAG_REFER_TO(), @ReferredBy, SIPTAG_REFERRED_BY(),
  *   nua_handle_make_replaces(), @Replaces, SIPTAG_REPLACES(),
@@ -248,83 +214,63 @@
  * - #nua_i_refer, nua_notify(), #nua_r_notify,
  *   nua_handle_by_replaces()
  * - nua_invite() with NUTAG_NOTIFY_REFER() and NUTAG_REFER_EVENT()
- *
  * Settings:
  * - NUTAG_REFER_EXPIRES(), NUTAG_REFER_WITH_ID()
- *
  * Specifications:
  * - @RFC3515 (@ReferTo), @RFC3892 (@ReferredBy), @RFC3891 (@Replaces),
- *   @RFC4488 (@ReferSub)
+ *   @RFC4488, @ReferSub
  *
  * @par Internal SIP Event Server
- *
  * - nua_notifier(), #nua_r_notifier, #nua_i_subscription,
  *   nua_authorize(), #nua_r_authorize, nua_terminate(), #nua_r_terminate
  * - SIPTAG_EVENT(), SIPTAG_CONTENT_TYPE(), SIPTAG_PAYLOAD(),
  *   NUTAG_SUBSTATE()
- *
  * @par Settings
- *
  * - NUTAG_ALLOW_EVENTS(), SIPTAG_ALLOW_EVENTS(), and
  *                          SIPTAG_ALLOW_EVENTS_STR()
  * - NUTAG_MAX_SUBSCRIPTIONS()
  * - NUTAG_SUBSTATE(), NUTAG_SUB_EXPIRES()
- *
- * Specifications:
+ * @par Specifications
  * - @RFC3265
  *
  * @par SIP Event Subscriber
- *
  * - nua_subscribe(), #nua_r_subscribe, #nua_i_notify, NUTAG_SUBSTATE(),
  *   SIPTAG_EVENT(), SIPTAG_EXPIRES()
  * - nua_unsubscribe(), #nua_r_unsubscribe()
- *
- * Specifications:
+ * @par Specifications
  * - @RFC3265
  *
  * @par SIP Event Notifier
- *
  * - #nua_i_subscribe(), nua_notify(), #nua_r_notify,
  *   NUTAG_SUBSTATE(), NUTAG_SUB_EXPIRES(), SIPTAG_EVENT()
- *
  * Settings:
  * - NUTAG_SUB_EXPIRES()
  * - NUTAG_ALLOW_EVENTS(), SIPTAG_ALLOW_EVENTS(), and
  *                          SIPTAG_ALLOW_EVENTS_STR()
- * - @ref NUTAG_ALLOW("SUBSCRIBE"),
- *   @ref NUTAG_APPL_METHOD("SUBSCRIBE")
- *
- * Specifications
+ * - NUTAG_ALLOW("SUBSCRIBE"), NUTAG_APPL_METHOD("SUBSCRIBE")
+ * @par Specifications
  * - @RFC3265
  *
  * @par SIP Event Publisher
- *
  * - nua_publish(), #nua_r_publish(), nua_unpublish(), nua_r_unpublish()
  * - @SIPETag, SIPTAG_ETAG(), @SIPIfMatch, SIPTAG_IF_MATCH()
- *
- * Specifications:
+ * @par Specifications
  * - @RFC3903
  *
  * @par SIP Event State Compositor (PUBLISH Server)
- *
  * - #nua_i_publish, @SIPETag, @SIPIfMatch
- *
- * Settings:
- * - @ref NUTAG_ALLOW("PUBLISH"), @ref NUTAG_APPL_METHOD("PUBLISH")
- *
- * Specifications:
+ * @par Settings
+ * - NUTAG_ALLOW("PUBLISH"), NUTAG_APPL_METHOD("PUBLISH")
+ * @par Specifications
  * - @RFC3903
  *
  * @par Non-Standard Extension Methods
- *
  * - nua_method(), NUTAG_METHOD(), #nua_r_method, NUTAG_DIALOG()
  * - #nua_i_method, nua_respond()
- *
  * Settings:
  * - NUTAG_ALLOW(x), NUTAG_APPL_METHOD(x)
  *
  * @par Server Shutdown
- *
  * - nua_shutdown(), NUTAG_SHUTDOWN_EVENTS(), nua_destroy().
  */
 
@@ -1384,6 +1330,8 @@
  */
 tag_typedef_t nutag_autoack = BOOLTAG_TYPEDEF(autoACK);
 
+tag_typedef_t nutag_timer_autorequire = BOOLTAG_TYPEDEF(timerAutorequire);
+
 /**@def NUTAG_AUTOACK_REF(x)
  * Reference tag for NUTAG_AUTOACK().
  */
@@ -1467,78 +1415,6 @@
  * Reference tag for NUTAG_ENABLEMESSENGER().
  */
 
-/**@def NUTAG_AUTO302(x)
- *
- * Recurse automatically on 302 response.
- *
- * If this parameter is true, a client recurses automatically upon receiving
- * a 302 response. The request is resent with the request-URI from the
- * @Contact header in the 302 response.
- *
- * @par Used with
- *    nua_create(), nua_set_params(), nua_set_hparams(), \n
- *    nua_get_params(), nua_get_hparams(), \n
- *    nua_invite(), nua_prack(), nua_ack(), nua_update(), nua_respond(), \n
- *    nua_info(), nua_cancel(), nua_bye(), \n
- *    nua_register(), nua_unregister(), nua_publish(), nua_unpublish(), \n
- *    nua_subscribe(), nua_unsubscribe(), nua_refer(), nua_notify(), \n
- *    nua_options(), nua_message(), nua_method()
- *
- * @par Parameter type
- *    int (boolean: nonzero is true, zero is false)
- *
- * @par Values
- *    - 0 (false) - process 302 as an ordinary final response
- *    - 1 (true) - resend request with URI received in 302 response
- *
- * Default value is NUTAG_AUTO302(1).
- *
- * Corresponding tag taking reference parameter is NUTAG_AUTO302_REF().
- */
-tag_typedef_t nutag_auto302 = BOOLTAG_TYPEDEF(auto302);
-
-/**@def NUTAG_AUTO302_REF(x)
- * Reference tag for NUTAG_AUTO302().
- */
-
-/**@def NUTAG_AUTO305(x)
- *
- * Recurse automatically on 305 response.
- *
- * If this parameter is true, a client recurses automatically upon receiving
- * a 305 response. The request is resent via the proxy specified by the
- * @Contact header in the 305 response. The proxy URI is included in the
- * @Route header of the request.
- *
- * Note that the NUTAG_PROXY() takes a precedence over the proxy in 305, and
- * the NUTAG_PROXY() is responsible of actually routing the request through
- * the 305 proxy.
- *
- * @par Used with
- *    nua_create(), nua_set_params(), nua_set_hparams(), \n
- *    nua_get_params(), nua_get_hparams(), \n
- *    nua_invite(), nua_prack(), nua_ack(), nua_update(), nua_respond(), \n
- *    nua_info(), nua_cancel(), nua_bye(), \n
- *    nua_register(), nua_unregister(), nua_publish(), nua_unpublish(), \n
- *    nua_subscribe(), nua_unsubscribe(), nua_refer(), nua_notify(), \n
- *    nua_options(), nua_message(), nua_method()
- *
- * @par Parameter type
- *    int (boolean: nonzero is true, zero is false)
- *
- * @par Values
- *    - 0 (false) - process 305 as an ordinary final response
- *    - 1 (true) - resend request via proxy received in 305 response
- *
- * Default value is NUTAG_AUTO305(1).
- *
- * Corresponding tag taking reference parameter is NUTAG_AUTO305_REF().
- */
-tag_typedef_t nutag_auto305 = BOOLTAG_TYPEDEF(auto305);
-
-/**@def NUTAG_AUTO305_REF(x)
- * Reference tag for NUTAG_AUTO305().
- */
 
 /**@def NUTAG_SMIME_ENABLE(x)
  *
@@ -1745,6 +1621,55 @@
  * Reference tag for NUTAG_SIPS_URL().
  */
 
+/**@def NUTAG_WS_URL(x)
+ *
+ * Local WS url.
+ *
+ * The application can specify an alternative local address for
+ * NUA user agent engine. Usually the alternative address is a
+ *  SIP URI (WS) used with websocket transport.
+ *
+ * @par Used with
+ *    nua_create()
+ *
+ * @par Parameter type
+ *    char const *
+ *
+ * @par Values
+ *
+ * Corresponding tag taking reference parameter is NUTAG_WS_URL_REF().
+ */
+tag_typedef_t nutag_ws_url = URLTAG_TYPEDEF(ws_url);
+
+/**@def NUTAG_WS_URL_REF(x)
+ * Reference tag for NUTAG_WS_URL().
+ */
+
+
+/**@def NUTAG_WSS_URL(x)
+ *
+ * Local WSS url.
+ *
+ * The application can specify an alternative local address for
+ * NUA user agent engine. Usually the alternative address is a
+ * secure SIP URI (WSS) used with secure websocket transport.
+ *
+ * @par Used with
+ *    nua_create()
+ *
+ * @par Parameter type
+ *    char const *
+ *
+ * @par Values
+ *
+ * Corresponding tag taking reference parameter is NUTAG_WSS_URL_REF().
+ */
+tag_typedef_t nutag_wss_url = URLTAG_TYPEDEF(wss_url);
+
+/**@def NUTAG_WSS_URL_REF(x)
+ * Reference tag for NUTAG_WSS_URL().
+ */
+
 
 /**@def NUTAG_CERTIFICATE_DIR(x)
  *
@@ -2109,8 +2034,8 @@
  * keepalive, use NUTAG_OUTBOUND("natify no-options-keepalive").
  *
  * An empty string can be passed to let the stack choose the
- * default values for outbound usage (in the 1.12.10 release, the
- * defaults are: "gruuize no-outbound validate use-rport options-keepalive").
+ * default values for outbound usage (in the 1.12.5 release, the
+ * defaults are: "gruuize no-outbound validate use-port options-keepalive").
  *
  * @note
  * Options string is used so that no new tags need to be added when the
@@ -2366,6 +2291,8 @@
  *    - 0 (zero) - Use authentication data only for this handle
  *    - nonzero - Lifetime of authentication data in seconds
  *
+ * @todo
+ *
  * Corresponding tag taking reference parameter is NUTAG_AUTHTIME_REF().
  */
 tag_typedef_t nutag_authtime = INTTAG_TYPEDEF(authtime);
@@ -2583,6 +2510,31 @@
  */
 
 
+/**@def NUTAG_VIA()
+ *
+ * Via string.
+ *
+ * Indicate the Via header used by the stack.
+ *
+ * @par Used with
+ *    nua_set_params(), nua_set_hparams() \n
+ *    nua_get_params(), nua_get_hparams(), #nua_r_get_params \n
+ *    any handle-specific nua call
+ *
+ * @par Parameter type
+ *    char const *
+ *
+ * @par Values
+ *    See @RFC3261 \n
+ *
+ * Corresponding tag taking reference parameter is NUTAG_VIA_REF().
+ */
+tag_typedef_t nutag_via = STRTAG_TYPEDEF(via);
+
+/**@def NUTAG_VIA_REF(x)
+ * Reference tag for NUTAG_VIA().
+ */
+
 /**@def NUTAG_ALLOW()
  *
  * Allow a method (or methods).
@@ -2761,6 +2713,29 @@
  * Reference tag for NUTAG_PATH_ENABLE().
  */
 
+/**@def NUTAG_RETRY_AFTER_ENABLE(x)
+ *
+ * If true, support RFC 3261 Retry-After
+ *
+ * @par Used with
+ * - nua_create(), nua_set_params(), nua_get_params()
+ * - nua_handle(), nua_set_hparams(), nua_get_hparams()
+ * - nua_register()
+ *
+ * @par Parameter type
+ *    int (boolean: nonzero is true, zero is false)
+ *
+ * @par Values
+ *    - 0 (false) - Do not honor Retry-After
+ *    - 1 (true) - honor Retry-After
+ *
+ */
+tag_typedef_t nutag_retry_after_enable = BOOLTAG_TYPEDEF(retry_after_enable);
+
+/**@def NUTAG_RETRY_AFTER_ENABLE_REF(x)
+ * Reference tag for NUTAG_RETRY_AFTER_ENABLE().
+ */
+
 
 
 /**@def NUTAG_SERVICE_ROUTE_ENABLE(x)
@@ -2783,6 +2758,8 @@
  * Corresponding tag taking reference parameter is NUTAG_SERVICE_ROUTE_ENABLE_REF().
  *
  * @sa NUTAG_INITIAL_ROUTE(), NUTAG_INITIAL_ROUTE_STR(), @RFC3608
+ *
+ * @todo
  */
 tag_typedef_t nutag_service_route_enable =
   BOOLTAG_TYPEDEF(service_route_enable);
@@ -2962,7 +2939,7 @@
 
 /**@def NUTAG_SIP_PARSER(x)
  *
- * Pointer to a customized SIP parser used with NUA.
+ * Pointer to SIP parser structure
  *
  * @par Used with
  *    nua_create()
diff -ur a/libsofia-sip-ua/nua/outbound.c b/libsofia-sip-ua/nua/outbound.c
--- a/libsofia-sip-ua/nua/outbound.c	2011-03-11 16:49:18.000000000 +0200
+++ b/libsofia-sip-ua/nua/outbound.c	2017-12-07 23:25:59.820839817 +0200
@@ -400,24 +400,9 @@
 
   if (status < 300) {
     if (request->sip_contact && response->sip_contact) {
-      sip_contact_t *m;
-
-      if (ob->ob_rcontact != NULL) {
+      if (ob->ob_rcontact != NULL)
         msg_header_free(ob->ob_home, (msg_header_t *)ob->ob_rcontact);
-        ob->ob_rcontact = NULL;
-      }
-
-      /* Ignore the contacts that were unregistered, if any */
-      for (m = request->sip_contact; m; m = m->m_next) {
-        if (!m->m_expires || strtoul(m->m_expires, NULL, 10) != 0)
-          break;
-      }
-      assert (!ob->ob_registering || m != NULL);
-
-      if (m)
-        ob->ob_rcontact = (sip_contact_t *)
-	  msg_header_dup_one(ob->ob_home, (const msg_header_t *)m);
-
+      ob->ob_rcontact = sip_contact_dup(ob->ob_home, request->sip_contact);
       ob->ob_registered = ob->ob_registering;
     } else
       ob->ob_registered = 0;
@@ -1235,9 +1220,6 @@
     }
   }
 
-  if (previous)
-    msg_header_replace_param(home, (msg_common_t *)previous, "expires=0");
-
   ob->ob_by_stack = application_contact == NULL;
 
   ob->ob_contacts = rcontact != NULL;
diff -ur a/libsofia-sip-ua/nua/sofia-sip/nua_tag.h b/libsofia-sip-ua/nua/sofia-sip/nua_tag.h
--- a/libsofia-sip-ua/nua/sofia-sip/nua_tag.h	2011-03-11 16:49:18.000000000 +0200
+++ b/libsofia-sip-ua/nua/sofia-sip/nua_tag.h	2017-12-07 23:26:01.156847064 +0200
@@ -199,6 +199,11 @@
 #define NUTAG_AUTOACK_REF(x)    nutag_autoack_ref, tag_bool_vr(&(x))
 SOFIAPUBVAR tag_typedef_t nutag_autoack_ref;
 
+#define NUTAG_TIMER_AUTOREQUIRE(x)        nutag_timer_autorequire, tag_bool_v(x)
+SOFIAPUBVAR tag_typedef_t nutag_timer_autorequire;
+#define NUTAG_TIMER_AUTOREQUIRE_REF(x)    nutag_timer_autorequire_ref, tag_bool_vr(&(x))
+SOFIAPUBVAR tag_typedef_t nutag_timer_autorequire_ref;
+
 #define NUTAG_AUTOANSWER(x)     nutag_autoanswer, tag_bool_v(x)
 SOFIAPUBVAR tag_typedef_t nutag_autoanswer;
 #define NUTAG_AUTOANSWER_REF(x) nutag_autoanswer_ref, tag_bool_vr(&(x))
@@ -220,16 +225,6 @@
   nutag_enablemessenger_ref, tag_bool_vr(&(x))
 SOFIAPUBVAR tag_typedef_t nutag_enablemessenger_ref;
 
-#define NUTAG_AUTO302(x)        nutag_auto302, tag_bool_v(x)
-SOFIAPUBVAR tag_typedef_t nutag_auto302;
-#define NUTAG_AUTO302_REF(x)    nutag_auto302_ref, tag_bool_vr(&(x))
-SOFIAPUBVAR tag_typedef_t nutag_auto302_ref;
-
-#define NUTAG_AUTO305(x)        nutag_auto305, tag_bool_v(x)
-SOFIAPUBVAR tag_typedef_t nutag_auto305;
-#define NUTAG_AUTO305_REF(x)    nutag_auto305_ref, tag_bool_vr(&(x))
-SOFIAPUBVAR tag_typedef_t nutag_auto305_ref;
-
 /* Start NRC Boston */
 
 #define NUTAG_SMIME_ENABLE(x)  nutag_smime_enable, tag_bool_v(x)
@@ -291,6 +286,16 @@
 #define NUTAG_SIPS_URL_REF(x)   nutag_sips_url_ref, urltag_url_vr(&(x))
 SOFIAPUBVAR tag_typedef_t nutag_sips_url_ref;
 
+#define NUTAG_WS_URL(x)       nutag_ws_url, urltag_url_v(x)
+SOFIAPUBVAR tag_typedef_t nutag_ws_url;
+#define NUTAG_WS_URL_REF(x)   nutag_ws_url_ref, urltag_url_vr(&(x))
+SOFIAPUBVAR tag_typedef_t nutag_ws_url_ref;
+
+#define NUTAG_WSS_URL(x)       nutag_wss_url, urltag_url_v(x)
+SOFIAPUBVAR tag_typedef_t nutag_wss_url;
+#define NUTAG_WSS_URL_REF(x)   nutag_wss_url_ref, urltag_url_vr(&(x))
+SOFIAPUBVAR tag_typedef_t nutag_wss_url_ref;
+
 #define NUTAG_PROXY(x)          NTATAG_DEFAULT_PROXY(x)
 #define NUTAG_PROXY_REF(x)      NTATAG_DEFAULT_PROXY_REF(x)
 #define nutag_proxy             ntatag_default_proxy
@@ -447,6 +452,11 @@
 #define NUTAG_USER_AGENT_REF(x) nutag_user_agent_ref, tag_str_vr(&(x))
 SOFIAPUBVAR tag_typedef_t nutag_user_agent_ref;
 
+#define NUTAG_VIA(x)     nutag_via, tag_str_v(x)
+SOFIAPUBVAR tag_typedef_t nutag_via;
+#define NUTAG_VIA_REF(x) nutag_via_ref, tag_str_vr(&(x))
+SOFIAPUBVAR tag_typedef_t nutag_via_ref;
+
 #define NUTAG_ALLOW(x)     nutag_allow, tag_str_v(x)
 SOFIAPUBVAR tag_typedef_t nutag_allow;
 #define NUTAG_ALLOW_REF(x) nutag_allow_ref, tag_str_vr(&(x))
@@ -550,6 +560,11 @@
 #define NUTAG_PATH_ENABLE_REF(x) nutag_path_enable_ref, tag_bool_vr(&(x))
 SOFIAPUBVAR tag_typedef_t nutag_path_enable_ref;
 
+#define NUTAG_RETRY_AFTER_ENABLE(x)   nutag_retry_after_enable, tag_bool_v(x)
+SOFIAPUBVAR tag_typedef_t nutag_retry_after_enable;
+#define NUTAG_RETRY_AFTER_ENABLE_REF(x) nutag_retry_after_enable_ref, tag_bool_vr(&(x))
+SOFIAPUBVAR tag_typedef_t nutag_retry_after_enable_ref;
+
 #define NUTAG_SERVICE_ROUTE_ENABLE(x) nutag_service_route_enable, tag_bool_v(x)
 SOFIAPUBVAR tag_typedef_t nutag_service_route_enable;
 #define NUTAG_SERVICE_ROUTE_ENABLE_REF(x) \
diff -ur a/libsofia-sip-ua/sdp/sdp.c b/libsofia-sip-ua/sdp/sdp.c
--- a/libsofia-sip-ua/sdp/sdp.c	2011-03-11 16:49:18.000000000 +0200
+++ b/libsofia-sip-ua/sdp/sdp.c	2017-12-07 23:25:59.852839991 +0200
@@ -63,7 +63,7 @@
 
 
 #define STRUCT_DUP(p, dst, src) \
-  ASSERT_STRUCT_ALIGN(p); assert(*(int*)(src) >= (int)sizeof(*src));	\
+  ASSERT_STRUCT_ALIGN(p); \
   ((*(int*)(src) >= (int)sizeof(*src)					\
     ? (dst = memcpy((p), (src), sizeof(*src)))				\
     : (dst = memcpy((p), (src), *(int*)(src))),				\
@@ -1831,7 +1831,7 @@
 {
   return m &&
     (m->m_proto == sdp_proto_rtp ||
-     m->m_proto == sdp_proto_srtp ||
+     m->m_proto == sdp_proto_srtp || m->m_proto == sdp_proto_extended_srtp ||
      (m->m_proto == sdp_proto_x && m->m_proto_name &&
       su_casenmatch(m->m_proto_name, "RTP/", 4)));
 }
@@ -1866,23 +1866,20 @@
   return 1;
 }
 
-/** Search for matching a rtpmap entry from list.
+/** Search for matching rtpmap from list.
  *
  * @note
  * The a=fmtp: for the codecs are not compared.
- *
- * @return
- * Pointer to first sdp_rtpmap_t entry on the @a list matching with any
- * sdp_rtpmap_t entry on @a rm.
  */
 sdp_rtpmap_t *sdp_rtpmap_find_matching(sdp_rtpmap_t const *list,
 				       sdp_rtpmap_t const *rm)
 {
   char const *lparam, *rparam;
+  sdp_rtpmap_t const *cp_list = NULL;
 
   if (rm == NULL)
     return NULL;
-
+    
   for (; list; list = list->rm_next) {
     if (rm->rm_rate != list->rm_rate)
       continue;
@@ -1892,8 +1889,11 @@
 
     lparam = rm->rm_params; rparam = list->rm_params;
 
-    if (lparam == rparam)
-      break;
+    if (lparam == rparam) {
+          cp_list = list;
+          if (rm->rm_pt != list->rm_pt) continue;
+          break;
+    }
 
     if (!lparam) lparam = "1"; if (!rparam) rparam = "1";
     if (!su_casematch(lparam, rparam))
@@ -1902,5 +1902,5 @@
     break;
   }
 
-  return (sdp_rtpmap_t *)list;
+  return cp_list ? (sdp_rtpmap_t *) cp_list : (sdp_rtpmap_t *)list;
 }
diff -ur a/libsofia-sip-ua/sdp/sdp_parse.c b/libsofia-sip-ua/sdp/sdp_parse.c
--- a/libsofia-sip-ua/sdp/sdp_parse.c	2011-03-11 16:49:18.000000000 +0200
+++ b/libsofia-sip-ua/sdp/sdp_parse.c	2017-12-07 23:25:59.864840056 +0200
@@ -91,6 +91,9 @@
 #define pr_error   pr_output.pru_error
 #define pr_session pr_output.pru_session
 
+#ifdef _MSC_VER
+#undef STRICT
+#endif
 #define STRICT(pr) (pr->pr_strict)
 
 /* Static parser object used when running out of memory */
@@ -480,7 +483,7 @@
 
   post_session(p, sdp);
 }
-
+#ifdef SOFIA_AUTO_CORRECT_INADDR_ANY
 int sdp_connection_is_inaddr_any(sdp_connection_t const *c)
 {
   return
@@ -489,6 +492,7 @@
     ((c->c_addrtype == sdp_addr_ip4 && su_strmatch(c->c_address, "0.0.0.0")) ||
      (c->c_addrtype == sdp_addr_ip6 && su_strmatch(c->c_address, "::")));
 }
+#endif
 
 /**Postprocess session description.
  *
@@ -498,7 +502,9 @@
 static void post_session(sdp_parser_t *p, sdp_session_t *sdp)
 {
   sdp_media_t *m;
+#ifdef SOFIA_AUTO_CORRECT_INADDR_ANY
   sdp_connection_t const *c;
+#endif
 
   if (!p->pr_ok)
     return;
@@ -522,12 +528,15 @@
       continue;
     }
 
+#ifdef SOFIA_AUTO_CORRECT_INADDR_ANY
     c = sdp_media_connections(m);
 
+
     if (p->pr_mode_0000 && sdp_connection_is_inaddr_any(c)) {
       /* Reset recvonly flag */
       m->m_mode &= ~sdp_recvonly;
     }
+#endif
   }
 
   if (p->pr_insane)
@@ -912,11 +921,13 @@
   }
 
   if (su_casematch(name, "CT"))
-    modifier = sdp_bw_ct, name = NULL;
-  else if (su_casematch(name, "AS") == 0)
-    modifier = sdp_bw_as, name = NULL;
+    modifier = sdp_bw_ct, name = "CT";
+  else if (su_casematch(name, "TIAS") == 1)
+    modifier = sdp_bw_tias, name = "TIAS";
+  else if (su_casematch(name, "AS") == 1)
+    modifier = sdp_bw_as, name = "AS";
   else
-    modifier = sdp_bw_x;
+	modifier = sdp_bw_x, name = "BW-X";
 
   if (STRICT(p))
     PARSE_CHECK_REST(p, r, "b");
@@ -1329,8 +1340,8 @@
 
   /* RTP format list */
   if (*r && sdp_media_has_rtp(m)) {
-    parse_payload(p, r, &m->m_rtpmaps);
-    return;
+	  parse_payload(p, r, &m->m_rtpmaps);
+	  return;
   }
 
   /* "normal" format list */
@@ -1373,7 +1384,7 @@
 
 /** Set transport protocol.
  *
- * Set the @a m->m_proto to a well-known protocol type as
+ * Set the @m->m_proto to a well-known protocol type as
  * well as canonize case of @a m_proto_name.
  */
 void sdp_media_transport(sdp_media_t *m, char const *s)
@@ -1386,9 +1397,23 @@
     m->m_proto = sdp_proto_rtp, m->m_proto_name = "RTP/AVP";
   else if (su_casematch(s, "RTP/SAVP"))
     m->m_proto = sdp_proto_srtp, m->m_proto_name = "RTP/SAVP";
+  else if (su_casematch(s, "UDP/TLS/RTP/SAVP"))
+    m->m_proto = sdp_proto_srtp, m->m_proto_name = "RTP/SAVP";
+  else if (su_casematch(s, "RTP/SAVPF"))
+	  m->m_proto = sdp_proto_extended_srtp, m->m_proto_name = "RTP/SAVPF";
+  else if (su_casematch(s, "UDP/TLS/RTP/SAVPF"))
+    m->m_proto = sdp_proto_extended_srtp, m->m_proto_name = "UDP/TLS/RTP/SAVPF";
+  else if (su_casematch(s, "RTP/AVPF"))
+	  m->m_proto = sdp_proto_extended_rtp, m->m_proto_name = "RTP/AVPF";
+  else if (su_casematch(s, "UDP/RTP/AVPF"))
+    m->m_proto = sdp_proto_extended_rtp, m->m_proto_name = "UDP/RTP/AVPF";
   else if (su_casematch(s, "udptl"))
     /* Lower case - be compatible with people living by T.38 examples */
     m->m_proto = sdp_proto_udptl, m->m_proto_name = "udptl";
+  else if (su_casematch(s, "TCP/MSRP"))
+    m->m_proto = sdp_proto_msrp, m->m_proto_name = "TCP/MSRP";
+  else if (su_casematch(s, "TCP/TLS/MSRP"))
+    m->m_proto = sdp_proto_msrps, m->m_proto_name = "TCP/TLS/MSRP";
   else if (su_casematch(s, "UDP"))
     m->m_proto = sdp_proto_udp, m->m_proto_name = "UDP";
   else if (su_casematch(s, "TCP"))
@@ -1402,7 +1427,7 @@
 /** Check if media uses RTP as its transport protocol.  */
 int sdp_media_has_rtp(sdp_media_t const *m)
 {
-  return m && (m->m_proto == sdp_proto_rtp || m->m_proto == sdp_proto_srtp);
+	return m && (m->m_proto == sdp_proto_rtp || m->m_proto == sdp_proto_srtp || m->m_proto == sdp_proto_extended_srtp || m->m_proto == sdp_proto_extended_rtp);
 }
 
 #define RTPMAP(pt, encoding, rate, params) \
@@ -1578,7 +1603,7 @@
 
   if (p->pr_mode_manual)
     ;
-  else if (su_casematch(name, "inactive")) {
+  else if (m->m_port == 0 || su_casematch(name, "inactive")) {
     m->m_mode = sdp_inactive;
     return;
   }
@@ -1596,8 +1621,8 @@
   }
 
   if (rtp && su_casematch(name, "rtpmap")) {
-    if ((n = parse_rtpmap(p, r, m)) == 0 || n < -1)
-      return;
+	  if ((n = parse_rtpmap(p, r, m)) == 0 || n < -1)
+		  return;
   }
   else if (rtp && su_casematch(name, "fmtp")) {
     if ((n = parse_fmtp(p, r, m)) == 0 || n < -1)
@@ -1797,7 +1822,9 @@
 }
 
 #if !HAVE_STRTOULL
-unsigned longlong strtoull(char const *string, char **return_end, int base);
+#if !((defined(WIN32) || defined(_WIN32)) && (_MSC_VER >= 1800))
+unsigned long long strtoull(char const *string, char **return_end, int base);
+#endif
 #endif
 
 /*
@@ -1806,7 +1833,7 @@
 static int parse_ull(sdp_parser_t *p, char **r,
 		     uint64_t *result, uint64_t max)
 {
-  unsigned longlong ull;
+  unsigned long long ull;
 
   char *s = *r;
 
@@ -1883,12 +1910,11 @@
 
 static int parsing_error(sdp_parser_t *p, char const *fmt, ...)
 {
-  int n;
   va_list ap;
   va_start(ap, fmt);
 
   memset(p->pr_error, 0, sizeof(p->pr_error));
-  n = vsnprintf(p->pr_error, sizeof(p->pr_error), fmt, ap);
+  vsnprintf(p->pr_error, sizeof(p->pr_error), fmt, ap);
   va_end(ap);
 
   p->pr_ok = 0;
diff -ur a/libsofia-sip-ua/sdp/sdp_print.c b/libsofia-sip-ua/sdp/sdp_print.c
--- a/libsofia-sip-ua/sdp/sdp_print.c	2011-03-11 16:49:18.000000000 +0200
+++ b/libsofia-sip-ua/sdp/sdp_print.c	2017-12-07 23:25:59.872840100 +0200
@@ -270,7 +270,7 @@
 {
   p->pr_ok = 1;
 
-  if (p->pr_ok && sdp->sdp_version)
+  if (p->pr_ok)
     print_version(p, sdp->sdp_version);
   if (p->pr_ok && sdp->sdp_origin)
     print_origin(p, sdp->sdp_origin);
@@ -430,6 +430,7 @@
     switch (b->b_modifier) {
     case sdp_bw_ct: name = "CT"; break;
     case sdp_bw_as: name = "AS"; break;
+    case sdp_bw_tias: name = "TIAS"; break;
     default:        name = b->b_modifier_name; break;
     }
 
@@ -590,7 +591,10 @@
     case sdp_proto_udp:   proto = "udp"; break;
     case sdp_proto_rtp:   proto = "RTP/AVP"; break;
     case sdp_proto_srtp:  proto = "RTP/SAVP"; break;
+		//case sdp_proto_extended_srtp:  proto = "RTP/SAVPF"; break;
     case sdp_proto_udptl: proto = "udptl"; break;
+    case sdp_proto_msrp:  proto = "TCP/MSRP"; break;
+    case sdp_proto_msrps:  proto = "TCP/TLS/MSRP"; break;
     case sdp_proto_tls:   proto = "tls"; break;
     default:              proto = m->m_proto_name; break;
     }
@@ -615,8 +619,10 @@
 	sdp_printf(p, " %s", l->l_text);
     }
     else {
-      sdp_printf(p, " 19");      /* SDP syntax requires at least one format.
-				    19 is used by nobody, right?. */
+		/* SDP syntax requires at least one format. */
+		/* defaults to "19", or "t38" for image */
+		if (m->m_type == sdp_media_image) sdp_printf(p, " t38");
+		else sdp_printf(p, " 19");
     }
 
 
@@ -635,14 +641,16 @@
       print_key(p, m->m_key);
 
     for (rm = m->m_rtpmaps; rm; rm = rm->rm_next) {
-      if (!rm->rm_predef || p->pr_all_rtpmaps)
-	sdp_printf(p, "a=rtpmap:%u %s/%lu%s%s" CRLF,
-		   rm->rm_pt, rm->rm_encoding, rm->rm_rate,
-		   rm->rm_params ? "/" : "",
-		   rm->rm_params ? rm->rm_params : "");
-      if (rm->rm_fmtp)
-	sdp_printf(p, "a=fmtp:%u %s" CRLF,
-		   rm->rm_pt, rm->rm_fmtp);
+		if (rm->rm_encoding && *rm->rm_encoding && (!rm->rm_predef || p->pr_all_rtpmaps)) {
+			sdp_printf(p, "a=rtpmap:%u %s/%lu%s%s" CRLF,
+					   rm->rm_pt, rm->rm_encoding, rm->rm_rate,
+					   rm->rm_params ? "/" : "",
+					   rm->rm_params ? rm->rm_params : "");
+		}
+		if (rm->rm_fmtp) {
+			sdp_printf(p, "a=fmtp:%u %s" CRLF,
+					   rm->rm_pt, rm->rm_fmtp);
+		}
     }
 
     if (!p->pr_mode_manual && !m->m_rejected &&
@@ -685,9 +693,8 @@
   va_list ap;
 
   if (p->pr_ok) {
-    int n;
     va_start(ap, fmt);
-    n = vsnprintf(p->pr_buffer, p->pr_bsiz, fmt, ap);
+    vsnprintf(p->pr_buffer, p->pr_bsiz, fmt, ap);
     va_end(ap);
   }
 
diff -ur a/libsofia-sip-ua/sdp/sofia-sip/sdp.h b/libsofia-sip-ua/sdp/sofia-sip/sdp.h
--- a/libsofia-sip-ua/sdp/sofia-sip/sdp.h	2011-03-11 16:49:18.000000000 +0200
+++ b/libsofia-sip-ua/sdp/sofia-sip/sdp.h	2017-12-07 23:26:01.168847129 +0200
@@ -143,6 +143,7 @@
   sdp_bw_x,				/**< Unknown bandwidth type */
   sdp_bw_ct,				/**< Conference total */
   sdp_bw_as,				/**< Application-specific */
+  sdp_bw_tias,				/**< Application-specific */
 } sdp_bandwidth_e;
 
 /** Session or media bandwidth. */
@@ -243,6 +244,10 @@
   sdp_proto_rtp = 256,			/**< RTP/AVP */
   sdp_proto_srtp = 257,			/**< RTP/SAVP  */
   sdp_proto_udptl = 258,		/**< UDPTL. @NEW_1_12_4. */
+  sdp_proto_msrp =  259,		/**< TCP/MSRP @NEW_MSRP*/
+  sdp_proto_msrps = 260,		/**< TCP/TLS/MSRP @NEW_MSRP*/
+  sdp_proto_extended_srtp = 261, /** WEBRTC SAVPF */
+  sdp_proto_extended_rtp = 262, /** WEBRTC AVPF */
   sdp_proto_tls = 511,			/**< TLS over TCP */
   sdp_proto_any = 512		        /**< * wildcard */
 } sdp_proto_e;
diff -ur a/libsofia-sip-ua/sip/sip_basic.c b/libsofia-sip-ua/sip/sip_basic.c
--- a/libsofia-sip-ua/sip/sip_basic.c	2011-03-11 16:49:18.000000000 +0200
+++ b/libsofia-sip-ua/sip/sip_basic.c	2017-12-07 23:25:59.944840491 +0200
@@ -1391,18 +1391,23 @@
 		       char *s,
 		       isize_t slen)
 {
-  sip_contact_t *m = (sip_contact_t *)h;
+  sip_contact_t *m;
 
   assert(h);
+  for(;;) {
 
-  while (*s == ',')   /* Ignore empty entries (comma-whitespace) */
-    *s = '\0', s += span_lws(s + 1) + 1;
+	  m = (sip_contact_t *)h;
 
-  if (sip_name_addr_d(home, &s, &m->m_display, m->m_url,
-		      &m->m_params, &m->m_comment) == -1)
-    return -1;
+	  while (*s == ',')   /* Ignore empty entries (comma-whitespace) */
+		  *s = '\0', s += span_lws(s + 1) + 1;
+	  
+	  if (sip_name_addr_d(home, &s, &m->m_display, m->m_url,
+						  &m->m_params, &m->m_comment) == -1)
+		  return -1;
+
+	  msg_parse_next_field_without_recursion();
+  }
 
-  return msg_parse_next_field(home, h, s, slen);
 }
 
 
@@ -2106,18 +2111,24 @@
 			 char *s,
 			 isize_t slen)
 {
-  sip_route_t *r = (sip_route_t *)h;
+	sip_route_t *r;
+
 
   assert(h);
+  for (;;) {
+	  r = (sip_route_t *)h;
 
-  while (*s == ',')   /* Ignore empty entries (comma-whitespace) */
-    *s = '\0', s += span_lws(s + 1) + 1;
+	  while (*s == ',')  { /* Ignore empty entries (comma-whitespace) */
+		  *s = '\0', s += span_lws(s + 1) + 1;
+	  }
+
+	  if (sip_name_addr_d(home, &s, &r->r_display, r->r_url, &r->r_params, NULL) < 0) {
+		  return -1;
+	  }
 
-  if (sip_name_addr_d(home, &s, &r->r_display,
-		      r->r_url, &r->r_params, NULL) < 0)
-    return -1;
+	  msg_parse_next_field_without_recursion();
+  }
 
-  return msg_parse_next_field(home, h, s, slen);
 }
 
 issize_t sip_any_route_e(char b[], isize_t bsiz, sip_header_t const *h, int flags)
@@ -2534,29 +2545,32 @@
 
 issize_t sip_via_d(su_home_t *home, sip_header_t *h, char *s, isize_t slen)
 {
-  sip_via_t *v = (sip_via_t *)h;
+  sip_via_t *v;
 
   assert(h);
+  for (;;) {
+	  v = (sip_via_t *)h;
 
-  while (*s == ',')   /* Ignore empty entries (comma-whitespace) */
-    *s = '\0', s += span_lws(s + 1) + 1;
+	  while (*s == ',')   /* Ignore empty entries (comma-whitespace) */
+		  *s = '\0', s += span_lws(s + 1) + 1;
 
-  /* sent-protocol sent-by *( ";" via-params ) [ comment ] */
+	  /* sent-protocol sent-by *( ";" via-params ) [ comment ] */
+	  
+	  /* Parse protocol */
+	  if (sip_transport_d(&s, &v->v_protocol) == -1)
+		  return -1;
+	  /* Host (and port) */
+	  if (msg_hostport_d(&s, &v->v_host, &v->v_port) == -1)
+		  return -1;
+	  /* Parameters */
+	  if (*s == ';' && msg_params_d(home, &s, &v->v_params) == -1)
+		  return -1;
+	  /* Comment */
+	  if (*s == '(' && msg_comment_d(&s, &v->v_comment) == -1)
+		  return -1;
 
-  /* Parse protocol */
-  if (sip_transport_d(&s, &v->v_protocol) == -1)
-    return -1;
-  /* Host (and port) */
-  if (msg_hostport_d(&s, &v->v_host, &v->v_port) == -1)
-    return -1;
-  /* Parameters */
-  if (*s == ';' && msg_params_d(home, &s, &v->v_params) == -1)
-    return -1;
-  /* Comment */
-  if (*s == '(' && msg_comment_d(&s, &v->v_comment) == -1)
-    return -1;
-
-  return msg_parse_next_field(home, h, s, slen);
+	  msg_parse_next_field_without_recursion();
+  }
 }
 
 issize_t sip_via_e(char b[], isize_t bsiz, sip_header_t const *h, int flags)
diff -ur a/libsofia-sip-ua/sip/sip_caller_prefs.c b/libsofia-sip-ua/sip/sip_caller_prefs.c
--- a/libsofia-sip-ua/sip/sip_caller_prefs.c	2011-03-11 16:49:18.000000000 +0200
+++ b/libsofia-sip-ua/sip/sip_caller_prefs.c	2017-12-07 23:25:59.948840512 +0200
@@ -194,39 +194,41 @@
 issize_t sip_caller_prefs_d(su_home_t *home, sip_header_t *h,
 			    char *s, isize_t slen)
 {
-  sip_caller_prefs_t *cp = (sip_caller_prefs_t *)h;
-  url_t url[1];
-  char const *ignore = NULL;
-  int kludge = 0;
-
-  assert(h);
-
-  while (*s == ',')   /* Ignore empty entries (comma-whitespace) */
-    *s = '\0', s += span_lws(s + 1) + 1;
-
-  /* Kludge: support PoC IS spec with a typo... */
-  if (su_casenmatch(s, "*,", 2))
-    s[1] = ';',  kludge = 0;
-  else if (s[0] != '*' && s[0] != '<') {
-    /* Kludge: missing URL -  */
-    size_t n = span_attribute_value(s);
-    kludge = n > 0 && (s[n] == '\0' || s[n] == ',' || s[n] == ';');
-  }
-
-  if (kludge) {
-    if (msg_any_list_d(home, &s, (msg_param_t **)&cp->cp_params,
-		       msg_attribute_value_scanner, ';') == -1)
-      return -1;
-  }
-  /* Parse params (and ignore display name and url) */
-  else if (sip_name_addr_d(home, &s, &ignore, url, &cp->cp_params, NULL)
-	   == -1)
-    return -1;
-  /* Be liberal... */
-  /* if (url->url_type != url_any)
-     return -1; */
-
-  return msg_parse_next_field(home, h, s, slen);
+	for(;;) {
+		sip_caller_prefs_t *cp = (sip_caller_prefs_t *)h;
+		url_t url[1];
+		char const *ignore = NULL;
+		int kludge = 0;
+
+		assert(h);
+
+		while (*s == ',')   /* Ignore empty entries (comma-whitespace) */
+			*s = '\0', s += span_lws(s + 1) + 1;
+
+		/* Kludge: support PoC IS spec with a typo... */
+		if (su_casenmatch(s, "*,", 2))
+			s[1] = ';',  kludge = 0;
+		else if (s[0] != '*' && s[0] != '<') {
+			/* Kludge: missing URL -  */
+			size_t n = span_attribute_value(s);
+			kludge = n > 0 && (s[n] == '\0' || s[n] == ',' || s[n] == ';');
+		}
+
+		if (kludge) {
+			if (msg_any_list_d(home, &s, (msg_param_t **)&cp->cp_params,
+							   msg_attribute_value_scanner, ';') == -1)
+				return -1;
+		}
+		/* Parse params (and ignore display name and url) */
+		else if (sip_name_addr_d(home, &s, &ignore, url, &cp->cp_params, NULL)
+				 == -1)
+			return -1;
+		/* Be liberal... */
+		/* if (url->url_type != url_any)
+		   return -1; */
+		msg_parse_next_field_without_recursion();
+	}
+	
 }
 
 static
diff -ur a/libsofia-sip-ua/sip/sip.doxyaliases b/libsofia-sip-ua/sip/sip.doxyaliases
--- a/libsofia-sip-ua/sip/sip.doxyaliases	2011-03-11 16:49:18.000000000 +0200
+++ b/libsofia-sip-ua/sip/sip.doxyaliases	2017-12-07 23:25:59.932840425 +0200
@@ -41,7 +41,6 @@
  "ReferTo=@ref sip_refer_to \"Refer-To\"" \
  "ReferredBy=@ref sip_referred_by \"Referred-By\"" \
  "RejectContact=@ref sip_reject_contact \"Reject-Contact\"" \
- "RemotePartyId=@ref sip_remote_party_id \"Remote-Party-Id\"" \
  "Replaces=@ref sip_replaces \"Replaces\"" \
  "RequestDisposition=@ref sip_request_disposition \"Request-Disposition\"" \
  "Require=@ref sip_require \"Require\"" \
diff -ur a/libsofia-sip-ua/sip/sip_extra.c b/libsofia-sip-ua/sip/sip_extra.c
--- a/libsofia-sip-ua/sip/sip_extra.c	2011-03-11 16:49:18.000000000 +0200
+++ b/libsofia-sip-ua/sip/sip_extra.c	2017-12-07 23:25:59.956840555 +0200
@@ -40,15 +40,17 @@
 #define MSG_PUB_T       struct sip_s
 #define MSG_HDR_T       union sip_header_u
 
+
 #include "sofia-sip/sip_parser.h"
 #include "sofia-sip/sip_extra.h"
+#include "../su/sofia-sip/su_alloc.h"
 
 #include <stdio.h>
 #include <stddef.h>
 #include <stdlib.h>
 #include <string.h>
 #include <limits.h>
-
+#
 #include <assert.h>
 
 /* ====================================================================== */
@@ -309,7 +311,7 @@
  * {
  *   sip_common_t       rplyto_common[1]; // Common fragment info
 
- *   sip_error_t       *rplyto_next;	 // Dummy link to next header
+ *   sip_reply_to_t       *rplyto_next;	 // Dummy link to next header
  *   char const        *rplyto_display;	 // Display name
  *   url_t              rplyto_url[1];	 // Return URI
  *   msg_param_t const *rplyto_params;	 // List of optional parameters
@@ -887,16 +889,19 @@
   sip_call_info_t *ci = h->sh_call_info;
   char *end = s + slen;
 
-  assert(h);
+  for(;;) {
+	  ci = h->sh_call_info;
+	  end = s + slen;
 
-  while (*s == ',')
-    s += span_lws(s + 1) + 1;
+	  while (*s == ',')
+		  s += span_lws(s + 1) + 1;
 
-  if (sip_name_addr_d(home, &s, NULL, ci->ci_url, &ci->ci_params, NULL) < 0)
-    return -1;
+	  if (sip_name_addr_d(home, &s, NULL, ci->ci_url, &ci->ci_params, NULL) < 0)
+		  return -1;
 
-  /* Recurse */
-  return msg_parse_next_field(home, h, s, end - s);
+	  slen = end - s;
+	  msg_parse_next_field_without_recursion();
+  }
 }
 
 isize_t sip_info_dup_xtra(sip_header_t const *h, isize_t offset)
@@ -1148,18 +1153,23 @@
 issize_t sip_remote_party_id_d(su_home_t *home, sip_header_t *h,
 			       char *s, isize_t slen)
 {
-  sip_remote_party_id_t *rpid = (sip_remote_party_id_t *)h;
+	sip_remote_party_id_t *rpid;
 
-  while (*s == ',')   /* Ignore empty entries (comma-whitespace) */
-    *s = '\0', s += span_lws(s + 1) + 1;
+	for(;;) {
+		rpid = (sip_remote_party_id_t *)h;
 
-  if (sip_name_addr_d(home, &s,
-		      &rpid->rpid_display,
-		      rpid->rpid_url,
-		      &rpid->rpid_params, NULL) == -1)
-    return -1;
+		while (*s == ',')   /* Ignore empty entries (comma-whitespace) */
+			*s = '\0', s += span_lws(s + 1) + 1;
+
+		if (sip_name_addr_d(home, &s,
+							&rpid->rpid_display,
+							rpid->rpid_url,
+							&rpid->rpid_params, NULL) == -1)
+			return -1;
+
+		msg_parse_next_field_without_recursion();
+	}
 
-  return msg_parse_next_field(home, h, s, slen);
 }
 
 issize_t sip_remote_party_id_e(char b[], isize_t bsiz,
@@ -1288,18 +1298,22 @@
 issize_t sip_p_asserted_identity_d(su_home_t *home, sip_header_t *h,
 				   char *s, isize_t slen)
 {
-  sip_p_asserted_identity_t *paid = (sip_p_asserted_identity_t *)h;
+	sip_p_asserted_identity_t *paid;
 
-  while (*s == ',')   /* Ignore empty entries (comma-whitespace) */
-    *s = '\0', s += span_lws(s + 1) + 1;
+	for(;;) {
+		paid = (sip_p_asserted_identity_t *)h;
+		while (*s == ',')   /* Ignore empty entries (comma-whitespace) */
+			*s = '\0', s += span_lws(s + 1) + 1;
+
+		if (sip_name_addr_d(home, &s,
+							&paid->paid_display,
+							paid->paid_url,
+							NULL, NULL) == -1)
+			return -1;
 
-  if (sip_name_addr_d(home, &s,
-		      &paid->paid_display,
-		      paid->paid_url,
-		      NULL, NULL) == -1)
-    return -1;
+		msg_parse_next_field_without_recursion();
+	}
 
-  return msg_parse_next_field(home, h, s, slen);
 }
 
 issize_t sip_p_asserted_identity_e(char b[], isize_t bsiz,
diff -ur a/libsofia-sip-ua/sip/sip_feature.c b/libsofia-sip-ua/sip/sip_feature.c
--- a/libsofia-sip-ua/sip/sip_feature.c	2011-03-11 16:49:18.000000000 +0200
+++ b/libsofia-sip-ua/sip/sip_feature.c	2017-12-07 23:25:59.964840599 +0200
@@ -116,7 +116,7 @@
     k->k_bitmap = 0;
   }
   else {
-    sip_method_t method = sip_method_code(name);
+	  int method = (int)sip_method_code(name);
 
     if (method >= 0 && method < 32)
       k->k_bitmap |= 1 << method;
@@ -130,14 +130,16 @@
 		   sip_method_t method,
 		   char const *name)
 {
-  if (method < sip_method_unknown || !allow)
+  int meth = method;
+
+  if (meth < sip_method_unknown || !allow)
     return 0;
 
-  if (sip_method_unknown < method && method < 32)
+  if (sip_method_unknown < meth && meth < 32)
     /* Well-known method */
-    return (allow->k_bitmap & (1 << method)) != 0;
+    return (allow->k_bitmap & (1 << meth)) != 0;
 
-  if (method == sip_method_unknown &&
+  if (meth == sip_method_unknown &&
       (allow->k_bitmap & (1 << sip_method_unknown)) == 0)
     return 0;
 
diff -ur a/libsofia-sip-ua/sip/sip_mime.c b/libsofia-sip-ua/sip/sip_mime.c
--- a/libsofia-sip-ua/sip/sip_mime.c	2011-03-11 16:49:18.000000000 +0200
+++ b/libsofia-sip-ua/sip/sip_mime.c	2017-12-07 23:25:59.980840685 +0200
@@ -135,24 +135,28 @@
 
 issize_t sip_accept_disposition_d(su_home_t *home, sip_header_t *h, char *s, isize_t slen)
 {
-  sip_accept_disposition_t *ad = (sip_accept_disposition_t *)h;
+	sip_accept_disposition_t *ad;
 
-  assert(h);
+	assert(h);
 
-  /* Ignore empty entries (comma-whitespace) */
-  while (*s == ',')
-    s += span_lws(s + 1) + 1;
+	for(;;) {
+		ad = (sip_accept_disposition_t *)h;
+		/* Ignore empty entries (comma-whitespace) */
+		while (*s == ',')
+			s += span_lws(s + 1) + 1;
+
+		/* "Accept:" #(type/subtyp ; *(parameters))) */
+		if (/* Parse protocol */
+			sip_version_d(&s, &ad->ad_type) == -1 ||
+			(ad->ad_subtype = strchr(ad->ad_type, '/')) == NULL ||
+			(*s == ';' && msg_params_d(home, &s, &ad->ad_params) == -1))
+			return -1;
 
-  /* "Accept:" #(type/subtyp ; *(parameters))) */
-  if (/* Parse protocol */
-      sip_version_d(&s, &ad->ad_type) == -1 ||
-      (ad->ad_subtype = strchr(ad->ad_type, '/')) == NULL ||
-      (*s == ';' && msg_params_d(home, &s, &ad->ad_params) == -1))
-    return -1;
+		if (ad->ad_subtype) ad->ad_subtype++;
 
-  if (ad->ad_subtype) ad->ad_subtype++;
+		msg_parse_next_field_without_recursion();
+	}
 
-  return msg_parse_next_field(home, h, s, slen);
 }
 
 issize_t sip_accept_disposition_e(char b[], isize_t bsiz, sip_header_t const *h, int flags)
diff -ur a/libsofia-sip-ua/sip/sip_parser.c b/libsofia-sip-ua/sip/sip_parser.c
--- a/libsofia-sip-ua/sip/sip_parser.c	2011-03-11 16:49:18.000000000 +0200
+++ b/libsofia-sip-ua/sip/sip_parser.c	2017-12-07 23:25:59.984840707 +0200
@@ -451,6 +451,8 @@
 char const sip_transport_udp[] = "SIP/2.0/UDP";
 char const sip_transport_tcp[] = "SIP/2.0/TCP";
 char const sip_transport_sctp[] = "SIP/2.0/SCTP";
+char const sip_transport_ws[] = "SIP/2.0/WS";
+char const sip_transport_wss[] = "SIP/2.0/WSS";
 char const sip_transport_tls[] = "SIP/2.0/TLS";
 
 /** Decode transport */
@@ -470,6 +472,8 @@
       (!TRANSPORT_MATCH(sip_transport_udp) &&
        !TRANSPORT_MATCH(sip_transport_tcp) &&
        !TRANSPORT_MATCH(sip_transport_sctp) &&
+       !TRANSPORT_MATCH(sip_transport_ws) &&
+       !TRANSPORT_MATCH(sip_transport_wss) &&
        !TRANSPORT_MATCH(sip_transport_tls))) {
     /* Protocol name */
     transport = pn = s;
@@ -512,6 +516,10 @@
 	transport = sip_transport_tcp;
       else if (su_casematch(transport, sip_transport_sctp))
 	transport = sip_transport_sctp;
+      else if (su_casematch(transport, sip_transport_ws))
+	transport = sip_transport_ws;
+      else if (su_casematch(transport, sip_transport_wss))
+	transport = sip_transport_wss;
       else if (su_casematch(transport, sip_transport_tls))
 	transport = sip_transport_tls;
     }
@@ -529,10 +537,14 @@
   if (transport == sip_transport_udp ||
       transport == sip_transport_tcp ||
       transport == sip_transport_sctp ||
+      transport == sip_transport_ws ||
+      transport == sip_transport_wss ||
       transport == sip_transport_tls ||
       su_casematch(transport, sip_transport_udp) ||
       su_casematch(transport, sip_transport_tcp) ||
       su_casematch(transport, sip_transport_sctp) ||
+      su_casematch(transport, sip_transport_ws) ||
+      su_casematch(transport, sip_transport_wss) ||
       su_casematch(transport, sip_transport_tls))
     return 0;
 
@@ -550,6 +562,10 @@
     *dd = s;
   else if (s == sip_transport_tls)
     *dd = s;
+  else if (s == sip_transport_ws)
+    *dd = s;
+  else if (s == sip_transport_wss)
+    *dd = s;
   else if (su_casematch(s, sip_transport_udp))
     *dd = sip_transport_udp;
   else if (su_casematch(s, sip_transport_tcp))
@@ -558,6 +574,10 @@
     *dd = sip_transport_sctp;
   else if (su_casematch(s, sip_transport_tls))
     *dd = sip_transport_tls;
+  else if (su_casematch(s, sip_transport_ws))
+    *dd = sip_transport_ws;
+  else if (su_casematch(s, sip_transport_wss))
+    *dd = sip_transport_wss;
   else
     MSG_STRING_DUP(*pp, *dd, s);
 }
@@ -641,7 +661,7 @@
   else {
     if (sip->sip_content_length->l_length != len) {
       sip->sip_content_length->l_length = (uint32_t)len;
-      msg_fragment_clear(sip->sip_content_length->l_common);
+      sip_fragment_clear(sip->sip_content_length->l_common);
     }
   }
 
diff -ur a/libsofia-sip-ua/sip/sip_reason.c b/libsofia-sip-ua/sip/sip_reason.c
--- a/libsofia-sip-ua/sip/sip_reason.c	2011-03-11 16:49:18.000000000 +0200
+++ b/libsofia-sip-ua/sip/sip_reason.c	2017-12-07 23:26:00.004840816 +0200
@@ -96,20 +96,25 @@
 
 issize_t sip_reason_d(su_home_t *home, sip_header_t *h, char *s, isize_t slen)
 {
-  sip_reason_t *re = (sip_reason_t *)h;
-  size_t n;
+	sip_reason_t *re;
+	size_t n;
+	for (;;) {
+		re = (sip_reason_t *)h;
 
-  while (*s == ',')   /* Ignore empty entries (comma-whitespace) */
-    *s = '\0', s += span_lws(s + 1) + 1;
+		while (*s == ',')   /* Ignore empty entries (comma-whitespace) */
+			*s = '\0', s += span_lws(s + 1) + 1;
+
+		re->re_protocol = s;
+		if ((n = span_token(s)) == 0)
+			return -1;
+		s += n; while (IS_LWS(*s)) *s++ = '\0';
+		if (*s == ';' && msg_params_d(home, &s, &re->re_params) < 0)
+			return -1;
+
+		msg_parse_next_field_without_recursion();
+	}
 
-  re->re_protocol = s;
-  if ((n = span_token(s)) == 0)
-    return -1;
-  s += n; while (IS_LWS(*s)) *s++ = '\0';
-  if (*s == ';' && msg_params_d(home, &s, &re->re_params) < 0)
-    return -1;
 
-  return msg_parse_next_field(home, h, s, slen);
 }
 
 issize_t sip_reason_e(char b[], isize_t bsiz, sip_header_t const *h, int f)
diff -ur a/libsofia-sip-ua/sip/sip_security.c b/libsofia-sip-ua/sip/sip_security.c
--- a/libsofia-sip-ua/sip/sip_security.c	2011-03-11 16:49:18.000000000 +0200
+++ b/libsofia-sip-ua/sip/sip_security.c	2017-12-07 23:26:00.016840881 +0200
@@ -458,20 +458,24 @@
 static
 issize_t sip_security_agree_d(su_home_t *home, sip_header_t *h, char *s, isize_t slen)
 {
-  sip_security_agree_t *sa = (sip_security_agree_t *)h;
 
-  isize_t n;
+	for (;;) {
+		sip_security_agree_t *sa = (sip_security_agree_t *)h;
 
-  while (*s == ',')   /* Ignore empty entries (comma-whitespace) */
-    *s = '\0', s += span_lws(s + 1) + 1;
+		isize_t n;
 
-  if ((n = span_token(s)) == 0)
-    return -1;
-  sa->sa_mec = s; s += n; while (IS_LWS(*s)) *s++ = '\0';
-  if (*s == ';' && msg_params_d(home, &s, &sa->sa_params) < 0)
-    return -1;
+		while (*s == ',')   /* Ignore empty entries (comma-whitespace) */
+			*s = '\0', s += span_lws(s + 1) + 1;
+
+		if ((n = span_token(s)) == 0)
+			return -1;
+		sa->sa_mec = s; s += n; while (IS_LWS(*s)) *s++ = '\0';
+		if (*s == ';' && msg_params_d(home, &s, &sa->sa_params) < 0)
+			return -1;
+
+		msg_parse_next_field_without_recursion();
+	}
 
-  return msg_parse_next_field(home, h, s, slen);
 }
 
 static
diff -ur a/libsofia-sip-ua/sip/sip_tag_class.c b/libsofia-sip-ua/sip/sip_tag_class.c
--- a/libsofia-sip-ua/sip/sip_tag_class.c	2011-03-11 16:49:18.000000000 +0200
+++ b/libsofia-sip-ua/sip/sip_tag_class.c	2017-12-07 23:26:00.036840989 +0200
@@ -381,8 +381,8 @@
       return NULL;
 
     for (;*n; n++)
-      if (isupper(*n))
-	*n = tolower(*n);
+      if (isupper(*(const unsigned char *)n))
+	*n = tolower(*(const unsigned char *)n);
 
     slen = strlen(s); elen = url_esclen(s, HNV_RESERVED);
 
diff -ur a/libsofia-sip-ua/sip/sip_util.c b/libsofia-sip-ua/sip/sip_util.c
--- a/libsofia-sip-ua/sip/sip_util.c	2011-03-11 16:49:18.000000000 +0200
+++ b/libsofia-sip-ua/sip/sip_util.c	2017-12-07 23:26:00.048841055 +0200
@@ -394,7 +394,8 @@
 char *sip_header_as_string(su_home_t *home, sip_header_t const *h)
 {
   ssize_t len;
-  char *rv, s[128];
+  char *rv, s[256];
+  ssize_t n;
 
   if (h == NULL)
     return NULL;
@@ -412,7 +413,8 @@
   for (rv = su_alloc(home, len);
        rv;
        rv = su_realloc(home, rv, len)) {
-    ssize_t n = sip_header_field_e(rv, len, h, 0);
+	memset(rv,0,len);
+    n = sip_header_field_e(rv, len, h, 0);
     if (n > -1 && n + 1 <= len)
       break;
     if (n > -1)			/* glibc >2.1 */
@@ -668,12 +670,27 @@
   return sip_route_fixdup_as(home, sip_route_class, route);
 }
 
+static void sip_fragment_clear_chain(sip_header_t *h)
+{
+  void const *next;
+
+  for (; h; h = h->sh_succ) {
+    next = (char *)h->sh_data + h->sh_len;
+
+    sip_fragment_clear(h->sh_common);
+
+    if (!next ||
+	!h->sh_succ ||
+	h->sh_next != h->sh_succ ||
+	h->sh_succ->sh_data != next ||
+	h->sh_succ->sh_len)
+      return;
+  }
+}
+
 /**@ingroup sip_route
  *
  * Fix @Route header.
- *
- * If URI has no parameters and the header contains a single @c ;lr header
- * parameter, the "lr" is moved as URI parameter.
  */
 sip_route_t *sip_route_fix(sip_route_t *route)
 {
@@ -699,7 +716,7 @@
       for (i = 0; r->r_params[i]; i++)
 	((char const **)r->r_params)[i] = r->r_params[i + 1];
 
-      msg_fragment_clear_chain((msg_header_t *)h);
+      sip_fragment_clear_chain(h);
     }
   }
 
@@ -717,9 +734,14 @@
   if (sip == NULL)
     return NULL;
 
-  v = sip->sip_via;
+  for (v = sip->sip_via; v; v = v->v_next) {
+    sip_fragment_clear(v->v_common);
+
+    if (v->v_next != (void *)v->v_common->h_succ)
+      break;
+  }
 
-  if (v)
+  if ((v = sip->sip_via))
     msg_header_remove(msg, (msg_pub_t *)sip, (msg_header_t *)v);
 
   return v;
diff -ur a/libsofia-sip-ua/sip/sofia-sip/sip_extra.h.in b/libsofia-sip-ua/sip/sofia-sip/sip_extra.h.in
--- a/libsofia-sip-ua/sip/sofia-sip/sip_extra.h.in	2011-03-11 16:49:18.000000000 +0200
+++ b/libsofia-sip-ua/sip/sofia-sip/sip_extra.h.in	2017-12-07 23:26:01.264847649 +0200
@@ -87,7 +87,7 @@
 struct sip_reply_to_s
 {
   sip_common_t        rplyto_common[1];	/**< Common fragment info */
-  sip_error_t        *rplyto_next;	/**< Dummy link to next header */
+  sip_reply_to_t        *rplyto_next;	/**< Dummy link to next header */
   char const         *rplyto_display;	/**< Display name */
   url_t               rplyto_url[1];	/**< Return URI */
   msg_param_t const  *rplyto_params;	/**< List of optional parameters */
diff -ur a/libsofia-sip-ua/sip/sofia-sip/sip.h b/libsofia-sip-ua/sip/sofia-sip/sip.h
--- a/libsofia-sip-ua/sip/sofia-sip/sip.h	2011-03-11 16:49:18.000000000 +0200
+++ b/libsofia-sip-ua/sip/sofia-sip/sip.h	2017-12-07 23:26:01.260847628 +0200
@@ -81,10 +81,18 @@
 #define SIP_METHOD_PUBLISH    sip_method_publish, "PUBLISH"
 
 /** Magic pointer value - never valid for SIP headers. @HI */
+#ifndef _MSC_VER
 #define SIP_NONE ((void const *)-1L)
+#else
+#define SIP_NONE ((void const *)(INT_PTR)-1L)
+#endif
 
 /** SIP protocol identifier @HIDE */
+#ifndef _MSC_VER
 #define SIP_PROTOCOL_TAG   ((void *)0x53495020)	/* 'SIP'20 */
+#else
+#define SIP_PROTOCOL_TAG   ((void *)(UINT_PTR)0x53495020)	/* 'SIP'20 */
+#endif
 
 enum {
   /** Default port for SIP as integer */
diff -ur a/libsofia-sip-ua/sip/sofia-sip/sip_header.h b/libsofia-sip-ua/sip/sofia-sip/sip_header.h
--- a/libsofia-sip-ua/sip/sofia-sip/sip_header.h	2011-03-11 16:49:18.000000000 +0200
+++ b/libsofia-sip-ua/sip/sofia-sip/sip_header.h	2017-12-07 23:26:01.276847714 +0200
@@ -162,6 +162,10 @@
 SOFIAPUBVAR char const sip_transport_sctp[];
 /** @internal TLS transport version string. */
 SOFIAPUBVAR char const sip_transport_tls[];
+/** @internal WS transport version string. */
+SOFIAPUBVAR char const sip_transport_ws[];
+/** @internal WSS transport version string. */
+SOFIAPUBVAR char const sip_transport_wss[];
 /** @internal SIP version string. */
 SOFIAPUBVAR char const sip_version_2_0[];
 
@@ -313,7 +317,7 @@
  * @HIDE
  */
 #define SIP_PAYLOAD_INIT2(data, length) \
-  {{{ 0, 0, sip_payload_class, data, length }, NULL, data, length }}
+  {{{ 0, 0, sip_payload_class, data, length }}, NULL, data, length }
 
 /** Create a SIP separator line structure. */
 SOFIAPUBFUN sip_separator_t *sip_separator_create(su_home_t *home);
Only in b/libsofia-sip-ua/sip/tests: 10052.txt
diff -ur a/libsofia-sip-ua/sip/tests/own0.txt b/libsofia-sip-ua/sip/tests/own0.txt
--- a/libsofia-sip-ua/sip/tests/own0.txt	2011-03-11 16:49:18.000000000 +0200
+++ b/libsofia-sip-ua/sip/tests/own0.txt	2017-12-07 23:26:01.324847975 +0200
@@ -1,45 +1,45 @@
-REGISTER sip:garage.sr.ntc.nokia.com SIP/2.0
-Via: SIP/2.0/UDP srlab.sr.ntc.nokia.com:5060;maddr=192.168.102.5
-Via: SIP/2.0/TCP srlab.sr.ntc.nokia.com:5060;maddr=192.168.102.5 (NTA 1.0)
-Via: SIP/2.0/UDP 192.2.2.1:5060;received=[ffe0::FAB1]
-Route: <sip:garage.sr.ntc.nokia.com:5060;maddr=srlab.sr.ntc.nokia.com>;foo=bar
-Record-Route: <sip:garage.sr.ntc.nokia.com:5060;maddr=srlab.sr.ntc.nokia.com>
-Hide: route
-Max-Forwards: 15
-From: sip:digest@garage.sr.ntc.nokia.com
-To: sip:digest@garage.sr.ntc.nokia.com
-Contact: sip:digest@172.21.9.155
-Call-ID: 982773899-reg@172.21.9.155
-CSeq: 2 REGISTER
-Subject: Barfoo
-Priority: emergency
-Date: Wed, 04 Apr 2001 17:38:38 GMT
-Retry-After: Wed, 04 Apr 2001 19:00:00 GMT (wake-up) ;duration=1800
-Timestamp: 986395257.13924321 3
-Expires: 180
-Also: sip:digestify@garage.sr.ntc.nokia.com
-Call-Info: <http://garage.sr.ntc.nokia.com/images/face.jpg>;purpose=icon
-Organization: Fuzzy Felines, Inc.
-Server: please
-User-Agent: Nokia Universal Killer Internet Application/2.0 (NUUKIA)
-In-Reply-To: 982773898-reg@172.21.9.155
-Accept: text/plain
-Accept-Encoding: identity, deflate (???)
-Accept-Language: en
-Allow: any
-Require: all
-Proxy-Require: kinky, things
-Supported: sip-cc, sip-cc-01, timer
-Unsupported: everything
-Error-Info: <http://garage.sr.ntc.nokia.com/figure-1.jpg>
-Warning: 300 garage.sr.ntc.nokia.com IPv6 global addresses not available
-Warning: 330 garage.sr.ntc.nokia.com No IPv6 multicast, 330 garage.sr.ntc.nokia.com Only local IPv4 multicast available
-Authorization: Digest USERNAME="digest", REALM="garage.sr.ntc.nokia.com", NONCE="MjAwMS0wMS0yMSAxNTowODo1OA==", RESPONSE="d9d7f1ae99a013cb05f319f0f678251d", URI="sip:garage.sr.ntc.nokia.com"
-Via: SIP/2.0/UDP 172.21.9.155
-MIME-Version: 1.0
-Content-Type: text/plain;charset=US-ASCII
-Content-Encoding: identity
-Content-Disposition: render;handling=optional
-Content-Length: 31
-
-xxxxxxxxxxxxxxxxxxxxxxxxxxxxx
+REGISTER sip:garage.sr.ntc.nokia.com SIP/2.0
+Via: SIP/2.0/UDP srlab.sr.ntc.nokia.com:5060;maddr=192.168.102.5
+Via: SIP/2.0/TCP srlab.sr.ntc.nokia.com:5060;maddr=192.168.102.5 (NTA 1.0)
+Via: SIP/2.0/UDP 192.2.2.1:5060;received=[ffe0::FAB1]
+Route: <sip:garage.sr.ntc.nokia.com:5060;maddr=srlab.sr.ntc.nokia.com>;foo=bar
+Record-Route: <sip:garage.sr.ntc.nokia.com:5060;maddr=srlab.sr.ntc.nokia.com>
+Hide: route
+Max-Forwards: 15
+From: sip:digest@garage.sr.ntc.nokia.com
+To: sip:digest@garage.sr.ntc.nokia.com
+Contact: sip:digest@172.21.9.155
+Call-ID: 982773899-reg@172.21.9.155
+CSeq: 2 REGISTER
+Subject: Barfoo
+Priority: emergency
+Date: Wed, 04 Apr 2001 17:38:38 GMT
+Retry-After: Wed, 04 Apr 2001 19:00:00 GMT (wake-up) ;duration=1800
+Timestamp: 986395257.13924321 3
+Expires: 180
+Also: sip:digestify@garage.sr.ntc.nokia.com
+Call-Info: <http://garage.sr.ntc.nokia.com/images/face.jpg>;purpose=icon
+Organization: Fuzzy Felines, Inc.
+Server: please
+User-Agent: Nokia Universal Killer Internet Application/2.0 (NUUKIA)
+In-Reply-To: 982773898-reg@172.21.9.155
+Accept: text/plain
+Accept-Encoding: identity, deflate (???)
+Accept-Language: en
+Allow: any
+Require: all
+Proxy-Require: kinky, things
+Supported: sip-cc, sip-cc-01, timer
+Unsupported: everything
+Error-Info: <http://garage.sr.ntc.nokia.com/figure-1.jpg>
+Warning: 300 garage.sr.ntc.nokia.com IPv6 global addresses not available
+Warning: 330 garage.sr.ntc.nokia.com No IPv6 multicast, 330 garage.sr.ntc.nokia.com Only local IPv4 multicast available
+Authorization: Digest USERNAME="digest", REALM="garage.sr.ntc.nokia.com", NONCE="MjAwMS0wMS0yMSAxNTowODo1OA==", RESPONSE="d9d7f1ae99a013cb05f319f0f678251d", URI="sip:garage.sr.ntc.nokia.com"
+Via: SIP/2.0/UDP 172.21.9.155
+MIME-Version: 1.0
+Content-Type: text/plain;charset=US-ASCII
+Content-Encoding: identity
+Content-Disposition: render;handling=optional
+Content-Length: 31
+
+xxxxxxxxxxxxxxxxxxxxxxxxxxxxx
diff -ur a/libsofia-sip-ua/sip/tests/own5.txt b/libsofia-sip-ua/sip/tests/own5.txt
--- a/libsofia-sip-ua/sip/tests/own5.txt	2011-03-11 16:49:18.000000000 +0200
+++ b/libsofia-sip-ua/sip/tests/own5.txt	2017-12-07 23:26:01.344848083 +0200
@@ -1,27 +1,27 @@
-INVITE sip:bob@[3ffe:1200:3012:c006:206:5bff:fe55:462f] SIP/2.0
-Via: SIP/2.0/UDP [3ffe:1200:3012:c000:0030:e0ff:fe40:6297]:5062
-     ;branch=z9hG4bKuNCTHs8Lumv
-     ;received=3ffe:1200:3012:c006:0030:e0ff:fe40:6297
-Via: SIP/2.0/UDP [3ffe:1200:3012:c000:210:a4ff:fe8d:6a46]:5062
-     ;branch=z9hG4bKuNCTHs8Lumv
-     ;received=[3ffe:1200:3012:c006:210:a4ff:fe8d:6a46]
-From: <sip:alice@[3ffe:1200:3012:c000:210:a4ff:fe8d:6a46]>
-     ;tag=ud6a29947
-To: <sip:bob@example.com;maddr=[3ffe:1200:3012:c006:206:5bff:fe55:462f]>
-Call-ID: f89fa68e-5109-11d6-0581-0010A48D6A46
-CSeq: 2 INVITE
-Contact: <sip:[3ffe:1200:3012:c000:210:a4ff:fe8d:6a46]:5062>
-Call-Info: <http://[3ffe:1200:3012:c000:210:a4ff:fe8d:6a46]/alice.gif>
-     ;purpose=icon;g-param=[3ffe:1200:3012:c000:210:a4ff:fe8d:6a46]
-Content-Type: application/sdp
-Content-Length: 239
-
-v=0
-o=alice 1804289383 2 IN IP6 3ffe:1200:3012:c000:210:a4ff:fe8d:6a46
-s=-
-c=IN IP6 3ffe:1200:3012:c000:210:a4ff:fe8d:6a46
-t=0 0
-m=audio 5004 RTP/AVP 96 97 98
-a=rtpmap:96 AMR/8000
-a=rtpmap:97 AMR-WB/16000
-a=rtpmap:98 GSM-EFR/8000
+INVITE sip:bob@[3ffe:1200:3012:c006:206:5bff:fe55:462f] SIP/2.0
+Via: SIP/2.0/UDP [3ffe:1200:3012:c000:0030:e0ff:fe40:6297]:5062
+     ;branch=z9hG4bKuNCTHs8Lumv
+     ;received=3ffe:1200:3012:c006:0030:e0ff:fe40:6297
+Via: SIP/2.0/UDP [3ffe:1200:3012:c000:210:a4ff:fe8d:6a46]:5062
+     ;branch=z9hG4bKuNCTHs8Lumv
+     ;received=[3ffe:1200:3012:c006:210:a4ff:fe8d:6a46]
+From: <sip:alice@[3ffe:1200:3012:c000:210:a4ff:fe8d:6a46]>
+     ;tag=ud6a29947
+To: <sip:bob@example.com;maddr=[3ffe:1200:3012:c006:206:5bff:fe55:462f]>
+Call-ID: f89fa68e-5109-11d6-0581-0010A48D6A46
+CSeq: 2 INVITE
+Contact: <sip:[3ffe:1200:3012:c000:210:a4ff:fe8d:6a46]:5062>
+Call-Info: <http://[3ffe:1200:3012:c000:210:a4ff:fe8d:6a46]/alice.gif>
+     ;purpose=icon;g-param=[3ffe:1200:3012:c000:210:a4ff:fe8d:6a46]
+Content-Type: application/sdp
+Content-Length: 239
+
+v=0
+o=alice 1804289383 2 IN IP6 3ffe:1200:3012:c000:210:a4ff:fe8d:6a46
+s=-
+c=IN IP6 3ffe:1200:3012:c000:210:a4ff:fe8d:6a46
+t=0 0
+m=audio 5004 RTP/AVP 96 97 98
+a=rtpmap:96 AMR/8000
+a=rtpmap:97 AMR-WB/16000
+a=rtpmap:98 GSM-EFR/8000
diff -ur a/libsofia-sip-ua/sip/tests/own6.txt b/libsofia-sip-ua/sip/tests/own6.txt
--- a/libsofia-sip-ua/sip/tests/own6.txt	2011-03-11 16:49:18.000000000 +0200
+++ b/libsofia-sip-ua/sip/tests/own6.txt	2017-12-07 23:26:01.348848105 +0200
@@ -1,17 +1,16 @@
-OPTIONS sip:bob@example.com SIP/2.0
-Via: SIP/2.0/UDP 172.21.40.44;branch=z9hG4bKitIIzAialKS
-Via: SIP/2.0/UDP [3ffe:1200:3012:c000:210:a4ff:fe8d:6a46]:5062
-     ;branch=z9hG4bKJv+PsUQdfOb
-     ;received=172.21.40.24
-Record-Route: <sip:bob@example.com;maddr=172.21.40.44>
-Record-Route: <sip:bob@example.com
-     ;maddr=[3ffe:1200:3012:c000:210:a4ff:fe8d:6a46]>
-From: <sip:alice@example.com>;tag=ud6a29947
-To: <sip:bob@example.com>
-Call-ID: f3359e42-5109-11d6-998d-0010a47e1c0f
-CSeq: 1 OPTIONS
-Contact: <sip:[3ffe:1200:3012:c000:210:a4ff:fe8d:6a46]:5062>
-Content-Length: 0
-Accept: 
-Allow: 
-
+OPTIONS sip:bob@example.com SIP/2.0
+Via: SIP/2.0/UDP 172.21.40.44;branch=z9hG4bKitIIzAialKS
+Via: SIP/2.0/UDP [3ffe:1200:3012:c000:210:a4ff:fe8d:6a46]:5062
+     ;branch=z9hG4bKJv+PsUQdfOb
+     ;received=172.21.40.24
+Record-Route: <sip:bob@example.com;maddr=172.21.40.44>
+Record-Route: <sip:bob@example.com
+     ;maddr=[3ffe:1200:3012:c000:210:a4ff:fe8d:6a46]>
+From: <sip:alice@example.com>;tag=ud6a29947
+To: <sip:bob@example.com>
+Call-ID: f3359e42-5109-11d6-998d-0010a47e1c0f
+CSeq: 1 OPTIONS
+Contact: <sip:[3ffe:1200:3012:c000:210:a4ff:fe8d:6a46]:5062>
+Content-Length: 0
+Accept:
+Allow:
diff -ur a/libsofia-sip-ua/sip/tests/own8.txt b/libsofia-sip-ua/sip/tests/own8.txt
--- a/libsofia-sip-ua/sip/tests/own8.txt	2011-03-11 16:49:18.000000000 +0200
+++ b/libsofia-sip-ua/sip/tests/own8.txt	2017-12-07 23:26:01.352848126 +0200
@@ -1,2 +1,2 @@
-JUNK * SIP/1.0
+JUNK * SIP/1.0
   
\ No newline at end of file
diff -ur a/libsofia-sip-ua/sip/tests/test12.txt b/libsofia-sip-ua/sip/tests/test12.txt
--- a/libsofia-sip-ua/sip/tests/test12.txt	2011-03-11 16:49:18.000000000 +0200
+++ b/libsofia-sip-ua/sip/tests/test12.txt	2017-12-07 23:26:01.384848300 +0200
@@ -12,7 +12,7 @@
 o=mhandley 29739 7272939 IN IP4 126.5.4.3
 c=IN IP4 135.180.130.88
 m=audio 492170 RTP/AVP 0 12
-m=video 3227 RTP/AVP 31
-s=My sesion
+m=video 3227 RTP/AVP 31
+s=My sesion
 t=2873397496 2873404696
 a=rtpmap:31 LPC
diff -ur a/libsofia-sip-ua/sip/tests/test1a.txt b/libsofia-sip-ua/sip/tests/test1a.txt
--- a/libsofia-sip-ua/sip/tests/test1a.txt	2011-03-11 16:49:18.000000000 +0200
+++ b/libsofia-sip-ua/sip/tests/test1a.txt	2017-12-07 23:26:01.424848517 +0200
@@ -1,21 +1,21 @@
-INVITE sip:vivekg@chair.dnrc.bell-labs.com SIP/2.0
- To :
-  sip:vivekg@chair.dnrc.bell-labs.com ;    tag    = 1a1b1f1H33n
-From   : "J Rosenberg \\\"" <sip:jdrosen@lucent.com>
-  ;
- tag = 98asjd8
-CaLl-Id
- : 0ha0isndaksdj@10.1.1.1
-cseq: 8 INVITE
-Via  : SIP   /  2.0/  UDP 
-  135.180.130.133
-Subject :
-Content-Type: application/sdp
-
-v:  SIP  / 2.0  / TCP     12.3.4.5   ;
-  branch  =   9ikj8  ,
-  SIP  /    2.0   / UDP  1.2.3.4   ; hidden   
-m:"Quoted string \"\"" <sip:jdrosen@bell-labs.com> ; newparam = newvalue ;
-  secondparam = secondvalue  ; q = 0.33
-  (((nested comments) and (more)))   ,
- tel:4443322
+INVITE sip:vivekg@chair.dnrc.bell-labs.com SIP/2.0
+ To :
+  sip:vivekg@chair.dnrc.bell-labs.com ;    tag    = 1a1b1f1H33n
+From   : "J Rosenberg \\\"" <sip:jdrosen@lucent.com>
+  ;
+ tag = 98asjd8
+CaLl-Id
+ : 0ha0isndaksdj@10.1.1.1
+cseq: 8 INVITE
+Via  : SIP   /  2.0/  UDP
+  135.180.130.133
+Subject :
+Content-Type: application/sdp
+
+v:  SIP  / 2.0  / TCP     12.3.4.5   ;
+  branch  =   9ikj8  ,
+  SIP  /    2.0   / UDP  1.2.3.4   ; hidden
+m:"Quoted string \"\"" <sip:jdrosen@bell-labs.com> ; newparam = newvalue ;
+  secondparam = secondvalue  ; q = 0.33
+  (((nested comments) and (more)))   ,
+ tel:4443322
diff -ur a/libsofia-sip-ua/sip/tests/test1.txt b/libsofia-sip-ua/sip/tests/test1.txt
--- a/libsofia-sip-ua/sip/tests/test1.txt	2011-03-11 16:49:18.000000000 +0200
+++ b/libsofia-sip-ua/sip/tests/test1.txt	2017-12-07 23:26:01.360848170 +0200
@@ -1,22 +1,22 @@
-INVITE sip:vivekg@chair.dnrc.bell-labs.com SIP/2.0
-  To :
-  sip:vivekg@chair.dnrc.bell-labs.com ;    tag    = 1a1b1f1H33n
-From   : "J Rosenberg \\\"" <sip:jdrosen@lucent.com>
-  ;
- tag = 98asjd8
-CaLl-Id
- : 0ha0isndaksdj@10.1.1.1
-cseq: 8 INVITE
-Via  : SIP   /  2.0/  UDP 
-  135.180.130.133
-Subject :
-NewFangledHeader:   newfangled value
- more newfangled value
-Content-Type: application/sdp
-v:  SIP  / 2.0  / TCP     12.3.4.5   ;
-  branch  =   9ikj8  ,
-  SIP  /    2.0   / UDP  1.2.3.4   ; hidden   
-m:"Quoted string \"\"" <sip:jdrosen@bell-labs.com> ; newparam = newvalue ;
-  secondparam = secondvalue  ; q = 0.33
-  (((nested comments) and (more)))   ,
- tel:4443322
+INVITE sip:vivekg@chair.dnrc.bell-labs.com SIP/2.0
+  To :
+  sip:vivekg@chair.dnrc.bell-labs.com ;    tag    = 1a1b1f1H33n
+From   : "J Rosenberg \\\"" <sip:jdrosen@lucent.com>
+  ;
+ tag = 98asjd8
+CaLl-Id
+ : 0ha0isndaksdj@10.1.1.1
+cseq: 8 INVITE
+Via  : SIP   /  2.0/  UDP
+  135.180.130.133
+Subject :
+NewFangledHeader:   newfangled value
+ more newfangled value
+Content-Type: application/sdp
+v:  SIP  / 2.0  / TCP     12.3.4.5   ;
+  branch  =   9ikj8  ,
+  SIP  /    2.0   / UDP  1.2.3.4   ; hidden
+m:"Quoted string \"\"" <sip:jdrosen@bell-labs.com> ; newparam = newvalue ;
+  secondparam = secondvalue  ; q = 0.33
+  (((nested comments) and (more)))   ,
+ tel:4443322
diff -ur a/libsofia-sip-ua/sip/tests/test21.txt b/libsofia-sip-ua/sip/tests/test21.txt
--- a/libsofia-sip-ua/sip/tests/test21.txt	2011-03-11 16:49:18.000000000 +0200
+++ b/libsofia-sip-ua/sip/tests/test21.txt	2017-12-07 23:26:01.436848582 +0200
@@ -1,17 +1,17 @@
-INVITE <sip:user@company.com> SIP/2.0
-To: sip:user@company.com
-From: sip:caller@university.edu
-Call-ID: 1@10.0.0.1
-CSeq: 1 INVITE
-Via: SIP/2.0/UDP 135.180.130.133
-Content-Type: application/sdp
-Content-Length: 163
-
-v=0
-o=mhandley 29739 7272939 IN IP4 126.5.4.3
-s=SIP Call
-t=0 0
-c=IN IP4 135.180.130.88
-m=audio 492170 RTP/AVP 0 12
-m=video 3227 RTP/AVP 31
-a=rtpmap:31 LPC
+INVITE <sip:user@company.com> SIP/2.0
+To: sip:user@company.com
+From: sip:caller@university.edu
+Call-ID: 1@10.0.0.1
+CSeq: 1 INVITE
+Via: SIP/2.0/UDP 135.180.130.133
+Content-Type: application/sdp
+Content-Length: 163
+
+v=0
+o=mhandley 29739 7272939 IN IP4 126.5.4.3
+s=SIP Call
+t=0 0
+c=IN IP4 135.180.130.88
+m=audio 492170 RTP/AVP 0 12
+m=video 3227 RTP/AVP 31
+a=rtpmap:31 LPC
diff -ur a/libsofia-sip-ua/sip/tests/test22.txt b/libsofia-sip-ua/sip/tests/test22.txt
--- a/libsofia-sip-ua/sip/tests/test22.txt	2011-03-11 16:49:18.000000000 +0200
+++ b/libsofia-sip-ua/sip/tests/test22.txt	2017-12-07 23:26:01.440848604 +0200
@@ -1,17 +1,17 @@
-INVITE sip:user@company.com; transport=udp SIP/2.0
-To: sip:user@company.com
-From: sip:caller@university.edu
-Call-ID: 2@10.0.0.1
-CSeq: 1 INVITE
-Via: SIP/2.0/UDP 135.180.130.133
-Content-Type: application/sdp
-Content-Length: 163
-
-v=0
-o=mhandley 29739 7272939 IN IP4 126.5.4.3
-s=SIP Call
-t=0 0
-c=IN IP4 135.180.130.88
-m=audio 492170 RTP/AVP 0 12
-m=video 3227 RTP/AVP 31
-a=rtpmap:31 LPC
+INVITE sip:user@company.com; transport=udp SIP/2.0
+To: sip:user@company.com
+From: sip:caller@university.edu
+Call-ID: 2@10.0.0.1
+CSeq: 1 INVITE
+Via: SIP/2.0/UDP 135.180.130.133
+Content-Type: application/sdp
+Content-Length: 163
+
+v=0
+o=mhandley 29739 7272939 IN IP4 126.5.4.3
+s=SIP Call
+t=0 0
+c=IN IP4 135.180.130.88
+m=audio 492170 RTP/AVP 0 12
+m=video 3227 RTP/AVP 31
+a=rtpmap:31 LPC
diff -ur a/libsofia-sip-ua/sip/tests/test23.txt b/libsofia-sip-ua/sip/tests/test23.txt
--- a/libsofia-sip-ua/sip/tests/test23.txt	2011-03-11 16:49:18.000000000 +0200
+++ b/libsofia-sip-ua/sip/tests/test23.txt	2017-12-07 23:26:01.444848626 +0200
@@ -1,17 +1,17 @@
-INVITE sip:user@company.com  SIP/2.0
-To: sip:user@company.com
-From: sip:caller@university.edu
-Call-ID: 3@10.0.0.1
-CSeq: 1 INVITE
-Via: SIP/2.0/UDP 135.180.130.133
-Content-Type: application/sdp
-Content-Length: 163
-
-v=0
-o=mhandley 29739 7272939 IN IP4 126.5.4.3
-s=SIP Call
-t=0 0
-c=IN IP4 135.180.130.88
-m=audio 492170 RTP/AVP 0 12
-m=video 3227 RTP/AVP 31
-a=rtpmap:31 LPC
+INVITE sip:user@company.com  SIP/2.0
+To: sip:user@company.com
+From: sip:caller@university.edu
+Call-ID: 3@10.0.0.1
+CSeq: 1 INVITE
+Via: SIP/2.0/UDP 135.180.130.133
+Content-Type: application/sdp
+Content-Length: 163
+
+v=0
+o=mhandley 29739 7272939 IN IP4 126.5.4.3
+s=SIP Call
+t=0 0
+c=IN IP4 135.180.130.88
+m=audio 492170 RTP/AVP 0 12
+m=video 3227 RTP/AVP 31
+a=rtpmap:31 LPC
diff -ur a/libsofia-sip-ua/sip/tests/test24.txt b/libsofia-sip-ua/sip/tests/test24.txt
--- a/libsofia-sip-ua/sip/tests/test24.txt	2011-03-11 16:49:18.000000000 +0200
+++ b/libsofia-sip-ua/sip/tests/test24.txt	2017-12-07 23:26:01.448848648 +0200
@@ -1,17 +1,17 @@
-INVITE sip:sip%3Auser%40example.com@company.com;other-param=summit SIP/2.0
-To: sip:user@company.com
-From: sip:caller@university.edu
-Call-ID: 4@10.0.0.1
-CSeq: 1 INVITE
-Via: SIP/2.0/UDP 135.180.130.133
-Content-Type: application/sdp
-Content-Length: 163
-
-v=0
-o=mhandley 29739 7272939 IN IP4 126.5.4.3
-s=SIP Call
-t=0 0
-c=IN IP4 135.180.130.88
-m=audio 492170 RTP/AVP 0 12
-m=video 3227 RTP/AVP 31
-a=rtpmap:31 LPC
+INVITE sip:sip%3Auser%40example.com@company.com;other-param=summit SIP/2.0
+To: sip:user@company.com
+From: sip:caller@university.edu
+Call-ID: 4@10.0.0.1
+CSeq: 1 INVITE
+Via: SIP/2.0/UDP 135.180.130.133
+Content-Type: application/sdp
+Content-Length: 163
+
+v=0
+o=mhandley 29739 7272939 IN IP4 126.5.4.3
+s=SIP Call
+t=0 0
+c=IN IP4 135.180.130.88
+m=audio 492170 RTP/AVP 0 12
+m=video 3227 RTP/AVP 31
+a=rtpmap:31 LPC
diff -ur a/libsofia-sip-ua/sip/tests/test25.txt b/libsofia-sip-ua/sip/tests/test25.txt
--- a/libsofia-sip-ua/sip/tests/test25.txt	2011-03-11 16:49:18.000000000 +0200
+++ b/libsofia-sip-ua/sip/tests/test25.txt	2017-12-07 23:26:01.452848669 +0200
@@ -1,17 +1,17 @@
-INVITE sip:user@company.com?Route=%3Csip:sip.example.com%3E SIP/2.0
-To: sip:user@company.com
-From: sip:caller@university.edu
-Call-ID: 5@10.0.0.1
-CSeq: 1 INVITE
-Via: SIP/2.0/UDP 135.180.130.133
-Content-Type: application/sdp
-Content-Length: 163
-
-v=0
-o=mhandley 29739 7272939 IN IP4 126.5.4.3
-s=SIP Call
-t=0 0
-c=IN IP4 135.180.130.88
-m=audio 492170 RTP/AVP 0 12
-m=video 3227 RTP/AVP 31
-a=rtpmap:31 LPC
+INVITE sip:user@company.com?Route=%3Csip:sip.example.com%3E SIP/2.0
+To: sip:user@company.com
+From: sip:caller@university.edu
+Call-ID: 5@10.0.0.1
+CSeq: 1 INVITE
+Via: SIP/2.0/UDP 135.180.130.133
+Content-Type: application/sdp
+Content-Length: 163
+
+v=0
+o=mhandley 29739 7272939 IN IP4 126.5.4.3
+s=SIP Call
+t=0 0
+c=IN IP4 135.180.130.88
+m=audio 492170 RTP/AVP 0 12
+m=video 3227 RTP/AVP 31
+a=rtpmap:31 LPC
diff -ur a/libsofia-sip-ua/sip/tests/test26.txt b/libsofia-sip-ua/sip/tests/test26.txt
--- a/libsofia-sip-ua/sip/tests/test26.txt	2011-03-11 16:49:18.000000000 +0200
+++ b/libsofia-sip-ua/sip/tests/test26.txt	2017-12-07 23:26:01.456848690 +0200
@@ -1,17 +1,17 @@
-INVITE name:user SIP/2.0
-To: sip:user@company.com
-From: sip:caller@university.edu
-Call-ID: 6@10.0.0.1
-CSeq: 1 INVITE
-Via: SIP/2.0/UDP 135.180.130.133
-Content-Type: application/sdp
-Content-Length: 163
-
-v=0
-o=mhandley 29739 7272939 IN IP4 126.5.4.3
-s=SIP Call
-t=0 0
-c=IN IP4 135.180.130.88
-m=audio 492170 RTP/AVP 0 12
-m=video 3227 RTP/AVP 31
-a=rtpmap:31 LPC
+INVITE name:user SIP/2.0
+To: sip:user@company.com
+From: sip:caller@university.edu
+Call-ID: 6@10.0.0.1
+CSeq: 1 INVITE
+Via: SIP/2.0/UDP 135.180.130.133
+Content-Type: application/sdp
+Content-Length: 163
+
+v=0
+o=mhandley 29739 7272939 IN IP4 126.5.4.3
+s=SIP Call
+t=0 0
+c=IN IP4 135.180.130.88
+m=audio 492170 RTP/AVP 0 12
+m=video 3227 RTP/AVP 31
+a=rtpmap:31 LPC
diff -ur a/libsofia-sip-ua/sip/tests/test27.txt b/libsofia-sip-ua/sip/tests/test27.txt
--- a/libsofia-sip-ua/sip/tests/test27.txt	2011-03-11 16:49:18.000000000 +0200
+++ b/libsofia-sip-ua/sip/tests/test27.txt	2017-12-07 23:26:01.460848712 +0200
@@ -1,8 +1,6 @@
-OPTIONS sip:user@company.com SIP/2.0
-To: sip:user@company.com
-From: "caller"<sip:caller@example.com>
-Call-ID: 1234abcd@10.0.0.1
-CSeq: 1 OPTIONS
-Via: SIP/2.0/UDP 135.180.130.133
-
-
+OPTIONS sip:user@company.com SIP/2.0
+To: sip:user@company.com
+From: "caller"<sip:caller@example.com>
+Call-ID: 1234abcd@10.0.0.1
+CSeq: 1 OPTIONS
+Via: SIP/2.0/UDP 135.180.130.133
diff -ur a/libsofia-sip-ua/sip/tests/test28.txt b/libsofia-sip-ua/sip/tests/test28.txt
--- a/libsofia-sip-ua/sip/tests/test28.txt	2011-03-11 16:49:18.000000000 +0200
+++ b/libsofia-sip-ua/sip/tests/test28.txt	2017-12-07 23:26:01.464848734 +0200
@@ -1,8 +1,6 @@
-OPTIONS sip:user@company.com SIP/2.0
-To: sip:user@company.com
-From: "caller"    <sip:caller@example.com>
-Call-ID: 1234abcd@10.0.0.1
-CSeq: 2 OPTIONS
-Via: SIP/2.0/UDP 135.180.130.133
-
-
+OPTIONS sip:user@company.com SIP/2.0
+To: sip:user@company.com
+From: "caller"    <sip:caller@example.com>
+Call-ID: 1234abcd@10.0.0.1
+CSeq: 2 OPTIONS
+Via: SIP/2.0/UDP 135.180.130.133
diff -ur a/libsofia-sip-ua/sip/tests/test29.txt b/libsofia-sip-ua/sip/tests/test29.txt
--- a/libsofia-sip-ua/sip/tests/test29.txt	2011-03-11 16:49:18.000000000 +0200
+++ b/libsofia-sip-ua/sip/tests/test29.txt	2017-12-07 23:26:01.468848755 +0200
@@ -1,18 +1,18 @@
-INVITE sip:user@company.com SIP/2.0
-To: sip:user@company.com
-From: sip:caller@university.edu
-Call-ID: 7@10.0.0.1
-CSeq: 1 INVITE
-Via: SIP/2.0/UDP 135.180.130.133
-Expires: Fri, 01 Jan 2010 16:00:00 EST
-Content-Type: application/sdp
-Content-Length: 163
-
-v=0
-o=mhandley 29739 7272939 IN IP4 126.5.4.3
-s=SIP Call
-t=0 0
-c=IN IP4 135.180.130.88
-m=audio 492170 RTP/AVP 0 12
-m=video 3227 RTP/AVP 31
-a=rtpmap:31 LPC
+INVITE sip:user@company.com SIP/2.0
+To: sip:user@company.com
+From: sip:caller@university.edu
+Call-ID: 7@10.0.0.1
+CSeq: 1 INVITE
+Via: SIP/2.0/UDP 135.180.130.133
+Expires: Fri, 01 Jan 2010 16:00:00 EST
+Content-Type: application/sdp
+Content-Length: 163
+
+v=0
+o=mhandley 29739 7272939 IN IP4 126.5.4.3
+s=SIP Call
+t=0 0
+c=IN IP4 135.180.130.88
+m=audio 492170 RTP/AVP 0 12
+m=video 3227 RTP/AVP 31
+a=rtpmap:31 LPC
diff -ur a/libsofia-sip-ua/sip/tests/test30.txt b/libsofia-sip-ua/sip/tests/test30.txt
--- a/libsofia-sip-ua/sip/tests/test30.txt	2011-03-11 16:49:18.000000000 +0200
+++ b/libsofia-sip-ua/sip/tests/test30.txt	2017-12-07 23:26:01.480848821 +0200
@@ -1,18 +1,18 @@
-INVITE sip:user@company.com SIP/2.0
-To: sip:user@company.com
-From: sip:caller@university.edu
-Call-ID: 8@10.0.0.1
-CSeq: 1 INVITE
-Via: SIP/2.0/UDP 135.180.130.133
-Expires: Thu, 01 Dec 1994 16:00:00 GMT
-Content-Type: application/sdp
-Content-Length: 163
-
-v=0
-o=mhandley 29739 7272939 IN IP4 126.5.4.3
-s=SIP Call
-t=0 0
-c=IN IP4 135.180.130.88
-m=audio 492170 RTP/AVP 0 12
-m=video 3227 RTP/AVP 31
-a=rtpmap:31 LPC
+INVITE sip:user@company.com SIP/2.0
+To: sip:user@company.com
+From: sip:caller@university.edu
+Call-ID: 8@10.0.0.1
+CSeq: 1 INVITE
+Via: SIP/2.0/UDP 135.180.130.133
+Expires: Thu, 01 Dec 1994 16:00:00 GMT
+Content-Type: application/sdp
+Content-Length: 163
+
+v=0
+o=mhandley 29739 7272939 IN IP4 126.5.4.3
+s=SIP Call
+t=0 0
+c=IN IP4 135.180.130.88
+m=audio 492170 RTP/AVP 0 12
+m=video 3227 RTP/AVP 31
+a=rtpmap:31 LPC
diff -ur a/libsofia-sip-ua/sip/tests/test31.txt b/libsofia-sip-ua/sip/tests/test31.txt
--- a/libsofia-sip-ua/sip/tests/test31.txt	2011-03-11 16:49:18.000000000 +0200
+++ b/libsofia-sip-ua/sip/tests/test31.txt	2017-12-07 23:26:01.484848842 +0200
@@ -1,18 +1,18 @@
-INVITE sip:user@company.com SIP/2.0
-To: sip:user@company.com
-From: sip:caller@university.edu
-Call-ID: 9@10.0.0.1
-CSeq: 1 INVITE
-Via: SIP/2.0/UDP 135.180.130.133
-Max-Forwards: 0
-Content-Type: application/sdp
-Content-Length: 163
-
-v=0
-o=mhandley 29739 7272939 IN IP4 126.5.4.3
-s=SIP Call
-t=0 0
-c=IN IP4 135.180.130.88
-m=audio 492170 RTP/AVP 0 12
-m=video 3227 RTP/AVP 31
-a=rtpmap:31 LPC
+INVITE sip:user@company.com SIP/2.0
+To: sip:user@company.com
+From: sip:caller@university.edu
+Call-ID: 9@10.0.0.1
+CSeq: 1 INVITE
+Via: SIP/2.0/UDP 135.180.130.133
+Max-Forwards: 0
+Content-Type: application/sdp
+Content-Length: 163
+
+v=0
+o=mhandley 29739 7272939 IN IP4 126.5.4.3
+s=SIP Call
+t=0 0
+c=IN IP4 135.180.130.88
+m=audio 492170 RTP/AVP 0 12
+m=video 3227 RTP/AVP 31
+a=rtpmap:31 LPC
diff -ur a/libsofia-sip-ua/sip/tests/test32.txt b/libsofia-sip-ua/sip/tests/test32.txt
--- a/libsofia-sip-ua/sip/tests/test32.txt	2011-03-11 16:49:18.000000000 +0200
+++ b/libsofia-sip-ua/sip/tests/test32.txt	2017-12-07 23:26:01.488848864 +0200
@@ -1,10 +1,8 @@
-REGISTER sip:company.com SIP/2.0
-To: sip:user@company.com
-From: sip:user@company.com
-Contact: sip:user@host.company.com
-Call-ID: k345asrl3fdbv@10.0.0.1
-CSeq: 1 REGISTER
-Via: SIP/2.0/UDP 135.180.130.133
-Contact: <sip:user@example.com?Route=%3Csip:sip.example.com%3E>
-
-
+REGISTER sip:company.com SIP/2.0
+To: sip:user@company.com
+From: sip:user@company.com
+Contact: sip:user@host.company.com
+Call-ID: k345asrl3fdbv@10.0.0.1
+CSeq: 1 REGISTER
+Via: SIP/2.0/UDP 135.180.130.133
+Contact: <sip:user@example.com?Route=%3Csip:sip.example.com%3E>
diff -ur a/libsofia-sip-ua/sip/tests/test33.txt b/libsofia-sip-ua/sip/tests/test33.txt
--- a/libsofia-sip-ua/sip/tests/test33.txt	2011-03-11 16:49:18.000000000 +0200
+++ b/libsofia-sip-ua/sip/tests/test33.txt	2017-12-07 23:26:01.496848907 +0200
@@ -1,10 +1,8 @@
-REGISTER sip:company.com SIP/2.0
-To: sip:user@company.com
-From: sip:user@company.com
-Contact: sip:user@host.company.com
-Call-ID: k345asrl3fdbv@10.0.0.1
-CSeq: 1 REGISTER
-Via: SIP/2.0/UDP 135.180.130.133
-Contact: sip:user@example.com?Route=%3Csip:sip.example.com%3E
-
-
+REGISTER sip:company.com SIP/2.0
+To: sip:user@company.com
+From: sip:user@company.com
+Contact: sip:user@host.company.com
+Call-ID: k345asrl3fdbv@10.0.0.1
+CSeq: 1 REGISTER
+Via: SIP/2.0/UDP 135.180.130.133
+Contact: sip:user@example.com?Route=%3Csip:sip.example.com%3E
diff -ur a/libsofia-sip-ua/sip/tests/test34.txt b/libsofia-sip-ua/sip/tests/test34.txt
--- a/libsofia-sip-ua/sip/tests/test34.txt	2011-03-11 16:49:18.000000000 +0200
+++ b/libsofia-sip-ua/sip/tests/test34.txt	2017-12-07 23:26:01.504848951 +0200
@@ -1,52 +1,50 @@
-INVITE sip:user@company.com SIP/2.0
-To: "I have a user name of extreme proportion" <sip:user@company.com:6000;other-param=1234567890somethingelselong1234567890>
-From: sip:caller@university.edu
-Call-ID: kl24ahsd546folnyt2vbak9sad98u23naodiunzds09a3bqw0sdfbsk34poouymnae0043nsed09mfkvc74bd0cuwnms05dknw87hjpobd76f
-CSeq: 1 INVITE
-My-State: sldkjflzdsfaret0803adgaasd0afds0asdaasd
-Via: SIP/2.0/UDP sip33.example.com
-Via: SIP/2.0/UDP sip32.example.com
-Via: SIP/2.0/UDP sip31.example.com
-Via: SIP/2.0/UDP sip30.example.com
-Via: SIP/2.0/UDP sip29.example.com
-Via: SIP/2.0/UDP sip28.example.com
-Via: SIP/2.0/UDP sip27.example.com
-Via: SIP/2.0/UDP sip26.example.com
-Via: SIP/2.0/UDP sip25.example.com
-Via: SIP/2.0/UDP sip24.example.com
-Via: SIP/2.0/UDP sip23.example.com
-Via: SIP/2.0/UDP sip22.example.com
-Via: SIP/2.0/UDP sip21.example.com
-Via: SIP/2.0/UDP sip20.example.com
-Via: SIP/2.0/UDP sip19.example.com
-Via: SIP/2.0/UDP sip18.example.com
-Via: SIP/2.0/UDP sip17.example.com
-Via: SIP/2.0/UDP sip16.example.com
-Via: SIP/2.0/UDP sip15.example.com
-Via: SIP/2.0/UDP sip14.example.com
-Via: SIP/2.0/UDP sip13.example.com
-Via: SIP/2.0/UDP sip12.example.com
-Via: SIP/2.0/UDP sip11.example.com
-Via: SIP/2.0/UDP sip10.example.com
-Via: SIP/2.0/UDP sip9.example.com
-Via: SIP/2.0/UDP sip8.example.com
-Via: SIP/2.0/UDP sip7.example.com
-Via: SIP/2.0/UDP sip6.example.com
-Via: SIP/2.0/UDP sip5.example.com
-Via: SIP/2.0/UDP sip4.example.com
-Via: SIP/2.0/UDP sip3.example.com
-Via: SIP/2.0/UDP sip2.example.com
-Via: SIP/2.0/UDP sip1.example.com
-Via: SIP/2.0/UDP host.example.com;received=135.180.130.133;branch=C1C3344E2710000000E299E568E7potato10potato0potato0
-Content-Type: application/sdp
-
-v=0
-o=mhandley 29739 7272939 IN IP4 126.5.4.3
-s=SIP Call
-t=3149328700 0
-c=IN IP4 135.180.130.88
-m=audio 492170 RTP/AVP 0 12
-m=video 3227 RTP/AVP 31
-a=rtpmap:31 LPC
-
-
+INVITE sip:user@company.com SIP/2.0
+To: "I have a user name of extreme proportion" <sip:user@company.com:6000;other-param=1234567890somethingelselong1234567890>
+From: sip:caller@university.edu
+Call-ID: kl24ahsd546folnyt2vbak9sad98u23naodiunzds09a3bqw0sdfbsk34poouymnae0043nsed09mfkvc74bd0cuwnms05dknw87hjpobd76f
+CSeq: 1 INVITE
+My-State: sldkjflzdsfaret0803adgaasd0afds0asdaasd
+Via: SIP/2.0/UDP sip33.example.com
+Via: SIP/2.0/UDP sip32.example.com
+Via: SIP/2.0/UDP sip31.example.com
+Via: SIP/2.0/UDP sip30.example.com
+Via: SIP/2.0/UDP sip29.example.com
+Via: SIP/2.0/UDP sip28.example.com
+Via: SIP/2.0/UDP sip27.example.com
+Via: SIP/2.0/UDP sip26.example.com
+Via: SIP/2.0/UDP sip25.example.com
+Via: SIP/2.0/UDP sip24.example.com
+Via: SIP/2.0/UDP sip23.example.com
+Via: SIP/2.0/UDP sip22.example.com
+Via: SIP/2.0/UDP sip21.example.com
+Via: SIP/2.0/UDP sip20.example.com
+Via: SIP/2.0/UDP sip19.example.com
+Via: SIP/2.0/UDP sip18.example.com
+Via: SIP/2.0/UDP sip17.example.com
+Via: SIP/2.0/UDP sip16.example.com
+Via: SIP/2.0/UDP sip15.example.com
+Via: SIP/2.0/UDP sip14.example.com
+Via: SIP/2.0/UDP sip13.example.com
+Via: SIP/2.0/UDP sip12.example.com
+Via: SIP/2.0/UDP sip11.example.com
+Via: SIP/2.0/UDP sip10.example.com
+Via: SIP/2.0/UDP sip9.example.com
+Via: SIP/2.0/UDP sip8.example.com
+Via: SIP/2.0/UDP sip7.example.com
+Via: SIP/2.0/UDP sip6.example.com
+Via: SIP/2.0/UDP sip5.example.com
+Via: SIP/2.0/UDP sip4.example.com
+Via: SIP/2.0/UDP sip3.example.com
+Via: SIP/2.0/UDP sip2.example.com
+Via: SIP/2.0/UDP sip1.example.com
+Via: SIP/2.0/UDP host.example.com;received=135.180.130.133;branch=C1C3344E2710000000E299E568E7potato10potato0potato0
+Content-Type: application/sdp
+
+v=0
+o=mhandley 29739 7272939 IN IP4 126.5.4.3
+s=SIP Call
+t=3149328700 0
+c=IN IP4 135.180.130.88
+m=audio 492170 RTP/AVP 0 12
+m=video 3227 RTP/AVP 31
+a=rtpmap:31 LPC
diff -ur a/libsofia-sip-ua/sip/tests/test35.txt b/libsofia-sip-ua/sip/tests/test35.txt
--- a/libsofia-sip-ua/sip/tests/test35.txt	2011-03-11 16:49:18.000000000 +0200
+++ b/libsofia-sip-ua/sip/tests/test35.txt	2017-12-07 23:26:01.504848951 +0200
@@ -1,16 +1,14 @@
-OPTIONS sip:135.180.130.133 SIP/2.0
-Via: SIP/2.0/UDP company.com:5604
-From: sip:iuser@company.com
-To: sip:user@135.180.130.133
-Call-ID: 1804928587@company.com
-CSeq: 1 OPTIONS
-Expires: 0 0l@company.com
-To: sip:user@135.180.130.133
-Call-ID: 1804928587@company.com
-CSeq: 1 OPTIONS
-Contact: sip:host.company.com
-Expires: 0xpires: 0sip:host.company.com
-Expires: 0
-Contact: sip:host.company.com
-
-
+OPTIONS sip:135.180.130.133 SIP/2.0
+Via: SIP/2.0/UDP company.com:5604
+From: sip:iuser@company.com
+To: sip:user@135.180.130.133
+Call-ID: 1804928587@company.com
+CSeq: 1 OPTIONS
+Expires: 0 0l@company.com
+To: sip:user@135.180.130.133
+Call-ID: 1804928587@company.com
+CSeq: 1 OPTIONS
+Contact: sip:host.company.com
+Expires: 0xpires: 0sip:host.company.com
+Expires: 0
+Contact: sip:host.company.com
diff -ur a/libsofia-sip-ua/sip/tests/test36.txt b/libsofia-sip-ua/sip/tests/test36.txt
--- a/libsofia-sip-ua/sip/tests/test36.txt	2011-03-11 16:49:18.000000000 +0200
+++ b/libsofia-sip-ua/sip/tests/test36.txt	2017-12-07 23:26:01.512848994 +0200
@@ -1,23 +1,23 @@
-INVITE sip:+1-972-555-2222;phone-context=name%40domain;new=user?%22Route%3a%20X%40Y%3bZ=W%22@gw1.wcom.com;user=phone SIP/2.0
-Via: SIP/2.0/UDP iftgw.there.com:5060
-From: sip:+1-303-555-1111@ift.here.com;user=phone
-To: sip:+1-650-555-2222@ss1.wcom.com;user=phone
-Call-ID: 1717@ift.here.com
-CSeq: 56 INVITE
-Content-Type: application/sdp
-Content-Length: 348
-
-v=0
-o=faxgw1 2890844527 2890844527 IN IP4 iftgw.there.com
-s=Session SDP
-c=IN IP4 iftmg.there.com
-t=0 0
-m=image 49172 udptl t38
-a=T38FaxVersion:0
-a=T38maxBitRate:14400
-a=T38FaxFillBitRemoval:0
-a=T38FaxTranscodingMMR:0
-a=T38FaxTranscodingJBIG:0
-a=T38FaxRateManagement:transferredTCF
-a=T38FaxMaxBuffer:260
-a=T38FaxUdpEC:t38UDPRedundancy
+INVITE sip:+1-972-555-2222;phone-context=name%40domain;new=user?%22Route%3a%20X%40Y%3bZ=W%22@gw1.wcom.com;user=phone SIP/2.0
+Via: SIP/2.0/UDP iftgw.there.com:5060
+From: sip:+1-303-555-1111@ift.here.com;user=phone
+To: sip:+1-650-555-2222@ss1.wcom.com;user=phone
+Call-ID: 1717@ift.here.com
+CSeq: 56 INVITE
+Content-Type: application/sdp
+Content-Length: 348
+
+v=0
+o=faxgw1 2890844527 2890844527 IN IP4 iftgw.there.com
+s=Session SDP
+c=IN IP4 iftmg.there.com
+t=0 0
+m=image 49172 udptl t38
+a=T38FaxVersion:0
+a=T38maxBitRate:14400
+a=T38FaxFillBitRemoval:0
+a=T38FaxTranscodingMMR:0
+a=T38FaxTranscodingJBIG:0
+a=T38FaxRateManagement:transferredTCF
+a=T38FaxMaxBuffer:260
+a=T38FaxUdpEC:t38UDPRedundancy
diff -ur a/libsofia-sip-ua/sip/tests/test37.txt b/libsofia-sip-ua/sip/tests/test37.txt
--- a/libsofia-sip-ua/sip/tests/test37.txt	2011-03-11 16:49:18.000000000 +0200
+++ b/libsofia-sip-ua/sip/tests/test37.txt	2017-12-07 23:26:01.520849038 +0200
@@ -1,9 +1,7 @@
-REGISTER sip:bell-tel.com SIP/2.0
-Via: SIP/2.0/UDP saturn.bell-tel.com
-From: sip:watson@bell-tel.com
-To: sip:watson@bell-tel.com
-Call-ID: 70710@saturn.bell-tel.com
-CSeq: 2 REGISTER
-Contact: sip:+1-972-555-2222@gw1.wcom.com;user=phone
-
-
+REGISTER sip:bell-tel.com SIP/2.0
+Via: SIP/2.0/UDP saturn.bell-tel.com
+From: sip:watson@bell-tel.com
+To: sip:watson@bell-tel.com
+Call-ID: 70710@saturn.bell-tel.com
+CSeq: 2 REGISTER
+Contact: sip:+1-972-555-2222@gw1.wcom.com;user=phone
diff -ur a/libsofia-sip-ua/sip/tests/test38.txt b/libsofia-sip-ua/sip/tests/test38.txt
--- a/libsofia-sip-ua/sip/tests/test38.txt	2011-03-11 16:49:18.000000000 +0200
+++ b/libsofia-sip-ua/sip/tests/test38.txt	2017-12-07 23:26:01.524849059 +0200
@@ -1,9 +1,7 @@
-REGISTER sip:bell-tel.com SIP/2.0
-Via: SIP/2.0/UDP saturn.bell-tel.com
-From: sip:watson@bell-tel.com
-To: sip:watson@bell-tel.com
-Call-ID: 70710@saturn.bell-tel.com
-CSeq: 3 REGISTER
-Contact: <sip:+1-972-555-2222@gw1.wcom.com;user=phone>
-
-
+REGISTER sip:bell-tel.com SIP/2.0
+Via: SIP/2.0/UDP saturn.bell-tel.com
+From: sip:watson@bell-tel.com
+To: sip:watson@bell-tel.com
+Call-ID: 70710@saturn.bell-tel.com
+CSeq: 3 REGISTER
+Contact: <sip:+1-972-555-2222@gw1.wcom.com;user=phone>
diff -ur a/libsofia-sip-ua/sip/tests/test39.txt b/libsofia-sip-ua/sip/tests/test39.txt
--- a/libsofia-sip-ua/sip/tests/test39.txt	2011-03-11 16:49:18.000000000 +0200
+++ b/libsofia-sip-ua/sip/tests/test39.txt	2017-12-07 23:26:01.528849081 +0200
@@ -1,8 +1,6 @@
-INVITE sip:t.watson@ieee.org SIP/2.0
-Via:     SIP/2.0/UDP c.bell-tel.com
-From:    A. Bell <sip:a.g.bell@bell-tel.com>
-To:      T. Watson <sip:t.watson@ieee.org>
-Call-ID: 31414@c.bell-tel.com
-CSeq:    1 INVITE
-
-
+INVITE sip:t.watson@ieee.org SIP/2.0
+Via:     SIP/2.0/UDP c.bell-tel.com
+From:    A. Bell <sip:a.g.bell@bell-tel.com>
+To:      T. Watson <sip:t.watson@ieee.org>
+Call-ID: 31414@c.bell-tel.com
+CSeq:    1 INVITE
diff -ur a/libsofia-sip-ua/sip/tests/test3.txt b/libsofia-sip-ua/sip/tests/test3.txt
--- a/libsofia-sip-ua/sip/tests/test3.txt	2011-03-11 16:49:18.000000000 +0200
+++ b/libsofia-sip-ua/sip/tests/test3.txt	2017-12-07 23:26:01.472848777 +0200
@@ -1,12 +1,12 @@
-INVITE sip:John_Smith@tct.hut.fi SIP/2.0
-To: isbn:2983792873
-From: http://www.cs.columbia.edu
-Call-ID: 0ha0isndaksdj@10.1.2.3
-CSeq : 8 INVITE
-Via: SIP/2.0/UDP 135.180.130.133
-Content-Type: application/sdp
-Contact: Joe Bob Briggs <urn:ipaddr:122.1.2.3>
-Content-Length: 138
+INVITE sip:John_Smith@tct.hut.fi SIP/2.0
+To: isbn:2983792873
+From: http://www.cs.columbia.edu
+Call-ID: 0ha0isndaksdj@10.1.2.3
+CSeq : 8 INVITE
+Via: SIP/2.0/UDP 135.180.130.133
+Content-Type: application/sdp
+Contact: Joe Bob Briggs <urn:ipaddr:122.1.2.3>
+Content-Length: 138
 
 v=0
 o=mhandley 29739 7272939 IN IP4 126.5.4.3
diff -ur a/libsofia-sip-ua/sip/tests/test40.txt b/libsofia-sip-ua/sip/tests/test40.txt
--- a/libsofia-sip-ua/sip/tests/test40.txt	2011-03-11 16:49:18.000000000 +0200
+++ b/libsofia-sip-ua/sip/tests/test40.txt	2017-12-07 23:26:01.540849146 +0200
@@ -1,8 +1,6 @@
-INVITE sip:t.watson@ieee.org SIP/2.0
-Via:     SIP/2.0/UDP c.bell-tel.com
-From:    Bell, Alexander <sip:a.g.bell@bell-tel.com>
-To:      Watson, Thomas <sip:t.watson@ieee.org>
-Call-ID: 31415@c.bell-tel.com
-CSeq:    1 INVITE
-
-
+INVITE sip:t.watson@ieee.org SIP/2.0
+Via:     SIP/2.0/UDP c.bell-tel.com
+From:    Bell, Alexander <sip:a.g.bell@bell-tel.com>
+To:      Watson, Thomas <sip:t.watson@ieee.org>
+Call-ID: 31415@c.bell-tel.com
+CSeq:    1 INVITE
diff -ur a/libsofia-sip-ua/sip/tests/test41.txt b/libsofia-sip-ua/sip/tests/test41.txt
--- a/libsofia-sip-ua/sip/tests/test41.txt	2011-03-11 16:49:18.000000000 +0200
+++ b/libsofia-sip-ua/sip/tests/test41.txt	2017-12-07 23:26:01.544849168 +0200
@@ -1,8 +1,7 @@
-INVITE sip:t.watson@ieee.org SIP/7.0
-Max-Forwards:     70
-Via:     SIP/2.0/UDP c.bell-tel.com
-From:    A. Bell <sip:a.g.bell@bell-tel.com>
-To:      T. Watson <sip:t.watson@ieee.org>
-Call-ID: 31416@c.bell-tel.com
-CSeq:    1 INVITE
-
+INVITE sip:t.watson@ieee.org SIP/7.0
+Max-Forwards:     70
+Via:     SIP/2.0/UDP c.bell-tel.com
+From:    A. Bell <sip:a.g.bell@bell-tel.com>
+To:      T. Watson <sip:t.watson@ieee.org>
+Call-ID: 31416@c.bell-tel.com
+CSeq:    1 INVITE
diff -ur a/libsofia-sip-ua/sip/tests/test42.txt b/libsofia-sip-ua/sip/tests/test42.txt
--- a/libsofia-sip-ua/sip/tests/test42.txt	2011-03-11 16:49:18.000000000 +0200
+++ b/libsofia-sip-ua/sip/tests/test42.txt	2017-12-07 23:26:01.548849190 +0200
@@ -1,11 +1,6 @@
-INVITE sip:t.watson@ieee.org SIP/7.0
-Via:     SIP/2.0/UDP c.bell-tel.com
-From:    A. Bell <sip:a.g.bell@bell-tel.com>
-To:      T. Watson <sip:t.watson@ieee.org>
-Call-ID: 31417@c.bell-tel.com
-CSeq:    1 INVITE
-
-
-
-
-
+INVITE sip:t.watson@ieee.org SIP/7.0
+Via:     SIP/2.0/UDP c.bell-tel.com
+From:    A. Bell <sip:a.g.bell@bell-tel.com>
+To:      T. Watson <sip:t.watson@ieee.org>
+Call-ID: 31417@c.bell-tel.com
+CSeq:    1 INVITE
diff -ur a/libsofia-sip-ua/sip/tests/test5.txt b/libsofia-sip-ua/sip/tests/test5.txt
--- a/libsofia-sip-ua/sip/tests/test5.txt	2011-03-11 16:49:18.000000000 +0200
+++ b/libsofia-sip-ua/sip/tests/test5.txt	2017-12-07 23:26:01.556849233 +0200
@@ -1,16 +1,16 @@
-INVITE sip:user@company.com SIP/2.0
-To: sip:j_user@company.com
-From: sip:caller@university.edu
-Call-ID: 0ha0isndaksdj@10.0.0.1
-Accept: text/newformat
-CSeq: 8 INVITE
-Via: SIP/2.0/UDP 135.180.130.133
-Content-Type: application/sdp
-
-v=0
-o=mhandley 29739 7272939 IN IP4 126.5.4.3
-c=IN IP4 135.180.130.88/127
-m=audio 492170 RTP/AVP 0 12
-m=video 3227 RTP/AVP 31
-b=CT:3455
-a=rtpmap:31 LPC
+INVITE sip:user@company.com SIP/2.0
+To: sip:j_user@company.com
+From: sip:caller@university.edu
+Call-ID: 0ha0isndaksdj@10.0.0.1
+Accept: text/newformat
+CSeq: 8 INVITE
+Via: SIP/2.0/UDP 135.180.130.133
+Content-Type: application/sdp
+
+v=0
+o=mhandley 29739 7272939 IN IP4 126.5.4.3
+c=IN IP4 135.180.130.88/127
+m=audio 492170 RTP/AVP 0 12
+m=video 3227 RTP/AVP 31
+b=CT:3455
+a=rtpmap:31 LPC
diff -ur a/libsofia-sip-ua/sip/tests/test8.txt b/libsofia-sip-ua/sip/tests/test8.txt
--- a/libsofia-sip-ua/sip/tests/test8.txt	2011-03-11 16:49:18.000000000 +0200
+++ b/libsofia-sip-ua/sip/tests/test8.txt	2017-12-07 23:26:01.568849298 +0200
@@ -1,15 +1,15 @@
-NEWMETHOD sip:user@comapny.com SIP/2.0
-To: sip:j.user@company.com
-From: sip:caller@university.edu;tag=34525
-Max-Forwards: 6
-Call-ID: 0ha0isndaksdj@10.0.1.1
-CSeq: 8 NEWMETHOD
-Via: SIP/2.0/UDP 135.180.130.133;branch=z9hG4bKkdjuw
-Content-Type: application/sdp
-
-v=0
-o=mhandley 29739 7272939 IN IP4 126.5.4.3
-c=IN IP4 135.180.130.88
-m=audio 492170 RTP/AVP 0 12
-m=video 3227 RTP/AVP 31
-a=rtpmap:31 LPC
+NEWMETHOD sip:user@comapny.com SIP/2.0
+To: sip:j.user@company.com
+From: sip:caller@university.edu;tag=34525
+Max-Forwards: 6
+Call-ID: 0ha0isndaksdj@10.0.1.1
+CSeq: 8 NEWMETHOD
+Via: SIP/2.0/UDP 135.180.130.133;branch=z9hG4bKkdjuw
+Content-Type: application/sdp
+
+v=0
+o=mhandley 29739 7272939 IN IP4 126.5.4.3
+c=IN IP4 135.180.130.88
+m=audio 492170 RTP/AVP 0 12
+m=video 3227 RTP/AVP 31
+a=rtpmap:31 LPC
diff -ur a/libsofia-sip-ua/soa/Makefile.am b/libsofia-sip-ua/soa/Makefile.am
--- a/libsofia-sip-ua/soa/Makefile.am	2011-03-11 16:49:18.000000000 +0200
+++ b/libsofia-sip-ua/soa/Makefile.am	2017-12-07 23:26:00.084841249 +0200
@@ -8,7 +8,7 @@
 # ----------------------------------------------------------------------
 # Header paths
 
-INCLUDES = 		-I$(srcdir)/../sdp -I../sdp \
+AM_CPPFLAGS = 		-I$(srcdir)/../sdp -I../sdp \
 			-I$(srcdir)/../sip -I../sip \
 			-I$(srcdir)/../msg -I../msg \
 			-I$(srcdir)/../url -I../url \
@@ -40,7 +40,8 @@
 
 COVERAGE_INPUT = 	$(libsoa_la_SOURCES) $(include_sofia_HEADERS)
 
-LDADD = 		libsoa.la \
+test_soa_LDADD = 	$(top_builddir)/s2check/libs2.a \
+			libsoa.la \
 			../sip/libsip.la \
 			../msg/libmsg.la \
 			../url/liburl.la \
@@ -49,9 +50,6 @@
 			../bnf/libbnf.la \
 			../su/libsu.la
 
-test_soa_LDADD = 	$(top_builddir)/s2check/libs2.a \
-			$(LDADD)
-
 test_soa_LDFLAGS = 	-static
 
 # ----------------------------------------------------------------------
@@ -62,6 +60,7 @@
 # ----------------------------------------------------------------------
 # Sofia specific rules
 
+LDADD = 
 include $(top_srcdir)/rules/sofia.am
 
 TAG_DLL_FLAGS =		LIST=soa_tag_list
diff -ur a/libsofia-sip-ua/soa/soa.c b/libsofia-sip-ua/soa/soa.c
--- a/libsofia-sip-ua/soa/soa.c	2011-03-11 16:49:18.000000000 +0200
+++ b/libsofia-sip-ua/soa/soa.c	2017-12-07 23:26:00.084841249 +0200
@@ -56,7 +56,11 @@
 #include <sofia-sip/su_string.h>
 #include <sofia-sip/su_errno.h>
 
+#ifndef _MSC_VER
 #define NONE ((void *)-1)
+#else
+#define NONE ((void *)(INT_PTR)-1)
+#endif
 #define XXX assert(!"implemented")
 
 typedef unsigned longlong ull;
@@ -71,8 +75,6 @@
 /* ======================================================================== */
 
 /* Internal prototypes */
-su_inline int soa_media_is_ready(soa_session_t const *ss);
-
 enum soa_sdp_kind {
   soa_capability_sdp_kind,
   soa_user_sdp_kind,
@@ -389,9 +391,8 @@
  * SOATAG_RTP_SORT(),
  * SOATAG_RTP_MISMATCH(),
  * SOATAG_SRTP_ENABLE(),
- * SOATAG_SRTP_CONFIDENTIALITY(),
- * SOATAG_SRTP_INTEGRITY(), and
- * SOATAG_DELAYED_OFFER_ENABLE().
+ * SOATAG_SRTP_CONFIDENTIALITY(), and
+ * SOATAG_SRTP_INTEGRITY().
  */
 int soa_set_params(soa_session_t *ss, tag_type_t tag, tag_value_t value, ...)
 {
@@ -435,9 +436,8 @@
  * SOATAG_RTP_SORT(),
  * SOATAG_RTP_MISMATCH(),
  * SOATAG_SRTP_ENABLE(),
- * SOATAG_SRTP_CONFIDENTIALITY(),
- * SOATAG_SRTP_INTEGRITY(), and
- * SOATAG_DELAYED_OFFER_ENABLE().
+ * SOATAG_SRTP_CONFIDENTIALITY(), and
+ * SOATAG_SRTP_INTEGRITY().
  */
 int soa_base_set_params(soa_session_t *ss, tagi_t const *tags)
 {
@@ -451,7 +451,6 @@
   int rtp_select, rtp_sort;
   int rtp_mismatch;
   int srtp_enable, srtp_confidentiality, srtp_integrity;
-  int delayed_offer_enable;
 
   af = ss->ss_af;
 
@@ -466,8 +465,6 @@
   srtp_confidentiality = ss->ss_srtp_confidentiality;
   srtp_integrity = ss->ss_srtp_integrity;
 
-  delayed_offer_enable = ss->ss_delayed_offer_enable;
-
   caps_sdp = user_sdp = NONE;
   caps_sdp_str = user_sdp_str = NONE;
 
@@ -491,8 +488,6 @@
 	      SOATAG_SRTP_CONFIDENTIALITY_REF(srtp_confidentiality),
 	      SOATAG_SRTP_INTEGRITY_REF(srtp_integrity),
 
-	      SOATAG_DELAYED_OFFER_ENABLE_REF(delayed_offer_enable),
-
 	      TAG_END());
 
   if (n <= 0)
@@ -541,8 +536,6 @@
   srtp_confidentiality = srtp_confidentiality != 0;
   srtp_integrity = srtp_integrity != 0;
 
-  delayed_offer_enable = delayed_offer_enable != 0;
-
   change_session
     =  af != (int)ss->ss_af
     || rtp_select != (int)ss->ss_rtp_select
@@ -551,7 +544,6 @@
     || srtp_enable != (int)ss->ss_srtp_enable
     || srtp_confidentiality != (int)ss->ss_srtp_confidentiality
     || srtp_integrity != (int)ss->ss_srtp_integrity
-    || delayed_offer_enable != (int)ss->ss_delayed_offer_enable
     ;
 
   ss->ss_af = (enum soa_af)af;
@@ -564,11 +556,10 @@
   ss->ss_srtp_confidentiality = srtp_confidentiality;
   ss->ss_srtp_integrity = srtp_integrity;
 
-  ss->ss_delayed_offer_enable = delayed_offer_enable;
-
   if (!su_casematch(media_address, ss->ss_address)) {
-    su_free(ss->ss_home, (void *)ss->ss_address);
+    char const *addr = ss->ss_address;
     ss->ss_address = su_strdup(ss->ss_home, media_address);
+    su_free(ss->ss_home, (void *)addr);
     change_session = 1;
   }
 
@@ -576,8 +567,9 @@
     hold = "*";
 
   if (!su_casematch(hold, ss->ss_hold)) {
-    su_free(ss->ss_home, (void *)ss->ss_hold);
+    char const *h = ss->ss_hold;
     ss->ss_hold = su_strdup(ss->ss_home, hold);
+    su_free(ss->ss_home, (void *)h);
     change_session = 1;
   }
 
@@ -659,9 +651,8 @@
  * SOATAG_RTP_SORT(),
  * SOATAG_RTP_MISMATCH(),
  * SOATAG_SRTP_ENABLE(),
- * SOATAG_SRTP_CONFIDENTIALITY(),
- * SOATAG_SRTP_INTEGRITY(), and
- * SOATAG_DELAYED_OFFER_ENABLE().
+ * SOATAG_SRTP_CONFIDENTIALITY(), and
+ * SOATAG_SRTP_INTEGRITY().
  */
 int soa_base_get_params(soa_session_t const *ss, tagi_t *tags)
 {
@@ -692,8 +683,6 @@
 	       SOATAG_SRTP_CONFIDENTIALITY(ss->ss_srtp_confidentiality),
 	       SOATAG_SRTP_INTEGRITY(ss->ss_srtp_integrity),
 
-	       SOATAG_DELAYED_OFFER_ENABLE(ss->ss_delayed_offer_enable),
-
 	       TAG_END());
 
   return n;
@@ -1889,12 +1878,6 @@
   return ma;
 }
 
-/** Return true if delayed offer has been activated. */
-int soa_is_delayed_offer(soa_session_t const *ss)
-{
-  return ss ? ss->ss_delayed_offer_enable : 0;
-}
-
 /* ======================================================================== */
 /* Methods used by soa instances */
 
@@ -1914,14 +1897,6 @@
   return -1;
 }
 
-su_inline
-int soa_media_is_ready(soa_session_t const *ss)
-{
-  XXX;
-  return 0;
-  /* return ss && ss->ss_session != NULL; */
-}
-
 void soa_set_activity(soa_session_t *ss,
 		      sdp_media_t const *m,
 		      enum soa_activity activity)
diff -ur a/libsofia-sip-ua/soa/soa_static.c b/libsofia-sip-ua/soa/soa_static.c
--- a/libsofia-sip-ua/soa/soa_static.c	2011-03-11 16:49:18.000000000 +0200
+++ b/libsofia-sip-ua/soa/soa_static.c	2017-12-07 23:26:00.092841293 +0200
@@ -396,7 +396,11 @@
   return NULL;
 }
 
+#ifndef _MSC_VER
 #define SDP_MEDIA_NONE ((sdp_media_t *)-1)
+#else
+#define SDP_MEDIA_NONE ((sdp_media_t *)(INT_PTR)-1)
+#endif
 
 /** Find first matching media in table @a mm.
  *
@@ -483,11 +487,14 @@
     /* XXX - do fmtp comparison */
 
     if (rrm) {
+#if 0
       /* Use same payload type as remote */
       if (lrm->rm_pt != rrm->rm_pt) {
-	lrm->rm_predef = 0;
-	lrm->rm_pt = rrm->rm_pt;
+		  lrm->rm_predef = 0;
+		  lrm->rm_pt = rrm->rm_pt;
+
       }
+#endif
       common_codecs++;
     }
     else {
@@ -725,10 +732,19 @@
   if (session == NULL || user == NULL)
     return (errno = EFAULT), -1;
 
+#ifdef __clang__
+#pragma clang diagnostic push
+#pragma clang diagnostic ignored "-Wnon-literal-null-conversion"
+#endif
+
   Ns = sdp_media_count(session, sdp_media_any, (sdp_text_t)0, (sdp_proto_e)0, (sdp_text_t)0);
   Nu = sdp_media_count(user, sdp_media_any, (sdp_text_t)0, (sdp_proto_e)0, (sdp_text_t)0);
   Nr = sdp_media_count(remote, sdp_media_any, (sdp_text_t)0, (sdp_proto_e)0, (sdp_text_t)0);
 
+#ifdef __clang__
+#pragma clang diagnostic pop
+#endif
+
   if (remote == NULL)
     Nmax = Ns + Nu;
   else if (Ns < Nr)
@@ -778,7 +794,8 @@
 	continue;
       if (j >= Nu) /* lines removed from user SDP */
 	continue;
-      assert(i < Ns);
+	  if (i >= Ns) /* I should never be called but somehow i and Ns are 0 here sometimes */
+    continue;
       s_media[i] = u_media[j], u_media[j] = SDP_MEDIA_NONE;
       u2s[j] = i, s2u[i] = j;
     }
@@ -1005,7 +1022,6 @@
   int retval = 0, i, j;
   int hold_all;
   int inactive_all;
-  int inactive = 0;
   char const *hold_media = NULL;
   sdp_mode_t send_mode, recv_mode;
 
@@ -1024,35 +1040,39 @@
 
   for (sm = session->sdp_media; sm; sm = sm->m_next, rm = rm_next, i++) {
     rm_next = rm ? rm->m_next : NULL;
-    inactive = 0;
 
     if (sm->m_rejected)
       continue;
 
     assert(s2u);
 
-    for (j = 0, um = user->sdp_media; j != s2u[i]; um = um->m_next, j++)
-      assert(um);
+    for (j = 0, um = user->sdp_media; j != s2u[i]; um = um->m_next, j++) {
+		if (!um) break;
+	}
+
     if (um == NULL) {
       if (dryrun)
-	return 1;
+		  return 1;
       else
-	retval = 1;
+		  retval = 1;
       sm->m_rejected = 1;
       sm->m_mode = sdp_inactive;
       sm->m_port = 0;
       continue;
     }
 
-    send_mode = (sdp_mode_t)(um->m_mode & sdp_sendonly);
-    if (rm)
-      send_mode = (rm->m_mode & sdp_recvonly) ? send_mode : 0;
+	if (um->m_mode) { /* when its inactive, keep it inactive */
+		send_mode = (sdp_mode_t)(um->m_mode & sdp_sendonly);
+		if (rm)
+			send_mode = (rm->m_mode & sdp_recvonly) ? sdp_sendonly : 0;
+	} else send_mode = um->m_mode;
 
     recv_mode = (sdp_mode_t)(um->m_mode & sdp_recvonly);
-    if (rm)
-      recv_mode = (rm->m_mode & sdp_sendonly) ? recv_mode : 0;
 
-    if (inactive_all) {
+    if (rm && rm->m_mode == sdp_inactive) {
+      send_mode = recv_mode = (sdp_mode_t)0;
+    }
+    else if (inactive_all) {
       send_mode = recv_mode = (sdp_mode_t)0;
     }
     else if (hold_all) {
@@ -1135,6 +1155,11 @@
   else if (remote == NULL)
     return soa_set_status(ss, 500, "No remote SDP");
 
+#ifdef __clang__
+#pragma clang diagnostic push
+#pragma clang diagnostic ignored "-Wnon-literal-null-conversion"
+#endif
+
   /* Pre-negotiation Step: Expand truncated remote SDP */
   if (local && remote) switch (action) {
   case generate_answer:
@@ -1151,6 +1176,11 @@
     break;
   }
 
+#ifdef __clang__
+#pragma clang diagnostic pop
+#endif
+
+
   /* Step A: Create local SDP session (based on user-supplied SDP) */
   if (local == NULL) switch (action) {
   case generate_offer:
@@ -1287,9 +1317,21 @@
 
   /* Step F0: Initialize o= line */
   if (fresh) {
-    if (user->sdp_origin)
+	if (user->sdp_origin) {
       o->o_username = user->sdp_origin->o_username;
 
+	  if (user->sdp_origin->o_address)
+	    o->o_address = user->sdp_origin->o_address;
+
+      if (user->sdp_origin->o_id)
+		  o->o_id = user->sdp_origin->o_id;
+
+	  if (user->sdp_origin->o_version && user->sdp_origin->o_version != o->o_version) {
+		  o->o_version = user->sdp_origin->o_version;
+		  o->o_version--;
+	  }
+	}
+
     if (soa_init_sdp_origin_with_session(ss, o, c0_buffer, local) < 0) {
       phrase = "Cannot Get IP Address for Session Description";
       goto internal_error;
@@ -1507,27 +1549,21 @@
 {
   soa_static_session_t *sss = (soa_static_session_t *)ss;
   struct soa_description d[1];
-  int *u2s, *s2u;
 
   soa_base_process_reject(ss, NULL);
 
   *d = *ss->ss_local;
-  u2s = sss->sss_u2s, s2u = sss->sss_s2u;
-
   *ss->ss_local = *ss->ss_previous;
   ss->ss_local_user_version = ss->ss_previous_user_version;
   ss->ss_local_remote_version = ss->ss_previous_remote_version;
-  sss->sss_u2s = sss->sss_previous.u2s;
-  sss->sss_s2u = sss->sss_previous.s2u;
 
   memset(ss->ss_previous, 0, (sizeof *ss->ss_previous));
-  memset(&sss->sss_previous, 0, (sizeof sss->sss_previous));
   soa_description_free(ss, d);
+  su_free(ss->ss_home, sss->sss_previous.u2s), sss->sss_previous.u2s = NULL;
+  su_free(ss->ss_home, sss->sss_previous.s2u), sss->sss_previous.s2u = NULL;
   ss->ss_previous_user_version = 0;
   ss->ss_previous_remote_version = 0;
 
-  su_free(ss->ss_home, u2s);
-  su_free(ss->ss_home, s2u);
   su_free(ss->ss_home, sss->sss_latest), sss->sss_latest = NULL;
 
   return 0;
diff -ur a/libsofia-sip-ua/soa/soa_tag.c b/libsofia-sip-ua/soa/soa_tag.c
--- a/libsofia-sip-ua/soa/soa_tag.c	2011-03-11 16:49:18.000000000 +0200
+++ b/libsofia-sip-ua/soa/soa_tag.c	2017-12-07 23:26:00.100841336 +0200
@@ -647,23 +647,3 @@
 tag_typedef_t soatag_ordered_user = BOOLTAG_TYPEDEF(ordered_user);
 
 tag_typedef_t soatag_reuse_rejected = BOOLTAG_TYPEDEF(reuse_rejected);
-
-/**@def SOATAG_DELAYED_OFFER_ENABLE(x)
- *
- * Enable delayed offer
- *
- * @par Used with
- *    soa_set_params(), soa_get_params(), soa_get_paramlist() \n
- *
- * @par Parameter type
- *    boolean (int)
- *
- * @par Values
- *    @c !=0 enable \n
- *    @c 0 disable
- *
- * Corresponding tag taking reference parameter is
- * SOATAG_DELAYED_OFFER_ENABLE_REF()
- *
- */
-tag_typedef_t soatag_delayed_offer_enable = BOOLTAG_TYPEDEF(delayed_offer_enable);
diff -ur a/libsofia-sip-ua/soa/sofia-sip/soa.h b/libsofia-sip-ua/soa/sofia-sip/soa.h
--- a/libsofia-sip-ua/soa/sofia-sip/soa.h	2011-03-11 16:49:18.000000000 +0200
+++ b/libsofia-sip-ua/soa/sofia-sip/soa.h	2017-12-07 23:26:01.584849385 +0200
@@ -146,8 +146,6 @@
 SOFIAPUBFUN int soa_is_remote_image_active(soa_session_t const *ss);
 SOFIAPUBFUN int soa_is_remote_chat_active(soa_session_t const *ss);
 
-SOFIAPUBFUN int soa_is_delayed_offer(soa_session_t const *ss);
-
 SOFIAPUBFUN int soa_tag_filter(tagi_t const *f, tagi_t const *t);
 
 SOFIA_END_DECLS
diff -ur a/libsofia-sip-ua/soa/sofia-sip/soa_session.h b/libsofia-sip-ua/soa/sofia-sip/soa_session.h
--- a/libsofia-sip-ua/soa/sofia-sip/soa_session.h	2011-03-11 16:49:18.000000000 +0200
+++ b/libsofia-sip-ua/soa/sofia-sip/soa_session.h	2017-12-07 23:26:01.588849406 +0200
@@ -225,8 +225,6 @@
     ss_srtp_confidentiality:1,
     ss_srtp_integrity:1;
 
-  unsigned  ss_delayed_offer_enable:1;
-
   unsigned :0;			/* Pad */
 
   int             ss_wcode;	/**< Warning code from last media operation */
diff -ur a/libsofia-sip-ua/soa/sofia-sip/soa_tag.h b/libsofia-sip-ua/soa/sofia-sip/soa_tag.h
--- a/libsofia-sip-ua/soa/sofia-sip/soa_tag.h	2011-03-11 16:49:18.000000000 +0200
+++ b/libsofia-sip-ua/soa/sofia-sip/soa_tag.h	2017-12-07 23:26:01.596849450 +0200
@@ -72,6 +72,18 @@
  * soa_get_params() or soa_get_paramlist()
  */
 
+#define SOATAG_LOCAL_SDP(x)  soatag_local_sdp, sdptag_session_v(x)
+SOFIAPUBVAR tag_typedef_t soatag_local_sdp;
+#define SOATAG_LOCAL_SDP_REF(x) \
+  soatag_local_sdp_ref, sdptag_session_vr(&(x))
+SOFIAPUBVAR tag_typedef_t soatag_local_sdp_ref;
+
+#define SOATAG_LOCAL_SDP_STR(x)  soatag_local_sdp_str, tag_str_v(x)
+SOFIAPUBVAR tag_typedef_t soatag_local_sdp_str;
+#define SOATAG_LOCAL_SDP_STR_REF(x) \
+  soatag_local_sdp_str_ref, tag_str_vr(&(x))
+SOFIAPUBVAR tag_typedef_t soatag_local_sdp_str_ref;
+
 #define SOATAG_USER_SDP(x)  soatag_user_sdp, sdptag_session_v(x)
 SOFIAPUBVAR tag_typedef_t soatag_user_sdp;
 #define SOATAG_USER_SDP_REF(x) \
@@ -246,12 +258,6 @@
   soatag_reuse_rejected_ref, tag_bool_vr(&(x))
 SOFIAPUBVAR tag_typedef_t soatag_reuse_rejected_ref;
 
-#define SOATAG_DELAYED_OFFER_ENABLE(x)  soatag_delayed_offer_enable, tag_bool_v(x)
-SOFIAPUBVAR tag_typedef_t soatag_delayed_offer_enable;
-
-#define SOATAG_DELAYED_OFFER_ENABLE_REF(x) soatag_delayed_offer_enable_ref, tag_bool_vr(&(x))
-SOFIAPUBVAR tag_typedef_t soatag_delayed_offer_enable_ref;
-
 SOFIA_END_DECLS
 
 #endif /* SOA_TAG_H */
diff -ur a/libsofia-sip-ua/soa/test_soa.c b/libsofia-sip-ua/soa/test_soa.c
--- a/libsofia-sip-ua/soa/test_soa.c	2011-03-11 16:49:18.000000000 +0200
+++ b/libsofia-sip-ua/soa/test_soa.c	2017-12-07 23:26:00.108841380 +0200
@@ -339,7 +339,6 @@
   int rtp_select, rtp_sort;
   int rtp_mismatch;
   int srtp_enable, srtp_confidentiality, srtp_integrity;
-  int delayed_offer_enable;
   soa_session_t *a = ctx->a, *b = ctx->b;
 
   n = soa_set_params(a, TAG_END()); TEST(n, 0);
@@ -351,7 +350,6 @@
 
   rtp_select = -1, rtp_sort = -1, rtp_mismatch = -1;
   srtp_enable = -1, srtp_confidentiality = -1, srtp_integrity = -1;
-  delayed_offer_enable = -1;
 
   TEST(soa_get_params(a,
 		      SOATAG_AF_REF(af),
@@ -365,11 +363,8 @@
 		      SOATAG_SRTP_ENABLE_REF(srtp_enable),
 		      SOATAG_SRTP_CONFIDENTIALITY_REF(srtp_confidentiality),
 		      SOATAG_SRTP_INTEGRITY_REF(srtp_integrity),
-
-		      SOATAG_DELAYED_OFFER_ENABLE_REF(delayed_offer_enable),
-
 		      TAG_END()),
-       10);
+       9);
   TEST(af, SOA_AF_ANY);
   TEST_P(address, 0);
   TEST_P(hold, 0);
@@ -378,9 +373,7 @@
   TEST(rtp_mismatch, 0);
   TEST(srtp_enable, 0);
   TEST(srtp_confidentiality, 0);
-  TEST(rtp_mismatch, 0);
   TEST(srtp_integrity, 0);
-  TEST(delayed_offer_enable, 0);
 
   TEST(soa_set_params(a,
 		      SOATAG_AF(SOA_AF_IP4_IP6),
@@ -395,10 +388,8 @@
 		      SOATAG_SRTP_CONFIDENTIALITY(1),
 		      SOATAG_SRTP_INTEGRITY(1),
 
-		      SOATAG_DELAYED_OFFER_ENABLE(1),
-
 		      TAG_END()),
-       10);
+       9);
   TEST(soa_get_params(a,
 		      SOATAG_AF_REF(af),
 		      SOATAG_ADDRESS_REF(address),
@@ -411,11 +402,8 @@
 		      SOATAG_SRTP_ENABLE_REF(srtp_enable),
 		      SOATAG_SRTP_CONFIDENTIALITY_REF(srtp_confidentiality),
 		      SOATAG_SRTP_INTEGRITY_REF(srtp_integrity),
-
-		      SOATAG_DELAYED_OFFER_ENABLE_REF(delayed_offer_enable),
-
 		      TAG_END()),
-       10);
+       9);
   TEST(af, SOA_AF_IP4_IP6);
   TEST_S(address, "127.0.0.1");
   TEST_S(hold, "audio");
@@ -425,7 +413,6 @@
   TEST(srtp_enable, 1);
   TEST(srtp_confidentiality, 1);
   TEST(srtp_integrity, 1);
-  TEST(delayed_offer_enable, 1);
 
   /* Restore defaults */
   TEST(soa_set_params(a,
@@ -441,10 +428,8 @@
 		      SOATAG_SRTP_CONFIDENTIALITY(0),
 		      SOATAG_SRTP_INTEGRITY(0),
 
-		      SOATAG_DELAYED_OFFER_ENABLE(0),
-
 		      TAG_END()),
-       10);
+       9);
 
   END();
 }
@@ -1314,42 +1299,17 @@
 
   char const a_caps[] = "m=audio 5008 RTP/AVP 0 8\r\n";
   char const b_caps[] = "m=audio 5004 RTP/AVP 8 0\n";
-  char const b_recvonly[] = "m=audio 5004 RTP/AVP 8 0\na=recvonly\n";
 
   TEST_1(a = soa_clone(ctx->a, ctx->root, ctx));
   TEST_1(b = soa_clone(ctx->b, ctx->root, ctx));
 
   TEST(soa_set_user_sdp(a, 0, a_caps, -1), 1);
-  TEST(soa_set_user_sdp(b, 0, b_recvonly, -1), 1);
-
-  n = soa_generate_offer(a, 1, test_completed); TEST(n, 0);
-  n = soa_get_local_sdp(a, NULL, &offer, &offerlen); TEST(n, 1);
-  TEST_1(offer != NULL && offer != NONE);
-
-  n = soa_set_remote_sdp(b, 0, offer, offerlen); TEST(n, 1);
-  n = soa_generate_answer(b, test_completed); TEST(n, 0);
-  TEST_1(soa_is_complete(b));
-  TEST(soa_activate(b, NULL), 0);
-
-  n = soa_get_local_sdp(b, NULL, &answer, &answerlen); TEST(n, 1);
-  TEST_1(answer != NULL && answer != NONE);
-
-  n = soa_set_remote_sdp(a, 0, answer, -1); TEST(n, 1);
-  n = soa_process_answer(a, test_completed); TEST(n, 0);
-  TEST_1(soa_is_complete(a));
-  TEST(soa_activate(a, NULL), 0);
-
-  TEST(soa_is_audio_active(a), SOA_ACTIVE_SENDONLY);
-  TEST(soa_is_remote_audio_active(a), SOA_ACTIVE_SENDONLY);
-
-  /* Put B as sendrecv */
+  TEST(soa_set_user_sdp(b, 0, b_caps, -1), 1);
 
   n = soa_generate_offer(a, 1, test_completed); TEST(n, 0);
   n = soa_get_local_sdp(a, NULL, &offer, &offerlen); TEST(n, 1);
   TEST_1(offer != NULL && offer != NONE);
 
-  TEST(soa_set_user_sdp(b, 0, b_caps, -1), 1);
-
   n = soa_set_remote_sdp(b, 0, offer, offerlen); TEST(n, 1);
   n = soa_generate_answer(b, test_completed); TEST(n, 0);
   TEST_1(soa_is_complete(b));
@@ -1985,13 +1945,6 @@
   n = soa_generate_offer(a, 1, test_completed); TEST(n, 0);
   n = soa_get_local_sdp(a, NULL, &offer, &offerlen); TEST(n, 1);
   TEST_1(offer != NULL && offer != NONE);
-
-  soa_process_reject(a, test_completed);
-
-  n = soa_generate_offer(a, 1, test_completed); TEST(n, 0);
-  n = soa_get_local_sdp(a, NULL, &offer, &offerlen); TEST(n, 1);
-  TEST_1(offer != NULL && offer != NONE);
-
   /* printf("offer1: %s\n", offer); */
   n = soa_set_remote_sdp(b, 0, offer, offerlen); TEST(n, 1);
   n = soa_get_local_sdp(b, NULL, &answer, &answerlen); TEST(n, 0);
diff -ur a/libsofia-sip-ua/sresolv/Makefile.am b/libsofia-sip-ua/sresolv/Makefile.am
--- a/libsofia-sip-ua/sresolv/Makefile.am	2011-03-11 16:49:18.000000000 +0200
+++ b/libsofia-sip-ua/sresolv/Makefile.am	2017-12-07 23:26:00.148841597 +0200
@@ -8,7 +8,7 @@
 # ----------------------------------------------------------------------
 # Header paths
 
-INCLUDES = 		-I$(srcdir)/../url -I../url \
+AM_CPPFLAGS = 		-I$(srcdir)/../url -I../url \
 			-I$(srcdir)/../bnf -I../bnf \
 			-I$(srcdir)/../su -I../su
 
@@ -21,13 +21,10 @@
 
 TESTS =
 
-if HAVE_CHECK
 check_PROGRAMS +=	check_sres_sip
 TESTS +=		check_sres_sip
-
 check_sres_sip_LDADD = 	$(LDADD) ${top_builddir}/s2check/libs2.a @CHECK_LIBS@
-INCLUDES +=		-I${top_srcdir}/s2check
-endif
+AM_CPPFLAGS +=		-I${top_srcdir}/s2check
 
 TESTS += 		torture_sresolv run_test_sresolv
 
@@ -61,7 +58,7 @@
 # ----------------------------------------------------------------------
 # Distribution
 
-EXTRA_DIST =		sresolv.docs check_sres_sip.c
+EXTRA_DIST =		sresolv.docs
 
 dist_noinst_DATA = run_test_sresolv \
 	root.zone rndc.conf \
diff -ur a/libsofia-sip-ua/sresolv/run_test_sresolv b/libsofia-sip-ua/sresolv/run_test_sresolv
--- a/libsofia-sip-ua/sresolv/run_test_sresolv	2011-03-11 16:49:18.000000000 +0200
+++ b/libsofia-sip-ua/sresolv/run_test_sresolv	2017-12-07 23:26:00.164841684 +0200
@@ -97,7 +97,7 @@
 nameserver fe80::10:c6ff:fee3:da7f
 
 # This is bind we set up
-nameserver $ns # with comment
+nameserver $ns
 
 domain example.com
 
diff -ur a/libsofia-sip-ua/sresolv/sres.c b/libsofia-sip-ua/sresolv/sres.c
--- a/libsofia-sip-ua/sresolv/sres.c	2011-03-11 16:49:18.000000000 +0200
+++ b/libsofia-sip-ua/sresolv/sres.c	2017-12-07 23:26:00.172841727 +0200
@@ -125,7 +125,7 @@
 ssize_t sres_recvfrom(sres_socket_t s, void *buffer, size_t length, int flags,
 		      struct sockaddr *from, socklen_t *fromlen)
 {
-  int retval, ilen;
+  int retval, ilen = 0;
 
   if (fromlen)
     ilen = *fromlen;
@@ -484,8 +484,8 @@
 void sres_query_report_error(sres_query_t *q,
 			     sres_record_t **answers);
 
-static int sres_resend_dns_query(sres_resolver_t *res,
-				 sres_query_t *q, int timeout);
+static void
+sres_resend_dns_query(sres_resolver_t *res, sres_query_t *q, int timeout);
 
 static
 sres_server_t *sres_server_by_socket(sres_resolver_t const *ts,
@@ -1372,7 +1372,7 @@
     return NULL;
 
   if (!sres_cache_get(res->res_cache, type, name, &result))
-    su_seterrno(ENOENT), (void *)NULL;
+    return su_seterrno(ENOENT), (void *)NULL;
 
   return result;
 }
@@ -1705,9 +1705,18 @@
     res->res_updcb(res->res_async, INVALID_SOCKET, INVALID_SOCKET);
 }
 
+#ifdef __clang__
+#pragma clang diagnostic push
+#pragma clang diagnostic ignored "-Wunused-function"
+#endif
+
 HTABLE_BODIES_WITH(sres_qtable, qt, sres_query_t, SRES_QUERY_HASH,
 		   unsigned, size_t);
 
+#ifdef __clang__
+#pragma clang diagnostic pop
+#endif
+
 /** Allocate a query structure */
 static
 sres_query_t *
@@ -2283,7 +2292,7 @@
       b = buf + strspn(buf, " \t");
 
       /* ... and comments + whitespace at the end */
-      for (len = strcspn(b, "#;"); len && strchr(" \t\r\n", b[len - 1]); len--)
+      for (len = strcspn(b, "#;"); len > 0 && strchr(" \t\r\n", b[len - 1]); len--)
 	;
 
       if (len == 0) 	/* Empty line or comment */
@@ -3021,10 +3030,10 @@
       if (now < retry_time)
 	continue;
 
-      if (sres_resend_dns_query(res, q, 1) < 0) {
-	sres_query_report_error(q, NULL);
+      sres_resend_dns_query(res, q, 1);
+
+      if (q != res->res_queries->qt_table[i])
 	i--;
-      }
     }
 
     if (res->res_schedulecb && res->res_queries->qt_used)
@@ -3034,17 +3043,14 @@
   sres_cache_clean(res->res_cache, res->res_now);
 }
 
-/** Resend DNS query.
+/** Resend DNS query, report error if cannot resend any more.
  *
  * @param res  resolver object
  * @param q    query object
  * @param timeout  true if resent because of timeout
  *                (false if because icmp error report)
- *
- * @return -1 if cannot resend any more.
- * @return 0  if query is still active
  */
-static int
+static void
 sres_resend_dns_query(sres_resolver_t *res, sres_query_t *q, int timeout)
 {
   uint8_t i, N;
@@ -3071,7 +3077,7 @@
       if (timeout)
 	q->q_retry_count++;
 
-      return 0;
+      return;
     }
   }
 
@@ -3079,9 +3085,9 @@
   q->q_id = 0;
 
   if (q->q_n_subs)
-    return 0;			/* let subqueries also timeout */
+    return;			/* let subqueries also timeout */
 
-  return -1;
+  sres_query_report_error(q, NULL);
 }
 
 static void
@@ -3430,10 +3436,10 @@
 	  continue;
 
 	/* Resend query/report error to application */
-	if (sres_resend_dns_query(res, q, 1) < 0) {
-	  sres_query_report_error(q, NULL);
+	sres_resend_dns_query(res, q, 0);
+
+	if (q != res->res_queries->qt_table[i])
 	  i--;
-	}
       }
     }
   }
@@ -3495,19 +3501,6 @@
     sres_send_dns_query(res, query);
     query->q_retry_count++;
   }
-  else if (error == SRES_AUTH_ERR ||
-	   error == SRES_UNIMPL_ERR ||
-	   error == SRES_SERVER_ERR) {
-    /*
-     * Mark server as unresponsive and
-     * try to resend query to another server
-     */
-    dns->dns_icmp = res->res_now;
-    if (sres_resend_dns_query(res, query, 0) < 0)
-      sres_query_report_error(query, reply);
-    else
-      sres_cache_free_answers(res->res_cache, reply);
-  }
   else if (!error && reply) {
     /* Remove the query from the pending list */
     sres_remove_query(res, query, 1);
@@ -3612,7 +3605,7 @@
   m->m_offset = sizeof(m->m_packet.mp_header);
 
   if (m->m_size < m->m_offset) {
-    SU_DEBUG_5(("sres_decode_msg: truncated message\n"));
+    SU_DEBUG_5(("sres_decode_msg: truncated message\n" VA_NONE));
     return -1;
   }
 
@@ -3652,6 +3645,10 @@
     m_get_domain(name, sizeof(name), m, 0); /* Query domain */
     qtype = m_get_uint16(m);  /* Query type */
     qclass = m_get_uint16(m); /* Query class */
+    if (qtype && qclass) {
+      /* XXX: never mind these useless check, this is done to make compiler happy about unused value */
+    }
+
   }
 
   if (m->m_error) {
diff -ur a/libsofia-sip-ua/sresolv/sres_cache.c b/libsofia-sip-ua/sresolv/sres_cache.c
--- a/libsofia-sip-ua/sresolv/sres_cache.c	2011-03-11 16:49:18.000000000 +0200
+++ b/libsofia-sip-ua/sresolv/sres_cache.c	2017-12-07 23:26:00.188841814 +0200
@@ -648,9 +648,18 @@
   return ret;
 }
 
+#ifdef __clang__
+#pragma clang diagnostic push
+#pragma clang diagnostic ignored "-Wunused-function"
+#endif
+
 HTABLE_BODIES_WITH(sres_htable, ht, sres_rr_hash_entry_t, SRES_HENTRY_HASH,
 		   unsigned, size_t);
 
+#ifdef __clang__
+#pragma clang diagnostic pop
+#endif
+
 static inline
 int sres_heap_earlier_entry(sres_rr_hash_entry_t const *a,
 			    sres_rr_hash_entry_t const *b)
@@ -667,6 +676,11 @@
   heap[index] = entry;
 }
 
+#ifdef __clang__
+#pragma clang diagnostic push
+#pragma clang diagnostic ignored "-Wunused-function"
+#endif
+
 HEAP_BODIES(static inline,
 	    sres_heap_t,
 	    sres_heap_,
@@ -675,3 +689,7 @@
 	    sres_heap_set_entry,
 	    su_realloc,
 	    NULL);
+
+#ifdef __clang__
+#pragma clang diagnostic pop
+#endif
diff -ur a/libsofia-sip-ua/sresolv/sresolv.c b/libsofia-sip-ua/sresolv/sresolv.c
--- a/libsofia-sip-ua/sresolv/sresolv.c	2011-03-11 16:49:18.000000000 +0200
+++ b/libsofia-sip-ua/sresolv/sresolv.c	2017-12-07 23:26:00.172841727 +0200
@@ -132,13 +132,13 @@
     srs->srs_timer = t;
 
     if (!srs->srs_timer)
-      SU_DEBUG_3(("sres: cannot create timer\n"));
+      SU_DEBUG_3(("sres: cannot create timer\n" VA_NONE));
 #if nomore
     else if (su_timer_set_for_ever(t, sres_sofia_timer, srs) < 0)
-      SU_DEBUG_3(("sres: cannot set timer\n"));
+      SU_DEBUG_3(("sres: cannot set timer\n" VA_NONE));
 #else
     else if (sres_resolver_set_timer_cb(res, sres_sofia_set_timer, srs) < 0)
-      SU_DEBUG_3(("sres: cannot set timer cb\n"));
+      SU_DEBUG_3(("sres: cannot set timer cb\n" VA_NONE));
 #endif
     else
       return res;		/* Success! */
diff -ur a/libsofia-sip-ua/sresolv/sres_sip.c b/libsofia-sip-ua/sresolv/sres_sip.c
--- a/libsofia-sip-ua/sresolv/sres_sip.c	2011-03-11 16:49:18.000000000 +0200
+++ b/libsofia-sip-ua/sresolv/sres_sip.c	2017-12-07 23:26:00.192841836 +0200
@@ -404,7 +404,7 @@
   sres_resolver_t *sres = srs->srs_resolver;
   struct srs_step *step;
 
-  SU_DEBUG_5(("srs(%p): destroyed\n", (void *)(_srs)));
+  SU_DEBUG_5(("srs(%p): destroyed\n", (void *) (_srs)));
 
   srs->srs_resolver = NULL;
 
@@ -516,7 +516,7 @@
   if (len >= sizeof parameter)
     return -1;
 
-  for (i = 0; sres_sip_tports[i].stp_name; i++) {
+  for (i = 0; *sres_sip_tports[i].stp_name; i++) {
     if (su_casematch(parameter, sres_sip_tports[i].stp_name))
       return sres_sip_tports[i].stp_number;
   }
@@ -565,7 +565,7 @@
   if (step->sp_otype != sres_type_srv)
     return;
 
-  SU_DEBUG_5(("srs(%p): graylisting %s:%u;transport=%s\n", (void *)target, step->sp_port, proto));
+  SU_DEBUG_5(("srs(%p): graylisting %s:%u;transport=%s\n", (void *) target, step->sp_port, proto));
 
   for (step = srs->srs_send; step; step = step->sp_next)
     if (step->sp_otype == sres_type_srv && step->sp_priority > maxprio)
@@ -1625,7 +1625,7 @@
       break;
   }
 
-  if ((srs->srs_canonname && srs->srs_numeric) || (SU_LOG->log_level >= 0)) {
+  {
     unsigned port = 0;
     char const *lb = "", *rb = "";
 
@@ -1647,7 +1647,7 @@
     }
 
     SU_DEBUG_5(("srs(%p): %s result %s%s%s:%u;transport=%s\n",
-		(void *)srs, duplicate ? "duplicate" : "returning",
+				(void *)srs, duplicate ? "duplicate" : "returning",
 		lb , numeric, rb, port,
 		sres_sip_transport_name(result->ai_protocol)));
 
diff -ur a/libsofia-sip-ua/stun/stun.c b/libsofia-sip-ua/stun/stun.c
--- a/libsofia-sip-ua/stun/stun.c	2011-03-11 16:49:18.000000000 +0200
+++ b/libsofia-sip-ua/stun/stun.c	2017-12-07 23:26:00.236842074 +0200
@@ -552,7 +552,7 @@
 
     ta_list ta;
     ta_start(ta, tag, value);
-    SU_DEBUG_5(("Delaying STUN shared-secret req. for DNS-SRV query.\n"));
+    SU_DEBUG_5(("Delaying STUN shared-secret req. for DNS-SRV query.\n" VA_NONE));
     err = priv_dns_queue_action(sh, stun_action_tls_query, sdf, magic, ta_tags(ta));
     ta_end(ta);
 
@@ -565,7 +565,7 @@
     SU_DEBUG_3(("%s: Obtaining shared secret.\n", __func__));
   }
   else {
-    SU_DEBUG_3(("No message integrity enabled.\n"));
+    SU_DEBUG_3(("No message integrity enabled.\n" VA_NONE));
     return errno = EFAULT, -1;
   }
 
@@ -673,12 +673,12 @@
 
 void stun_request_destroy(stun_request_t *req)
 {
-  stun_handle_t *sh;
+  //stun_handle_t *sh;
   assert(req);
 
   enter;
 
-  sh = req->sr_handle;
+  //sh = req->sr_handle;
 
   if (x_is_inserted(req, sr))
     x_remove(req, sr);
@@ -928,12 +928,12 @@
       break;
 
     default:
-      SU_DEBUG_5(("Warning: unknown pending STUN DNS-SRV action.\n"));
+      SU_DEBUG_5(("Warning: unknown pending STUN DNS-SRV action.\n" VA_NONE));
     }
       }
   else {
     /* DNS lookup failed */
-    SU_DEBUG_5(("Warning: STUN DNS-SRV lookup failed.\n"));
+    SU_DEBUG_5(("Warning: STUN DNS-SRV lookup failed.\n" VA_NONE));
     if (sh->sh_dns_pend_cb) {
       sh->sh_dns_pend_cb(sh->sh_dns_pend_ctx, sh, NULL,
 			 sh->sh_dns_pend_action, stun_error);
@@ -1045,7 +1045,7 @@
     int err;
     ta_list ta;
     ta_start(ta, tag, value);
-    SU_DEBUG_5(("Delaying STUN bind for DNS-SRV query.\n"));
+    SU_DEBUG_5(("Delaying STUN bind for DNS-SRV query.\n" VA_NONE));
     err = priv_dns_queue_action(sh, stun_action_binding_request, sdf, magic, ta_tags(ta));
     ta_end(ta);
     return err;
@@ -1140,14 +1140,14 @@
 
 static int stun_discovery_destroy(stun_discovery_t *sd)
 {
-  stun_handle_t *sh;
+  //stun_handle_t *sh;
 
   enter;
 
   if (!sd)
     return errno = EFAULT, -1;
 
-  sh = sd->sd_handle;
+  //sh = sd->sd_handle;
 
   if (sd->sd_timer)
     su_timer_destroy(sd->sd_timer), sd->sd_timer = NULL;
@@ -1201,7 +1201,7 @@
 
     ta_list ta;
     ta_start(ta, tag, value);
-    SU_DEBUG_5(("Delaying STUN get-nat-type req. for DNS-SRV query.\n"));
+    SU_DEBUG_5(("Delaying STUN get-nat-type req. for DNS-SRV query.\n" VA_NONE));
     err = priv_dns_queue_action(sh, stun_action_test_nattype, sdf, magic, ta_tags(ta));
     ta_end(ta);
 
@@ -1453,7 +1453,7 @@
     su_root_eventmask(self->sh_root, sd->sd_index,
 		      sd->sd_socket, events);
 
-    SU_DEBUG_5(("Shared Secret Request sent to server:\n"));
+    SU_DEBUG_5(("Shared Secret Request sent to server:\n" VA_NONE));
     debug_print(&msg_req->enc_buf);
 
     z = SSL_read(ssl, buf, sizeof(buf));
@@ -1472,7 +1472,7 @@
     resp->enc_buf.size = z;
     resp->enc_buf.data = malloc(z);
     memcpy(resp->enc_buf.data, buf, z);
-    SU_DEBUG_5(("Shared Secret Response received from server:\n"));
+    SU_DEBUG_5(("Shared Secret Response received from server:\n" VA_NONE));
     debug_print(&resp->enc_buf);
 
     /* closed TLS connection */
@@ -1505,7 +1505,7 @@
 
     case SHARED_SECRET_ERROR_RESPONSE:
       if (stun_process_error_response(resp) < 0) {
-	SU_DEBUG_5(("Error in Shared Secret Error Response.\n"));
+	SU_DEBUG_5(("Error in Shared Secret Error Response.\n" VA_NONE));
       }
       stun_free_buffer(&resp->enc_buf);
       return -1;
@@ -1755,7 +1755,7 @@
   id = msg->stun_hdr.tran_id;
   req = find_request(sh, id);
   if (!req) {
-    SU_DEBUG_7(("warning: unable to find matching TID for response\n"));
+    SU_DEBUG_7(("warning: unable to find matching TID for response\n" VA_NONE));
     return 0;
   }
 
@@ -1883,7 +1883,7 @@
   stun_discovery_t *sd = req->sr_discovery;
   stun_request_t *new;
   stun_handle_t *sh = req->sr_handle;
-  su_localinfo_t *li;
+  //su_localinfo_t *li;
   su_sockaddr_t *sa;
   su_timer_t *sockfdy_timer = NULL;
   su_socket_t sockfdy = sd->sd_socket2;
@@ -1954,7 +1954,7 @@
   /* Rock, we come from sockfdx */
   process_binding_request(req, binding_response);
 
-  li = &req->sr_localinfo;
+  //li = &req->sr_localinfo;
   sa = req->sr_local_addr;
   stun_free_message(binding_response);
 
@@ -1981,7 +1981,7 @@
 
 static int action_bind(stun_request_t *req, stun_msg_t *binding_response)
 {
-  su_localinfo_t *li = NULL;
+  //su_localinfo_t *li = NULL;
   su_sockaddr_t *sa = NULL;
   stun_discovery_t *sd = req->sr_discovery;
   stun_handle_t *sh = req->sr_handle;
@@ -1992,7 +1992,7 @@
 
   process_binding_request(req, binding_response);
 
-  li = &req->sr_localinfo;
+  //li = &req->sr_localinfo;
   sa = req->sr_local_addr;
 
   memcpy(sd->sd_addr_seen_outside, sa, sizeof(su_sockaddr_t));
@@ -2205,7 +2205,7 @@
 
     if (err < 0) {
       SU_DEBUG_0(("WARNING: Failure in performing STUN Test-IV check. "
-		  "The results related to mapping characteristics may be incorrect."));
+		  "The results related to mapping characteristics may be incorrect." VA_NONE));
       stun_free_message(req->sr_msg);
       sd->sd_fourth = -1;
       /* call function again, sd_fourth stops the recursion */
@@ -2696,7 +2696,7 @@
 
     ta_list ta;
     ta_start(ta, tag, value);
-    SU_DEBUG_5(("Delaying STUN get-lifetime req. for DNS-SRV query.\n"));
+    SU_DEBUG_5(("Delaying STUN get-lifetime req. for DNS-SRV query.\n" VA_NONE));
     err = priv_dns_queue_action(sh, stun_action_test_lifetime, sdf, magic, ta_tags(ta));
     ta_end(ta);
 
@@ -3039,7 +3039,7 @@
   su_sockaddr_t mod_addr[1] = {{ 0 }}, src_addr[1] = {{ 0 }}, chg_addr[1] = {{ 0 }};
   stun_attr_t *tmp, m_attr[1], s_attr[1], c_attr[1], **p;
   su_sockaddr_t to_addr;
-  int c, i;
+  int i;
 
   tmp = stun_get_attr(req->stun_attr, RESPONSE_ADDRESS);
 
@@ -3071,20 +3071,20 @@
   /* SOURCE-ADDRESS depends on CHANGE_REQUEST */
   tmp = stun_get_attr(req->stun_attr, CHANGE_REQUEST);
   if (!tmp) {
-    c = 0;
+    //c = 0;
   }
   else {
     switch (((stun_attr_changerequest_t *) tmp->pattr)->value) {
     case STUN_CR_CHANGE_IP:
-      c = 1;
+      //c = 1;
       break;
 
     case STUN_CR_CHANGE_PORT:
-      c = 2;
+      //c = 2;
       break;
 
     case STUN_CR_CHANGE_IP | STUN_CR_CHANGE_PORT: /* bitwise or */
-      c = 3;
+      //c = 3;
       break;
 
     default:
diff -ur a/libsofia-sip-ua/stun/stun_common.c b/libsofia-sip-ua/stun/stun_common.c
--- a/libsofia-sip-ua/stun/stun_common.c	2011-03-11 16:49:18.000000000 +0200
+++ b/libsofia-sip-ua/stun/stun_common.c	2017-12-07 23:26:00.252842161 +0200
@@ -100,7 +100,7 @@
   msg->stun_attr = NULL;
   while (len > 0) {
     i = stun_parse_attribute(msg, p);
-    if (i <= 0) {
+    if (i <= 0 || i > len) {
       SU_DEBUG_3(("%s: Error parsing attribute.\n", __func__));
       return -1;
     }
@@ -558,9 +558,9 @@
 		*(buf->data + i*4 +2),
 		*(buf->data + i*4 +3)));
     if (i == 4)
-      SU_DEBUG_9(("---------------------\n"));
+		SU_DEBUG_9(("---------------------\n" VA_NONE));
   }
-  SU_DEBUG_9(("\n"));
+  SU_DEBUG_9(("\n" VA_NONE));
 }
 
 int stun_init_message(stun_msg_t *msg) {
@@ -608,50 +608,47 @@
   return 0;
 }
 
-void stun_free_message_data(stun_msg_t *msg)
-{
-  stun_attr_t *a, *next;
-
-  free(msg->enc_buf.data), msg->enc_buf.data = NULL;
-  msg->enc_buf.size = 0;
-
-  for (a = msg->stun_attr; a; a = next) {
-    next = a->next, a->next = NULL;
-
-    if (a->pattr)
-      free(a->pattr), a->pattr = NULL;
-
-    if (a->enc_buf.data)
-      free(a->enc_buf.data), a->enc_buf.data = NULL;
-
-    free(a);
-  }
-
-  msg->stun_attr = NULL;
-}
 
 int stun_send_message(su_socket_t s, su_sockaddr_t *to_addr,
 		      stun_msg_t *msg, stun_buffer_t *pwd)
 {
   int err;
   char ipaddr[SU_ADDRSIZE + 2];
+  stun_attr_t **a, *b;
 
   stun_encode_message(msg, pwd);
 
   err = su_sendto(s, msg->enc_buf.data, msg->enc_buf.size, 0,
 		  to_addr, SU_SOCKADDR_SIZE(to_addr));
 
+  free(msg->enc_buf.data), msg->enc_buf.data = NULL;
+  msg->enc_buf.size = 0;
+
+  for (a = &msg->stun_attr; *a;) {
+
+    if ((*a)->pattr)
+      free((*a)->pattr), (*a)->pattr = NULL;
+
+    if ((*a)->enc_buf.data)
+      free((*a)->enc_buf.data), (*a)->enc_buf.data = NULL;
+
+    b = *a;
+    b = b->next;
+    free(*a);
+    *a = NULL;
+    *a = b;
+  }
+
   if (err > 0) {
     su_inet_ntop(to_addr->su_family, SU_ADDR(to_addr), ipaddr, sizeof(ipaddr));
     SU_DEBUG_5(("%s: message sent to %s:%u\n", __func__,
 		ipaddr, ntohs(to_addr->su_port)));
+
     debug_print(&msg->enc_buf);
   }
   else
     STUN_ERROR(errno, sendto);
 
-  stun_free_message_data(msg);
-
   return err;
 }
 
diff -ur a/libsofia-sip-ua/stun/stun_dns.c b/libsofia-sip-ua/stun/stun_dns.c
--- a/libsofia-sip-ua/stun/stun_dns.c	2011-03-11 16:49:18.000000000 +0200
+++ b/libsofia-sip-ua/stun/stun_dns.c	2017-12-07 23:26:00.256842182 +0200
@@ -163,7 +163,10 @@
     query = sres_query(self->stun_sres, priv_sres_cb, self,
 		       sres_type_srv,
 		       srvname);
-  }
+    if (query) {
+      /* TODO Just so compiler doesn't give error */
+    }
+}
   else {
     su_free(NULL, self), self = NULL;
   }
diff -ur a/libsofia-sip-ua/stun/stun_internal.h b/libsofia-sip-ua/stun/stun_internal.h
--- a/libsofia-sip-ua/stun/stun_internal.h	2011-03-11 16:49:18.000000000 +0200
+++ b/libsofia-sip-ua/stun/stun_internal.h	2017-12-07 23:26:00.260842204 +0200
@@ -98,8 +98,6 @@
 int stun_send_message(su_socket_t s, su_sockaddr_t *srvr,
 		      stun_msg_t *msg, stun_buffer_t *pwd);
 
-void stun_free_message_data(stun_msg_t *msg);
-
 int stun_make_binding_req(stun_handle_t *se, stun_request_t *req,
 			  stun_msg_t *msg,
 			  tag_type_t, tag_value_t, ...);
diff -ur a/libsofia-sip-ua/stun/stun_mini.c b/libsofia-sip-ua/stun/stun_mini.c
--- a/libsofia-sip-ua/stun/stun_mini.c	2011-03-11 16:49:18.000000000 +0200
+++ b/libsofia-sip-ua/stun/stun_mini.c	2017-12-07 23:26:00.264842226 +0200
@@ -248,11 +248,12 @@
   next = &response->stun_attr;
 
   /* MAPPED-ADDRESS */
-  a = calloc(1, sizeof *a); if (!a) return STUN_500_SERVER_ERROR;
+  a = malloc(sizeof *a); if (!a) return STUN_500_SERVER_ERROR;
   a->attr_type = MAPPED_ADDRESS;
   addr = malloc(sizeof *addr); if (!addr) return STUN_500_SERVER_ERROR;
   memcpy(addr, from, sizeof *addr);
   a->pattr = addr;
+  a->next = NULL;
   *next = a; next = &a->next;
 
   /* SOURCE-ADDRESS */ /* depends on CHANGE_REQUEST */
@@ -311,11 +312,12 @@
       return STUN_500_SERVER_ERROR;
   }
 
-  a = calloc(1, sizeof *a); if (!a) return STUN_500_SERVER_ERROR;
+  a = malloc(sizeof *a); if (!a) return STUN_500_SERVER_ERROR;
   a->attr_type = SOURCE_ADDRESS;
   addr = malloc(sizeof *addr); if (!addr) return STUN_500_SERVER_ERROR;
   memcpy(addr, ss->ss_addr.array, sizeof *addr);
   a->pattr = addr;
+  a->next = NULL;
   *next = a; next = &(a->next);
 
   if (changed) {
@@ -367,9 +369,10 @@
   memcpy(response->stun_hdr.tran_id, transaction_id, 16);
 
   /* ERROR-CODE */
-  attr = calloc(1, sizeof *attr); if (!attr) return -1;
+  attr = malloc(sizeof *attr); if (!attr) return -1;
   response->stun_attr = attr;
   attr->attr_type = ERROR_CODE;
+  attr->next = NULL;
 
   errorcode = malloc(sizeof(*errorcode));
   if (!errorcode)
@@ -385,3 +388,4 @@
 
   return 0;
 }
+
diff -ur a/libsofia-sip-ua/su/sofia-sip/su_alloc.h b/libsofia-sip-ua/su/sofia-sip/su_alloc.h
--- a/libsofia-sip-ua/su/sofia-sip/su_alloc.h	2011-03-11 16:49:19.000000000 +0200
+++ b/libsofia-sip-ua/su/sofia-sip/su_alloc.h	2017-12-07 23:26:01.676849884 +0200
@@ -64,8 +64,33 @@
 
 SU_DLL void *su_home_new(isize_t size)
      __attribute__((__malloc__));
+
+#if (defined(HAVE_MEMLEAK_LOG) && (HAVE_MEMLEAK_LOG != 1))
+
+int _su_home_mutex_lock(su_home_t *home, const char *file, unsigned int line, const char *function);
+int _su_home_mutex_unlock(su_home_t *home, const char *file, unsigned int line, const char *function);
+
+#define su_home_mutex_lock(home) \
+  _su_home_mutex_lock((home), __FILE__, __LINE__, __func__)
+
+#define su_home_mutex_unlock(home) \
+  _su_home_mutex_unlock((home), __FILE__, __LINE__, __func__)
+
+
+su_home_t *_su_home_ref_by(
+  su_home_t *home, char const *file, unsigned line, char const *by);
+int _su_home_unref_by(
+  su_home_t *home, char const *file, unsigned line, char const *by);
+
+#define su_home_ref(home) \
+  _su_home_ref_by((home), __FILE__, __LINE__, __func__)
+#define su_home_unref(home) \
+  _su_home_unref_by((home), __FILE__, __LINE__, __func__)
+
+#else
 SU_DLL void *su_home_ref(su_home_t const *);
 SU_DLL int su_home_unref(su_home_t *);
+#endif
 
 SU_DLL size_t su_home_refcount(su_home_t *home);
 
@@ -107,9 +132,11 @@
 
 SU_DLL int su_home_check_alloc(su_home_t const *home, void const *data);
 
+#if (!defined(HAVE_MEMLEAK_LOG) || (HAVE_MEMLEAK_LOG != 1))
 SU_DLL int su_home_mutex_lock(su_home_t *home);
 
 SU_DLL int su_home_mutex_unlock(su_home_t *home);
+#endif
 
 SU_DLL int su_home_lock(su_home_t *home);
 SU_DLL int su_home_trylock(su_home_t *home);
diff -ur a/libsofia-sip-ua/su/sofia-sip/su_debug.h b/libsofia-sip-ua/su/sofia-sip/su_debug.h
--- a/libsofia-sip-ua/su/sofia-sip/su_debug.h	2011-03-11 16:49:19.000000000 +0200
+++ b/libsofia-sip-ua/su/sofia-sip/su_debug.h	2017-12-07 23:26:01.696849993 +0200
@@ -73,6 +73,8 @@
 SOFIAPUBVAR su_log_t SU_LOG[];
 #endif
 
+#define VA_NONE "%s",""
+
 #define SU_DEBUG_DEF(level) \
   su_inline void su_debug_##level(char const *fmt, ...) \
     __attribute__ ((__format__ (printf, 1, 2))); \
diff -ur a/libsofia-sip-ua/su/sofia-sip/su_errno.h b/libsofia-sip-ua/su/sofia-sip/su_errno.h
--- a/libsofia-sip-ua/su/sofia-sip/su_errno.h	2011-03-11 16:49:19.000000000 +0200
+++ b/libsofia-sip-ua/su/sofia-sip/su_errno.h	2017-12-07 23:26:01.704850036 +0200
@@ -53,11 +53,6 @@
 /** Set the su error. */
 SOFIAPUBFUN int su_seterrno(int);
 
-#if !SU_HAVE_WINSOCK
-#define su_errno() (errno)
-#define su_seterrno(n) ((errno = (n)), -1)
-#endif
-
 #if defined(__APPLE_CC__) || defined(__OpenBSD__) || defined(__NetBSD__) || defined(__FreeBSD__)
 #ifndef EBADMSG
 #define EBADMSG EFAULT
@@ -70,139 +65,211 @@
 #endif
 #endif
 
-#if SU_HAVE_WINSOCK
-/*
- * Use WinSock errors with Sofia-SIP.
- *
- * VC POSIX runtime defines some of these, undef POSIX definitions.
- */
-
+#if defined(_WIN32)
+/* VS 2010 defines these for POSIX but we cant have that */
+#if (_MSC_VER > 1500)
 #undef EWOULDBLOCK
+#undef EINPROGRESS
+#undef EALREADY
+#undef ENOTSOCK
+#undef EDESTADDRREQ
+#undef EMSGSIZE
+#undef EPROTOTYPE
+#undef ENOPROTOOPT
+#undef EPROTONOSUPPORT
+#undef ESOCKTNOSUPPORT
+#undef EOPNOTSUPP
+#undef EPFNOSUPPORT
+#undef EAFNOSUPPORT
+#undef EADDRINUSE
+#undef EADDRNOTAVAIL
+#undef ENETDOWN
+#undef ENETUNREACH
+#undef ENETRESET
+#undef ECONNABORTED
+#undef ECONNRESET
+#undef ENOBUFS
+#undef EISCONN
+#undef ENOTCONN
+#undef ESHUTDOWN
+#undef ETOOMANYREFS
+#undef ETIMEDOUT
+#undef ECONNREFUSED
+#undef ELOOP
+#undef EHOSTDOWN
+#undef EHOSTUNREACH
+#undef EPROCLIM
+#undef EUSERS
+#undef EDQUOT
+#undef ESTALE
+#undef EREMOTE
+#undef EBADMSG
+#undef EPROTO
+#endif
+
+#ifndef EWOULDBLOCK
 #define EWOULDBLOCK  (10035) /* WSAEWOULDBLOCK */
+#endif
 
-#undef EINPROGRESS
+#ifndef EINPROGRESS
 #define EINPROGRESS  (10036) /* WSAEINPROGRESS */
+#endif
 
-#undef EALREADY
+#ifndef EALREADY
 #define EALREADY (10037) /* WSAEALREADY */
+#endif
 
-#undef ENOTSOCK
+#ifndef ENOTSOCK
 #define ENOTSOCK (10038) /* WSAENOTSOCK */
+#endif
 
-#undef EDESTADDRREQ
+#ifndef EDESTADDRREQ
 #define EDESTADDRREQ (10039) /* WSAEDESTADDRREQ */
+#endif
 
-#undef EMSGSIZE
+#ifndef EMSGSIZE
 #define EMSGSIZE (10040) /* WSAEMSGSIZE */
+#endif
 
-#undef EPROTOTYPE
+#ifndef EPROTOTYPE
 #define EPROTOTYPE (10041) /* WSAEPROTOTYPE */
+#endif
 
-#undef ENOPROTOOPT
+#ifndef ENOPROTOOPT
 #define ENOPROTOOPT (10042) /* WSAENOPROTOOPT */
+#endif
 
-#undef EPROTONOSUPPORT
+#ifndef EPROTONOSUPPORT
 #define EPROTONOSUPPORT (10043) /* WSAEPROTONOSUPPORT */
+#endif
 
-#undef ESOCKTNOSUPPORT
+#ifndef ESOCKTNOSUPPORT
 #define ESOCKTNOSUPPORT (10044) /* WSAESOCKTNOSUPPORT */
+#endif
 
-#undef EOPNOTSUPP
+#ifndef EOPNOTSUPP
 #define EOPNOTSUPP (10045) /* WSAEOPNOTSUPP */
+#endif
 
-#undef EPFNOSUPPORT
+#ifndef EPFNOSUPPORT
 #define EPFNOSUPPORT (10046) /* WSAEPFNOSUPPORT */
+#endif
 
-#undef EAFNOSUPPORT
+#ifndef EAFNOSUPPORT
 #define EAFNOSUPPORT (10047) /* WSAEAFNOSUPPORT */
+#endif
 
-#undef EADDRINUSE
+#ifndef EADDRINUSE
 #define EADDRINUSE (10048) /* WSAEADDRINUSE */
+#endif
 
-#undef EADDRNOTAVAIL
+#ifndef EADDRNOTAVAIL
 #define EADDRNOTAVAIL (10049) /* WSAEADDRNOTAVAIL */
+#endif
 
-#undef ENETDOWN
+#ifndef ENETDOWN
 #define ENETDOWN (10050) /* WSAENETDOWN */
+#endif
 
-#undef ENETUNREACH
+#ifndef ENETUNREACH
 #define ENETUNREACH (10051) /* WSAENETUNREACH */
+#endif
 
-#undef ENETRESET
+#ifndef ENETRESET
 #define ENETRESET (10052) /* WSAENETRESET */
+#endif
 
-#undef ECONNABORTED
+#ifndef ECONNABORTED
 #define ECONNABORTED (10053) /* WSAECONNABORTED */
+#endif
 
-#undef ECONNRESET
+#ifndef ECONNRESET
 #define ECONNRESET (10054) /* WSAECONNRESET */
+#endif
 
-#undef ENOBUFS
+#ifndef ENOBUFS
 #define ENOBUFS (10055) /* WSAENOBUFS */
+#endif
 
-#undef EISCONN
+#ifndef EISCONN
 #define EISCONN (10056) /* WSAEISCONN */
+#endif
 
-#undef ENOTCONN
+#ifndef ENOTCONN
 #define ENOTCONN (10057) /* WSAENOTCONN */
+#endif
 
-#undef ESHUTDOWN
+#ifndef ESHUTDOWN
 #define ESHUTDOWN (10058) /* WSAESHUTDOWN */
+#endif
 
-#undef ETOOMANYREFS
+#ifndef ETOOMANYREFS
 #define ETOOMANYREFS (10059) /* WSAETOOMANYREFS */
+#endif
 
-#undef ETIMEDOUT
+#ifndef ETIMEDOUT
 #define ETIMEDOUT (10060) /* WSAETIMEDOUT */
+#endif
 
-#undef ECONNREFUSED
+#ifndef ECONNREFUSED
 #define ECONNREFUSED (10061) /* WSAECONNREFUSED */
+#endif
 
-#undef ELOOP
+#ifndef ELOOP
 #define ELOOP (10062) /* WSAELOOP */
+#endif
 
-#undef ENAMETOOLONG
+#ifndef ENAMETOOLONG
 #define ENAMETOOLONG (10063) /* WSAENAMETOOLONG */
+#endif
 
-#undef EHOSTDOWN
+#ifndef EHOSTDOWN
 #define EHOSTDOWN (10064) /* WSAEHOSTDOWN */
+#endif
 
-#undef EHOSTUNREACH
+#ifndef EHOSTUNREACH
 #define EHOSTUNREACH (10065) /* WSAEHOSTUNREACH */
+#endif
 
-#undef ENOTEMPTY
+#ifndef ENOTEMPTY
 #define ENOTEMPTY (10066) /* WSAENOTEMPTY */
+#endif
 
-#undef EPROCLIM
+#ifndef EPROCLIM
 #define EPROCLIM (10067) /* WSAEPROCLIM */
+#endif
 
-#undef EUSERS
+#ifndef EUSERS
 #define EUSERS (10068) /* WSAEUSERS */
+#endif
 
-#undef EDQUOT
+#ifndef EDQUOT
 #define EDQUOT (10069) /* WSAEDQUOT */
+#endif
 
-#undef ESTALE
+#ifndef ESTALE
 #define ESTALE (10070) /* WSAESTALE */
+#endif
 
-#undef EREMOTE
+#ifndef EREMOTE
 #define EREMOTE (10071) /* WSAEREMOTE */
+#endif
 
-#undef EBADMSG
-
+#ifndef EBADMSG
 #  if defined(WSABADMSG)
-#   define EBADMSG (WSAEBADMSG)
+#    define EBADMSG (WSAEBADMSG)
 #  else
-#   define EBADMSG (20005)
+#    define EBADMSG (20005)
 #  endif
+#endif
 
-#undef EPROTO
-
+#ifndef EPROTO
 #  if defined(WSAEPROTO)
 #    define EPROTO WSAEPROTO
 #  else
 #    define EPROTO (20006)
 #  endif
+#endif
 
 #endif
 
diff -ur a/libsofia-sip-ua/su/sofia-sip/su.h b/libsofia-sip-ua/su/sofia-sip/su.h
--- a/libsofia-sip-ua/su/sofia-sip/su.h	2011-03-11 16:49:19.000000000 +0200
+++ b/libsofia-sip-ua/su/sofia-sip/su.h	2017-12-07 23:26:01.668849841 +0200
@@ -316,7 +316,7 @@
  * and which was missing from WINSOCK
  */
 #define su_is_blocking(e) \
-  ((e) == EINPROGRESS || (e) == EAGAIN || (e) == EWOULDBLOCK)
+((e) == EINPROGRESS || (e) == EAGAIN || (e) == EWOULDBLOCK || (e) == EINTR)
 #endif
 
 #if SU_HAVE_WINSOCK
diff -ur a/libsofia-sip-ua/su/sofia-sip/su_os_nw.h b/libsofia-sip-ua/su/sofia-sip/su_os_nw.h
--- a/libsofia-sip-ua/su/sofia-sip/su_os_nw.h	2011-03-11 16:49:19.000000000 +0200
+++ b/libsofia-sip-ua/su/sofia-sip/su_os_nw.h	2017-12-07 23:26:01.720850122 +0200
@@ -58,7 +58,7 @@
 #endif
 
 #if SU_HAVE_POLL
-#include <sys/poll.h>
+#include <poll.h>
 #endif
 
 SOFIA_BEGIN_DECLS
diff -ur a/libsofia-sip-ua/su/sofia-sip/su_tagarg.h b/libsofia-sip-ua/su/sofia-sip/su_tagarg.h
--- a/libsofia-sip-ua/su/sofia-sip/su_tagarg.h	2011-03-11 16:49:19.000000000 +0200
+++ b/libsofia-sip-ua/su/sofia-sip/su_tagarg.h	2017-12-07 23:26:01.736850209 +0200
@@ -189,12 +189,12 @@
  * @hideinitializer
  */
 #if SU_HAVE_TAGSTACK
-#define ta_end(ta) (va_end((ta).ap), (ta).tl->t_tag = NULL, 0)
+#define ta_end(ta) (va_end((ta).ap), (ta).tl->t_tag = NULL)
 #else
 #define ta_end(ta)					   \
   ((((ta).tl[1].t_value) ?				   \
     (tl_vfree((tagi_t *)((ta).tl[1].t_value))) : (void)0), \
-   (ta).tl[1].t_value = 0, va_end((ta).ap), 0)
+   (ta).tl[1].t_value = 0, va_end((ta).ap))
 #endif
 
 SOFIA_END_DECLS
diff -ur a/libsofia-sip-ua/su/sofia-sip/su_time.h b/libsofia-sip-ua/su/sofia-sip/su_time.h
--- a/libsofia-sip-ua/su/sofia-sip/su_time.h	2011-03-11 16:49:19.000000000 +0200
+++ b/libsofia-sip-ua/su/sofia-sip/su_time.h	2017-12-07 23:26:01.752850296 +0200
@@ -85,6 +85,11 @@
 
 #define SU_E9 (1000000000U)
 
+typedef void (*su_time_func_t)(su_time_t *tv);
+
+
+SOFIAPUBFUN void su_set_time_func(su_time_func_t func);
+
 SOFIAPUBFUN su_nanotime_t su_nanotime(su_nanotime_t *return_time);
 SOFIAPUBFUN su_nanotime_t su_monotime(su_nanotime_t *return_time);
 
@@ -138,7 +143,7 @@
 /** Time as milliseconds. */
 su_inline uint32_t su_time_ms(su_time_t t)
 {
-  return t.tv_sec * 1000 + (t.tv_usec + 500) / 1000;
+	return (t.tv_sec * 1000) + ((t.tv_usec + 500) / 1000);
 }
 #endif
 
diff -ur a/libsofia-sip-ua/su/sofia-sip/su_wait.h b/libsofia-sip-ua/su/sofia-sip/su_wait.h
--- a/libsofia-sip-ua/su/sofia-sip/su_wait.h	2011-03-11 16:49:19.000000000 +0200
+++ b/libsofia-sip-ua/su/sofia-sip/su_wait.h	2017-12-07 23:26:01.772850404 +0200
@@ -47,7 +47,7 @@
 #endif
 
 #if SU_HAVE_POLL
-#include <sys/poll.h>
+#include <poll.h>
 #endif
 
 SOFIA_BEGIN_DECLS
@@ -129,7 +129,7 @@
 
 #define SU_WAIT_INIT    NULL
 
-#define SU_WAIT_MAX    (64)
+#define SU_WAIT_MAX    (0x7fffffff)
 
 #else
 /* If nothing works, try these */
diff -ur a/libsofia-sip-ua/su/sofia-sip/tstdef.h b/libsofia-sip-ua/su/sofia-sip/tstdef.h
--- a/libsofia-sip-ua/su/sofia-sip/tstdef.h	2011-03-11 16:49:19.000000000 +0200
+++ b/libsofia-sip-ua/su/sofia-sip/tstdef.h	2017-12-07 23:26:01.776850426 +0200
@@ -188,8 +188,7 @@
   } while(0)
 
 #define TEST_FAILED(flags) \
-  (((flags) & tst_abort) || getenv("SOFIA_SIP_TEST_ABORT"))	\
-  ? abort() : (void)0; return 1
+  ((flags) & tst_abort) ? abort() : (void)0; return 1
 
 /** @HIDE */
 #define TEST_1_(flags, suite) do { \
diff -ur a/libsofia-sip-ua/su/strtoull.c b/libsofia-sip-ua/su/strtoull.c
--- a/libsofia-sip-ua/su/strtoull.c	2011-03-11 16:49:19.000000000 +0200
+++ b/libsofia-sip-ua/su/strtoull.c	2017-12-07 23:26:00.352842703 +0200
@@ -73,7 +73,10 @@
     20, 21, 22, 23, 24, 25, 26, 27, 28, 29,
     30, 31, 32, 33, 34, 35};
 
-
+
+
+#if !((defined(WIN32) || defined(_WIN32)) && (_MSC_VER >= 1800))
+
 /**Convert an ASCII string into an unsigned long long integer.
  *
  * @param[in]  string  String of ASCII digits, possibly preceded by white
@@ -284,3 +287,5 @@
 
     return (unsigned longlong)-1;
 }
+
+#endif
diff -ur a/libsofia-sip-ua/su/su_addrinfo.c b/libsofia-sip-ua/su/su_addrinfo.c
--- a/libsofia-sip-ua/su/su_addrinfo.c	2011-03-11 16:49:19.000000000 +0200
+++ b/libsofia-sip-ua/su/su_addrinfo.c	2017-12-07 23:26:00.364842768 +0200
@@ -820,8 +820,6 @@
 #endif
 
 #if !HAVE_GAI_STRERROR
-#undef gai_strerror
-
 static
 char *
 gai_strerror(ecode)
diff -ur a/libsofia-sip-ua/su/su_alloc.c b/libsofia-sip-ua/su/su_alloc.c
--- a/libsofia-sip-ua/su/su_alloc.c	2011-03-11 16:49:19.000000000 +0200
+++ b/libsofia-sip-ua/su/su_alloc.c	2017-12-07 23:26:00.368842790 +0200
@@ -209,9 +209,14 @@
 su_inline void safefree(void *b) { b ? free(b) : (void)0; }
 #endif
 
-#define MEMLOCK(h)   \
-  ((void)((h) && (h)->suh_lock ? _su_home_locker((h)->suh_lock) : 0), (h)->suh_blocks)
-#define UNLOCK(h) ((void)((h) && (h)->suh_lock ? _su_home_unlocker((h)->suh_lock) : 0), NULL)
+static inline su_block_t* MEMLOCK(const su_home_t *h) {
+  if (h && h->suh_lock) _su_home_locker(h->suh_lock);
+  return h->suh_blocks;
+}
+static inline void* UNLOCK(const su_home_t *h) {
+  if (h && h->suh_lock) _su_home_unlocker(h->suh_lock);
+  return NULL;
+}
 
 #ifdef NDEBUG
 #define MEMCHECK 0
@@ -233,7 +238,7 @@
 };
 
 #define ALIGNMENT (8)
-#define ALIGN(n) (size_t)(((n) + (ALIGNMENT - 1)) & (size_t)~(ALIGNMENT - 1))
+#define __ALIGN(n) (size_t)(((n) + (ALIGNMENT - 1)) & (size_t)~(ALIGNMENT - 1))
 #define SIZEBITS (sizeof (unsigned) * 8 - 1)
 
 typedef struct {
@@ -427,15 +432,17 @@
   if (size >= ((size_t)1) << SIZEBITS)
     return (void)(errno = ENOMEM), NULL;
 
+  if (!size) return NULL;
+
   if (sub == NULL || 3 * sub->sub_used > 2 * sub->sub_n) {
     /* Resize the hash table */
-    size_t i, n, n2, used;
+    size_t i, n, n2;
     su_block_t *b2;
 
     if (sub)
-      n = home->suh_blocks->sub_n, n2 = 4 * n + 3, used = sub->sub_used;
+      n = home->suh_blocks->sub_n, n2 = 4 * n + 3; //, used = sub->sub_used;
     else
-      n = 0, n2 = SUB_N, used = 0;
+      n = 0, n2 = SUB_N; //, used = 0;
 
 #if 0
     printf("su_alloc(home = %p): realloc block hash of size %d\n", home, n2);
@@ -469,11 +476,11 @@
     sub = b2;
   }
 
-  if (size && sub && zero < do_clone &&
+  if (sub && zero < do_clone &&
       sub->sub_preload && size <= sub->sub_prsize) {
     /* Use preloaded memory */
     size_t prused = sub->sub_prused + size + MEMCHECK_EXTRA;
-    prused = ALIGN(prused);
+    prused = __ALIGN(prused);
     if (prused <= sub->sub_prsize) {
       preload = (char *)sub->sub_preload + sub->sub_prused;
       sub->sub_prused = (unsigned)prused;
@@ -569,28 +576,6 @@
   return home;
 }
 
-/** Create a new reference to a home object. */
-void *su_home_ref(su_home_t const *home)
-{
-  if (home) {
-    su_block_t *sub = MEMLOCK(home);
-
-    if (sub == NULL || sub->sub_ref == 0) {
-      assert(sub && sub->sub_ref != 0);
-      UNLOCK(home);
-      return NULL;
-    }
-
-    if (sub->sub_ref != REF_MAX)
-      sub->sub_ref++;
-    UNLOCK(home);
-  }
-  else
-    su_seterrno(EFAULT);
-
-  return (void *)home;
-}
-
 /** Set destructor function.
  *
  * The destructor function is called after the reference count of a
@@ -637,6 +622,123 @@
   return su_home_destructor(home, destructor);
 }
 
+
+#if (defined(HAVE_MEMLEAK_LOG) && (HAVE_MEMLEAK_LOG != 1))
+#include "sofia-sip/su_debug.h"
+
+
+static void *real_su_home_ref(su_home_t const *home)
+{
+  if (home) {
+    su_block_t *sub = MEMLOCK(home);
+
+    if (sub == NULL || sub->sub_ref == 0) {
+      assert(sub && sub->sub_ref != 0);
+      UNLOCK(home);
+      return NULL;
+    }
+
+    if (sub->sub_ref != REF_MAX)
+      sub->sub_ref++;
+    UNLOCK(home);
+  }
+  else
+    su_seterrno(EFAULT);
+
+  return (void *)home;
+}
+
+
+static int real_su_home_unref(su_home_t *home)
+{
+  su_block_t *sub;
+
+  if (home == NULL)
+    return 0;
+
+  sub = MEMLOCK(home);
+
+  if (sub == NULL) {
+    /* Xyzzy */
+    return 0;
+  }
+  else if (sub->sub_ref == REF_MAX) {
+    UNLOCK(home);
+    return 0;
+  }
+  else if (--sub->sub_ref > 0) {
+    UNLOCK(home);
+    return 0;
+  }
+  else if (sub->sub_parent) {
+    su_home_t *parent = sub->sub_parent;
+    UNLOCK(home);
+    su_free(parent, home);
+    return 1;
+  }
+  else {
+    int hauto = sub->sub_hauto;
+    _su_home_deinit(home);
+    if (!hauto)
+      safefree(home);
+    /* UNLOCK(home); */
+    return 1;
+  }
+}
+
+su_home_t *
+_su_home_ref_by(su_home_t *home,
+		   char const *file, unsigned line,
+		   char const *function)
+{
+  if (home)
+	  SU_DEBUG_0(("%ld %p - su_home_ref() => "MOD_ZU" by %s:%u: %s()\n", pthread_self(),
+		home, su_home_refcount(home) + 1, file, line, function));
+  return (su_home_t *)real_su_home_ref(home);
+}
+
+int
+_su_home_unref_by(su_home_t *home,
+		    char const *file, unsigned line,
+		    char const *function)
+{
+  if (home) {
+    size_t refcount = su_home_refcount(home) - 1;
+    int freed =  real_su_home_unref(home);
+
+    if (freed) refcount = 0;
+    SU_DEBUG_0(("%ld %p - su_home_unref() => "MOD_ZU" by %s:%u: %s()\n", pthread_self(),
+		home, refcount, file, line, function));
+    return freed;
+  }
+
+  return 0;
+}
+#else
+
+/** Create a new reference to a home object. */
+void *su_home_ref(su_home_t const *home)
+{
+  if (home) {
+    su_block_t *sub = MEMLOCK(home);
+
+    if (sub == NULL || sub->sub_ref == 0) {
+      assert(sub && sub->sub_ref != 0);
+      UNLOCK(home);
+      return NULL;
+    }
+
+    if (sub->sub_ref != REF_MAX)
+      sub->sub_ref++;
+    UNLOCK(home);
+  }
+  else
+    su_seterrno(EFAULT);
+
+  return (void *)home;
+}
+
+
 /**Unreference a su_home_t object.
  *
  * Decrements the reference count on home object and destroys and frees it
@@ -683,6 +785,7 @@
     return 1;
   }
 }
+#endif
 
 /** Return reference count of home. */
 size_t su_home_refcount(su_home_t *home)
@@ -1212,7 +1315,7 @@
     size_t size;
     void *preload;
 
-    size = n * ALIGN(isize);
+    size = n * __ALIGN(isize);
     if (size > 65535)		/* We have 16 bits... */
       size = 65535 & (ALIGNMENT - 1);
 
@@ -1233,13 +1336,13 @@
 {
   su_home_t *home;
   su_block_t *sub;
-  size_t homesize = ALIGN(sizeof *home);
-  size_t subsize = ALIGN(offsetof(su_block_t, sub_nodes[SUB_N_AUTO]));
+  size_t homesize = __ALIGN(sizeof *home);
+  size_t subsize = __ALIGN(offsetof(su_block_t, sub_nodes[SUB_N_AUTO]));
   size_t prepsize;
 
   char *p = area;
 
-  prepsize = homesize + subsize + (ALIGN((intptr_t)p) - (intptr_t)p);
+  prepsize = homesize + subsize + (__ALIGN((intptr_t)p) - (intptr_t)p);
 
   if (area == NULL || size < prepsize)
     return NULL;
@@ -1342,11 +1445,11 @@
 
   p = (char *)data - home->suh_blocks->sub_preload;
   p += sua->sua_size + MEMCHECK_EXTRA;
-  p = ALIGN(p);
+  p = __ALIGN(p);
 
   if (p == sub->sub_prused) {
     size_t p2 = (char *)data - sub->sub_preload + size + MEMCHECK_EXTRA;
-    p2 = ALIGN(p2);
+    p2 = __ALIGN(p2);
     if (p2 <= sub->sub_prsize) {
       /* Extend/reduce existing preload */
       if (sub->sub_stats) {
@@ -1546,14 +1649,24 @@
  * Otherwise the su_home_mutex_lock() will just increase the reference
  * count.
  */
+
+#if (defined(HAVE_MEMLEAK_LOG) && (HAVE_MEMLEAK_LOG != 1))
+int _su_home_mutex_lock(su_home_t *home, const char *file, unsigned int line, const char *function)
+#else
 int su_home_mutex_lock(su_home_t *home)
+#endif
+
 {
   int error;
 
   if (home == NULL)
     return su_seterrno(EFAULT);
 
+#if (defined(HAVE_MEMLEAK_LOG) && (HAVE_MEMLEAK_LOG != 1))
+  if (home->suh_blocks == NULL || !_su_home_ref_by(home, file, line, function))
+#else
   if (home->suh_blocks == NULL || !su_home_ref(home))
+#endif
     return su_seterrno(EINVAL);  /* Uninitialized home */
 
   if (!home->suh_lock)
@@ -1570,7 +1683,12 @@
  *
  * @sa su_home_unlock().
  */
+
+#if (defined(HAVE_MEMLEAK_LOG) && (HAVE_MEMLEAK_LOG != 1))
+int _su_home_mutex_unlock(su_home_t *home, const char *file, unsigned int line, const char *function)
+#else
 int su_home_mutex_unlock(su_home_t *home)
+#endif
 {
   if (home == NULL)
     return su_seterrno(EFAULT);
@@ -1584,7 +1702,11 @@
   if (home->suh_blocks == NULL)
     return su_seterrno(EINVAL), -1; /* Uninitialized home */
 
+#if (defined(HAVE_MEMLEAK_LOG) && (HAVE_MEMLEAK_LOG != 1))
+  _su_home_unref_by(home, file, line, function);
+#else
   su_home_unref(home);
+#endif
 
   return 0;
 }
@@ -1720,7 +1842,7 @@
 {
   su_home_stat_t *hs = sub->sub_stats;
 
-  size_t rsize = ALIGN(size);
+  size_t rsize = __ALIGN(size);
 
   hs->hs_rehash += (sub->sub_n != hs->hs_blocksize);
   hs->hs_blocksize = sub->sub_n;
@@ -1749,7 +1871,7 @@
 {
   su_home_stat_t *hs = sub->sub_stats;
 
-  size_t rsize = ALIGN(size);
+  size_t rsize = __ALIGN(size);
 
   if (preload) {
     hs->hs_frees.hsf_preload++;
diff -ur a/libsofia-sip-ua/su/su_bm.c b/libsofia-sip-ua/su/su_bm.c
--- a/libsofia-sip-ua/su/su_bm.c	2011-03-11 16:49:19.000000000 +0200
+++ b/libsofia-sip-ua/su/su_bm.c	2017-12-07 23:26:00.380842855 +0200
@@ -105,24 +105,6 @@
   return fwd;
 }
 
-#if !HAVE_MEMMEM
-/* Naive implementation of memmem() */
-static void *
-memmem(const void *haystack, size_t haystacklen,
-       const void *needle, size_t needlelen)
-{
-  size_t i;
-  char const *hs = haystack;
-
-  for (i = 0; i <= haystacklen - needlelen; i++) {
-    if (memcmp(hs + i, needle, needlelen) == 0)
-      return (void *)(hs + i);
-  }
-
-  return NULL;
-}
-#endif
-
 /** Search for a substring using Boyer-Moore algorithm.
  * @ingroup su_bm
  */
@@ -146,12 +128,8 @@
     return NULL;
   }
 
-  if (!fwd) {
-    if (nlen < 8 * sizeof (long)) /* Just guessing */
-      return memmem(haystack, hlen, needle, nlen);
-
+  if (!fwd)
     fwd = bm_memmem_study0(needle, nlen, fwd0);
-  }
 
   for (i = j = nlen - 1; i < hlen;) {
     unsigned char h = haystack[i];
@@ -205,7 +183,7 @@
     fwd->table[i] = (unsigned char)nlen;
 
   for (i = 0; i < nlen; i++) {
-    unsigned char n = tolower(needle[i]);
+    unsigned char n = tolower((const unsigned char)needle[i]);
     fwd->table[n] = (unsigned char)(nlen - i - 1);
   }
 
diff -ur a/libsofia-sip-ua/su/su.c b/libsofia-sip-ua/su/su.c
--- a/libsofia-sip-ua/su/su.c	2011-03-11 16:49:19.000000000 +0200
+++ b/libsofia-sip-ua/su/su.c	2017-12-07 23:26:00.356842725 +0200
@@ -270,42 +270,10 @@
 #endif
 
 #if SU_HAVE_WINSOCK
-
-static int
-get_extension_function_pointer(GUID const *id, void **return_function)
-{
-  int retval;
-  SOCKET s;
-  DWORD bytes_returned = 0;
-
-  *return_function = NULL;
-
-  s = su_socket(PF_INET, SOCK_STREAM, IPPROTO_TCP);
-  if (s == INVALID_SOCKET)
-    return -1;
-
-  retval = WSAIoctl(s, SIO_GET_EXTENSION_FUNCTION_POINTER,
-		    id, sizeof *id,
-		    return_function, sizeof *return_function,
-		    &bytes_returned, NULL, NULL);
-
-  closesocket(s);
-
-  return retval;
-}
-
-static BOOL (WINAPI *_DisconnectEx)(SOCKET, LPOVERLAPPED, DWORD, DWORD);
-
-#ifndef WSAID_DISCONNECTEX
-#define WSAID_DISCONNECTEX \
-{ 0x7fda2e11, 0x8630, 0x436f, { 0xa0, 0x31, 0xf5, 0x36, 0xa6, 0xee, 0xc1, 0x57 }}
-#endif
-
 int su_init(void)
 {
-  WORD wVersionRequested;
-  WSADATA wsaData;
-  GUID const disconnectExGuid = WSAID_DISCONNECTEX;
+  WORD	wVersionRequested;
+  WSADATA	wsaData;
 
   wVersionRequested = MAKEWORD(2, 0);
 
@@ -317,11 +285,6 @@
 
   su_log_init(su_log_global);
 
-  if (get_extension_function_pointer(&disconnectExGuid,
-				     (void **)&_DisconnectEx) == -1)
-    su_log("DisconnectEx: cannot load (%d): %s",
-	   su_errno(), su_strerror(su_errno()));
-
   return 0;
 }
 
@@ -333,10 +296,6 @@
 /** Close a socket descriptor. */
 int su_close(su_socket_t s)
 {
-  /* Implement close() semantics on XP or later */
-  if (_DisconnectEx)
-    _DisconnectEx(s, NULL, 0, 0);
-
   return closesocket(s);
 }
 
@@ -391,8 +350,15 @@
 
 int su_setreuseaddr(su_socket_t s, int reuse)
 {
-  return setsockopt(s, SOL_SOCKET, SO_REUSEADDR,
-		    (void *)&reuse, (socklen_t)sizeof(reuse));
+#ifdef SO_REUSEPORT
+	if (setsockopt(s, SOL_SOCKET, SO_REUSEPORT,
+				   (void *)&reuse, (socklen_t)sizeof(reuse)) < 0)
+		return -1;
+#endif
+	if (setsockopt(s, SOL_SOCKET, SO_REUSEADDR,
+				   (void *)&reuse, (socklen_t)sizeof(reuse)) < 0)
+		return -1;
+	return 0;
 }
 
 
@@ -475,7 +441,7 @@
 ssize_t su_recvfrom(su_socket_t s, void *buffer, size_t length, int flags,
 		    su_sockaddr_t *from, socklen_t *fromlen)
 {
-  int retval, ilen;
+  int retval, ilen = 0;
 
   if (fromlen)
     ilen = *fromlen;
@@ -545,19 +511,27 @@
 
 
 #else
-
+#include <sched.h>
 issize_t su_vsend(su_socket_t s,
 		  su_iovec_t const iov[], isize_t iovlen, int flags,
 		  su_sockaddr_t const *su, socklen_t sulen)
 {
   struct msghdr hdr[1] = {{0}};
+  issize_t rv;
+  int sanity = 100;
 
   hdr->msg_name = (void *)su;
   hdr->msg_namelen = sulen;
   hdr->msg_iov = (struct iovec *)iov;
   hdr->msg_iovlen = iovlen;
-
-  return sendmsg(s, hdr, flags);
+  
+  do {
+	  if ((rv = sendmsg(s, hdr, flags)) == -1) {
+		  if (errno == EAGAIN) sched_yield();
+	  }
+  } while (--sanity > 0 && rv == -1 && (errno == EAGAIN || errno == EINTR));
+  
+  return rv;
 }
 
 issize_t su_vrecv(su_socket_t s, su_iovec_t iov[], isize_t iovlen, int flags,
diff -ur a/libsofia-sip-ua/su/su.docs b/libsofia-sip-ua/su/su.docs
--- a/libsofia-sip-ua/su/su.docs	2011-03-11 16:49:19.000000000 +0200
+++ b/libsofia-sip-ua/su/su.docs	2017-12-07 23:26:00.360842746 +0200
@@ -47,6 +47,24 @@
  * level.
  */
 
+/**@maindefgroup su OS Utilities
+ *
+ * The "su" module contains OS utilies for Sofia.
+ *
+ * The @b su is a simple, portable socket/timing/synchronizing library
+ * developed for Sofia communications software. Currently, interface to
+ * it consists of following parts:
+ *
+ * - <sofia-sip/su_types.h> - basic integer types
+ * - <a href=group_su_socket.html>su_socket</a> - socket functions
+ * - <a href=group_su_wait.html>su_wait</a> - synchronization functions
+ * - <a href=group_su_time.html>su_time</a> - time functions
+ * - <a href=group_su_alloc.html>su_alloc</a> - memory management functions
+ * - <a href=group_su_log.html>su_log</a> - generic logging functions
+ * - <a href=group_su_tag.html>su_tag</a> - tag list function
+ * - <a href=group_su_md5.html>su_md5</a> - MD5 hashing
+ */
+
 /**@defgroup su_programs Shell Programs
  *
  * The @b su module provides few shell utilities:
diff -ur a/libsofia-sip-ua/su/su_errno.c b/libsofia-sip-ua/su/su_errno.c
--- a/libsofia-sip-ua/su/su_errno.c	2011-03-11 16:49:19.000000000 +0200
+++ b/libsofia-sip-ua/su/su_errno.c	2017-12-07 23:26:00.396842942 +0200
@@ -157,4 +157,7 @@
   return strerror(errcode);
 }
 
+int su_errno(void) { return errno; }
+int su_seterrno(int n) { errno = n; return -1; }
+
 #endif /* SU_HAVE_WINSOCK */
diff -ur a/libsofia-sip-ua/su/su_kqueue_port.c b/libsofia-sip-ua/su/su_kqueue_port.c
--- a/libsofia-sip-ua/su/su_kqueue_port.c	2011-03-11 16:49:19.000000000 +0200
+++ b/libsofia-sip-ua/su/su_kqueue_port.c	2017-12-07 23:26:00.404842985 +0200
@@ -46,6 +46,17 @@
 
 #include <sys/event.h>
 
+/* INT_TO_UDATA() macros from https://github.com/libevent/libevent */
+
+/* Some platforms apparently define the udata field of struct kevent as
+ * intptr_t, whereas others define it as void*.  There doesn't seem to be an
+ * easy way to tell them apart via autoconf, so we need to use OS macros. */
+#if defined(HAVE_INTTYPES_H) && !defined(__OpenBSD__) && !defined(__FreeBSD__) && !defined(__darwin__) && !defined(__APPLE__) && !defined(__DragonFly__)
+#define INT_TO_UDATA(x) ((intptr_t)(x))
+#else
+#define INT_TO_UDATA(x) ((void*)(intptr_t)(x))
+#endif
+
 #define SU_ENABLE_MULTISHOT_KQUEUE 1
 
 #include <stdlib.h>
@@ -246,7 +257,7 @@
   i = ser->ser_id;
 
   flags = (wait->events & SU_WAIT_IN) ? EV_ADD : EV_ADD | EV_DISABLE;
-  EV_SET(ev, wait->fd, EVFILT_READ, flags, 0, 0, (void *)(intptr_t)i);
+  EV_SET(ev, wait->fd, EVFILT_READ, flags, 0, 0, INT_TO_UDATA(i));
   if (kevent(self->sup_kqueue, ev, 1, NULL, 0, NULL) == -1) {
     SU_DEBUG_0(("kevent((%u, %s, %u, %p)) failed: %s\n",
 				wait->fd, "EVFILT_READ", flags, (void *)(intptr_t)i, strerror(errno)));
@@ -254,13 +265,13 @@
   }
 
   flags = (wait->events & SU_WAIT_OUT) ? EV_ADD : EV_ADD | EV_DISABLE;
-  EV_SET(ev, wait->fd, EVFILT_WRITE, flags, 0, 0, (void *)(intptr_t)i);
+  EV_SET(ev, wait->fd, EVFILT_WRITE, flags, 0, 0, INT_TO_UDATA(i));
   if (kevent(self->sup_kqueue, ev, 1, NULL, 0, NULL) == -1) {
     int error = errno;
     SU_DEBUG_0(("kevent((%u, %s, %u, %p)) failed: %s\n",
 				wait->fd, "EVFILT_WRITE", flags, (void *)(intptr_t)i, strerror(error)));
 
-    EV_SET(ev, wait->fd, EVFILT_READ, EV_DELETE, 0, 0, (void *)(intptr_t)i);
+    EV_SET(ev, wait->fd, EVFILT_READ, EV_DELETE, 0, 0, INT_TO_UDATA(i));
     kevent(self->sup_kqueue, ev, 1, NULL, 0, NULL);
 
     errno = error;
@@ -298,14 +309,14 @@
 
   wait = ser->ser_wait;
 
-  EV_SET(ev, wait->fd, EVFILT_READ, EV_DELETE, 0, 0, (void *)(intptr_t)i);
+  EV_SET(ev, wait->fd, EVFILT_READ, EV_DELETE, 0, 0, INT_TO_UDATA(i));
   if (kevent(self->sup_kqueue, ev, 1, NULL, 0, NULL) == -1) {
     SU_DEBUG_0(("remove kevent((%u, %s, %s, %p)) failed: %s\n",
 				wait->fd, "EVFILT_READ", "EV_DELETE", (void *)(intptr_t)i,
 		strerror(errno)));
   }
 
-  EV_SET(ev, wait->fd, EVFILT_WRITE, EV_DELETE, 0, 0, (void *)(intptr_t)i);
+  EV_SET(ev, wait->fd, EVFILT_WRITE, EV_DELETE, 0, 0, INT_TO_UDATA(i));
   if (kevent(self->sup_kqueue, ev, 1, NULL, 0, NULL) == -1) {
     SU_DEBUG_0(("remove kevent((%u, %s, %s, %p)) failed: %s\n",
 				wait->fd, "EVFILT_WRITE", "EV_DELETE", (void *)(intptr_t)i,
@@ -465,7 +476,7 @@
   wait->events = events;
 
   flags = (wait->events & SU_WAIT_IN) ? EV_ADD | EV_ENABLE : EV_ADD | EV_DISABLE;
-  EV_SET(ev, wait->fd, EVFILT_READ, flags, 0, 0, (void *)(intptr_t)index);
+  EV_SET(ev, wait->fd, EVFILT_READ, flags, 0, 0, INT_TO_UDATA(index));
   if (kevent(self->sup_kqueue, ev, 1, NULL, 0, NULL) == -1) {
     SU_DEBUG_0(("modify kevent((%u, %s, %s, %p)) failed: %s\n",
 		wait->fd, "EVFILT_READ",
@@ -474,7 +485,7 @@
   }
 
   flags = (wait->events & SU_WAIT_OUT) ? EV_ADD | EV_ENABLE : EV_ADD | EV_DISABLE;
-  EV_SET(ev, wait->fd, EVFILT_WRITE, flags, 0, 0, (void *)(intptr_t)index);
+  EV_SET(ev, wait->fd, EVFILT_WRITE, flags, 0, 0, INT_TO_UDATA(index));
   if (kevent(self->sup_kqueue, ev, 1, NULL, 0, NULL) == -1) {
     SU_DEBUG_0(("modify kevent((%u, %s, %s, %p)) failed: %s\n",
 		wait->fd, "EVFILT_WRITE",
diff -ur a/libsofia-sip-ua/su/su_localinfo.c b/libsofia-sip-ua/su/su_localinfo.c
--- a/libsofia-sip-ua/su/su_localinfo.c	2011-03-11 16:49:19.000000000 +0200
+++ b/libsofia-sip-ua/su/su_localinfo.c	2017-12-07 23:26:00.416843050 +0200
@@ -194,7 +194,8 @@
 int su_getlocalinfo(su_localinfo_t const *hints,
 		    su_localinfo_t **return_localinfo)
 {
-  int error = 0, ip4 = 0, ip6 = 0;
+  int error = 0, ip4 = 0;
+  int ip6 = 0;
   su_localinfo_t *result = NULL, **rr = &result;
   su_localinfo_t hh[1] = {{ 0 }};
 
@@ -231,7 +232,11 @@
     break;
 
   case 0:
-    ip6 = ip4 = 1;
+    ip4 = 1;
+#if SU_HAVE_IN6  
+    ip6 = 1;
+#endif
+
     break;
 
   default:
@@ -260,6 +265,9 @@
   }
 #endif
 
+  if (ip6) {
+    /* Required to make compiler happy */  
+  }
   if (!result)
     error = ELI_NOADDRESS;
 
@@ -401,8 +409,10 @@
 li_scope6(struct in6_addr const *ip6)
 {
   if (IN6_IS_ADDR_V4MAPPED(ip6) || IN6_IS_ADDR_V4COMPAT(ip6)) {
-    uint32_t ip4 = *(uint32_t *)(ip6->s6_addr + 12);
-    return li_scope4(ip4);
+	  uint32_t *u = (uint32_t *)(ip6->s6_addr + 12);
+
+	  uint32_t ip4 = *u;
+	  return li_scope4(ip4);
   }
   else if (IN6_IS_ADDR_LOOPBACK(ip6))
     return LI_SCOPE_HOST;
@@ -599,7 +609,7 @@
   ifc.ifc_len = numifs * sizeof (struct ifreq);
   buffer = malloc(sizeof(su_localinfo_t) + ifc.ifc_len + su_xtra);
   if (!buffer) {
-    SU_DEBUG_1(("su_localinfo: memory exhausted\n"));
+    SU_DEBUG_1(("su_localinfo: memory exhausted\n" VA_NONE));
     error = ELI_MEMORY;
     goto err;
   }
@@ -1250,7 +1260,7 @@
 	flags |= LI_NUMERIC;
 
     if (!(li = calloc(1, sizeof(*li) + sulen + ifnamelen))) {
-      SU_DEBUG_1(("su_getlocalinfo: memory exhausted\n"));
+		SU_DEBUG_1(("su_getlocalinfo: memory exhausted\n" VA_NONE));
       error = ELI_MEMORY;
       break;
     }
@@ -1619,7 +1629,7 @@
     if (error) {
       if ((flags & LI_NAMEREQD) == LI_NAMEREQD)
 	return 1;
-      SU_DEBUG_7(("li_name: getnameinfo() failed\n"));
+      SU_DEBUG_7(("li_name: getnameinfo() failed\n" VA_NONE));
       if (!su_inet_ntop(su->su_family, SU_ADDR(su), name, sizeof name))
 	return ELI_RESOLVER;
     }
diff -ur a/libsofia-sip-ua/su/su_os_nw.c b/libsofia-sip-ua/su/su_os_nw.c
--- a/libsofia-sip-ua/su/su_os_nw.c	2011-03-11 16:49:19.000000000 +0200
+++ b/libsofia-sip-ua/su/su_os_nw.c	2017-12-07 23:26:00.436843159 +0200
@@ -105,7 +105,7 @@
   su_network_changed_t *snc2;
   su_msg_r rmsg = SU_MSG_R_INIT;
 
-  SU_DEBUG_7(("nw_changed_cb: entering.\n"));
+  SU_DEBUG_7(("nw_changed_cb: entering.\n" VA_NONE));
 
   if (su_msg_create(rmsg,
 		    su_root_task(snc->su_root),
diff -ur a/libsofia-sip-ua/su/su_pthread_port.c b/libsofia-sip-ua/su/su_pthread_port.c
--- a/libsofia-sip-ua/su/su_pthread_port.c	2011-03-11 16:49:19.000000000 +0200
+++ b/libsofia-sip-ua/su/su_pthread_port.c	2017-12-07 23:26:00.456843267 +0200
@@ -251,6 +251,8 @@
 
   int thread_created = 0;
   pthread_t tid;
+  pthread_attr_t attr;
+  struct sched_param param;
 
   arg.create = create;
   arg.parent = parent;
@@ -258,11 +260,28 @@
   arg.init = init;
   arg.deinit = deinit;
 
+  pthread_attr_init(&attr);
+  pthread_attr_setstacksize(&attr, 244);
+  pthread_attr_getschedparam(&attr, &param);
+  param.sched_priority = 99;
+  pthread_attr_setschedparam(&attr, &param);
+
   pthread_mutex_lock(arg.mutex);
-  if (pthread_create(&tid, NULL, su_pthread_port_clone_main, &arg) == 0) {
+  if (pthread_create(&tid, &attr, su_pthread_port_clone_main, &arg) == 0) {
+#ifdef HAVE_PTHREAD_SETSCHEDPARAM
+	  int policy;
+	  struct sched_param param;
+
+	  pthread_getschedparam(tid, &policy, &param);
+	  param.sched_priority = 99;
+	  pthread_setschedparam(tid, policy, &param);
+#endif
+
     pthread_cond_wait(arg.cv, arg.mutex);
     thread_created = 1;
   }
+  pthread_attr_destroy(&attr);
+
   pthread_mutex_unlock(arg.mutex);
 
   pthread_mutex_destroy(arg.mutex);
diff -ur a/libsofia-sip-ua/su/su_root.c b/libsofia-sip-ua/su/su_root.c
--- a/libsofia-sip-ua/su/su_root.c	2011-03-11 16:49:19.000000000 +0200
+++ b/libsofia-sip-ua/su/su_root.c	2017-12-07 23:26:00.464843310 +0200
@@ -152,7 +152,7 @@
 {
   assert(task);
 
-  memset(task, 0, sizeof(task));
+  memset(task, 0, sizeof(su_task_r));
   return task;
 }
 
@@ -422,7 +422,6 @@
  *
  * Allocate and initialize the instance of su_root_t.
  *
- * @param self      pointer to a root object.
  * @param magic     pointer to user data
  *
  * @return A pointer to allocated su_root_t instance, NULL on error.
@@ -714,7 +713,7 @@
  * activated, however, they are deferred no longer than the maximum defer
  * time. The maximum defer time is 15 seconds by default.
  *
- * @param self pointer to root object
+ * @param root pointer to root object
  *
  * @return Maximum defer time
  *
diff -ur a/libsofia-sip-ua/su/su_string.c b/libsofia-sip-ua/su/su_string.c
--- a/libsofia-sip-ua/su/su_string.c	2011-03-11 16:49:19.000000000 +0200
+++ b/libsofia-sip-ua/su/su_string.c	2017-12-07 23:26:00.480843397 +0200
@@ -178,12 +178,14 @@
   }
 }
 
- /** Check if two strings match.
+/** Check if two strings match.
  *
  * Compare two strings. Accept NULL arguments: two NULL pointers match each
  * other, but otherwise NULL pointer does not match anything else, not even
  * empty string.
  *
+ * @param s1 
+ *
  * @retval One if @a s1 matches @a s2
  * @retval Zero if @a s1 does not match @a s2
  */
@@ -476,7 +478,7 @@
  * of bytes not in @a reject.
  *
  * @param mem        pointer to memory area
- *ÎÂ @param memlen     size of @a mem in bytes
+ *Â @param memlen     size of @a mem in bytes
  * @param reject     pointer to table containing bytes to reject
  * @param rejectlen  size of @a reject table
  *
diff -ur a/libsofia-sip-ua/su/su_taglist.c b/libsofia-sip-ua/su/su_taglist.c
--- a/libsofia-sip-ua/su/su_taglist.c	2011-03-11 16:49:19.000000000 +0200
+++ b/libsofia-sip-ua/su/su_taglist.c	2017-12-07 23:26:00.492843462 +0200
@@ -60,8 +60,10 @@
 #include <sofia-sip/su_string.h>
 
 #ifndef HAVE_STRTOULL
+#if !((defined(WIN32) || defined(_WIN32)) && (_MSC_VER >= 1800))
 unsigned longlong strtoull(const char *, char **, int);
 #endif
+#endif
 
 /**@defgroup su_tag Tag Item Lists
  *
@@ -411,7 +413,7 @@
 #if !defined(NDEBUG)
     else if (tt->tt_class && tt->tt_class->tc_ref_set) {
       fprintf(stderr, "WARNING: tag %s::%s directly used by tl_gets()\n",
-	      tt->tt_ns, tt->tt_name);
+			  tt->tt_ns ? tt->tt_ns : "", tt->tt_name ? tt->tt_name : "");
       assert(tt->tt_class == ref_tag_class);
     }
 #endif
diff -ur a/libsofia-sip-ua/su/su_time0.c b/libsofia-sip-ua/su/su_time0.c
--- a/libsofia-sip-ua/su/su_time0.c	2011-03-11 16:49:19.000000000 +0200
+++ b/libsofia-sip-ua/su/su_time0.c	2017-12-07 23:26:00.508843549 +0200
@@ -69,6 +69,13 @@
 void (*_su_time)(su_time_t *tv);
 uint64_t (*_su_nanotime)(uint64_t *);
 
+static su_time_func_t custom_time_func = NULL;
+
+void su_set_time_func(su_time_func_t func) {
+	custom_time_func = func;
+}
+
+
 /** Get current time.
  *
  * The function @c su_time() fills its argument with the current NTP
@@ -78,21 +85,37 @@
  */
 void su_time(su_time_t *tv)
 {
-#if HAVE_GETTIMEOFDAY
-  if (tv) {
-    gettimeofday((struct timeval *)tv, NULL);
-    tv->tv_sec += NTP_EPOCH;
-  }
-#elif HAVE_FILETIME
+#if HAVE_FILETIME
   union {
     FILETIME       ft[1];
     ULARGE_INTEGER ull[1];
   } date;
+#endif
+	su_time_t ltv = {0,0};
+
+	if (custom_time_func) {
+		custom_time_func(&ltv);
+		if (tv) *tv = ltv;
+		return;
+	}
+
+#if HAVE_CLOCK_GETTIME
+	struct timespec ctv = {0};
+	if (clock_gettime(CLOCK_REALTIME, &ctv) == 0) {
+		ltv.tv_sec = ctv.tv_sec + NTP_EPOCH;
+		ltv.tv_usec = ctv.tv_nsec / 1000;
+    }
+#elif HAVE_GETTIMEOFDAY
+	struct timeval tmp_tv = {0,0};
+    gettimeofday(&tmp_tv, NULL);
+	ltv.tv_sec = tmp_tv.tv_sec + NTP_EPOCH;
+	ltv.tv_usec = (unsigned long)tmp_tv.tv_usec;
+#elif HAVE_FILETIME
 
   GetSystemTimeAsFileTime(date.ft);
 
-  tv->tv_usec = (unsigned long) ((date.ull->QuadPart % E7) / 10);
-  tv->tv_sec = (unsigned long) ((date.ull->QuadPart / E7) -
+  ltv.tv_usec = (unsigned long) ((date.ull->QuadPart % E7) / 10);
+  ltv.tv_sec = (unsigned long) ((date.ull->QuadPart / E7) -
     /* 1900-Jan-01 - 1601-Jan-01: 299 years, 72 leap years */
     (299 * 365 + 72) * 24 * 60 * (uint64_t)60);
 #else
@@ -100,7 +123,9 @@
 #endif
 
   if (_su_time)
-    _su_time(tv);
+    _su_time(&ltv);
+
+  if (tv) *tv = ltv;
 }
 
 /** Get current time as nanoseconds since epoch.
@@ -121,7 +146,7 @@
 
 #if HAVE_CLOCK_GETTIME
   {
-    struct timespec tv;
+    struct timespec tv = {0,0};
 
     if (clock_gettime(CLOCK_REALTIME, &tv) == 0) {
       now = ((su_nanotime_t)tv.tv_sec + NTP_EPOCH) * E9 + tv.tv_nsec;
@@ -149,7 +174,7 @@
   }
 #elif HAVE_GETTIMEOFDAY
   {
-    struct timeval tv;
+    struct timeval tv = {0,0};
 
     gettimeofday(&tv, NULL);
 
@@ -181,7 +206,7 @@
 {
 #if HAVE_CLOCK_GETTIME && CLOCK_MONOTONIC
   {
-    struct timespec tv;
+    struct timespec tv = {0,0};
 
     if (clock_gettime(CLOCK_MONOTONIC, &tv) == 0) {
       su_nanotime_t now = (su_nanotime_t)tv.tv_sec * E9 + tv.tv_nsec;
@@ -194,7 +219,7 @@
 
 #if HAVE_NANOUPTIME
   {
-    struct timespec tv;
+    struct timespec tv = {0,0};
 
     nanouptime(&tv);
     now = (su_nanotime_t)tv.tv_sec * E9 + tv.tv_nsec;
@@ -204,7 +229,7 @@
   }
 #elif HAVE_MICROUPTIME
   {
-    struct timeval tv;
+    struct timeval tv = {0,0};
 
     microuptime(&tv);
     now = (su_nanotime_t)tv.tv_sec * E9 + tv.tv_usec * 1000;
diff -ur a/libsofia-sip-ua/su/su_time.c b/libsofia-sip-ua/su/su_time.c
--- a/libsofia-sip-ua/su/su_time.c	2011-03-11 16:49:19.000000000 +0200
+++ b/libsofia-sip-ua/su/su_time.c	2017-12-07 23:26:00.508843549 +0200
@@ -398,7 +398,7 @@
   static int init = 0;
   static clockid_t cpu = CLOCK_REALTIME;
 
-# define CLOCK_GETTIMEOFDAY 0xdedbeefUL
+# define CLOCK_GETTIMEOFDAY ((clockid_t)-1)
 
   if (init == 0) {
     init = 1;
diff -ur a/libsofia-sip-ua/su/su_timer.c b/libsofia-sip-ua/su/su_timer.c
--- a/libsofia-sip-ua/su/su_timer.c	2011-03-11 16:49:19.000000000 +0200
+++ b/libsofia-sip-ua/su/su_timer.c	2017-12-07 23:26:00.512843571 +0200
@@ -203,9 +203,18 @@
     return free(memory), NULL;
 }
 
+#ifdef __clang__
+#pragma clang diagnostic push
+#pragma clang diagnostic ignored "-Wunused-function"
+#endif
+
 HEAP_BODIES(su_inline, su_timer_queue_t, timers_, su_timer_t *,
 	    timers_less, timers_set, timers_alloc, NULL);
 
+#ifdef __clang__
+#pragma clang diagnostic pop
+#endif
+
 /**@internal Set the timer.
  *
  * @retval 0 when successful (always)
diff -ur a/libsofia-sip-ua/su/su_uniqueid.c b/libsofia-sip-ua/su/su_uniqueid.c
--- a/libsofia-sip-ua/su/su_uniqueid.c	2011-03-11 16:49:19.000000000 +0200
+++ b/libsofia-sip-ua/su/su_uniqueid.c	2017-12-07 23:26:00.516843593 +0200
@@ -110,7 +110,8 @@
 static union state *
 get_state(void)
 {
-  static union state *retval, state0[1];
+  static union state state0[1];
+  union state *retval;
 
 #if SU_HAVE_PTHREADS
 
@@ -196,8 +197,10 @@
 sofia_su_uniqueid_destructor(void)
 {
 #if HAVE_DEV_URANDOM
-  if (urandom)
-    fclose(urandom);
+	if (urandom) {
+		fclose(urandom);
+		urandom=NULL;
+	}
 #endif	/* HAVE_DEV_URANDOM */
 
 #if SU_HAVE_PTHREADS
@@ -217,8 +220,9 @@
 #endif
 #endif
 
+#define SIZEOF_NODE 6
 static
-void init_node(uint8_t node[6])
+void init_node(uint8_t node[SIZEOF_NODE])
 {
 #if HAVE_GETIFADDRS && HAVE_SOCKADDR_LL
   struct ifaddrs *ifa, *results;
@@ -239,7 +243,7 @@
 	continue;
       }
 
-      memcpy(node, sll->sll_addr, 6);
+      memcpy(node, sll->sll_addr, SIZEOF_NODE);
 
       break;
 #endif
@@ -252,16 +256,16 @@
   }
 #endif
 
-  su_randmem(node, 6);
+  su_randmem(node, SIZEOF_NODE);
   node[0] |= 1;			/* "multicast" address */
 }
 
-static unsigned char node[6];
+static unsigned char node[SIZEOF_NODE];
 
 size_t su_node_identifier(void *address, size_t addrlen)
 {
-  if (addrlen > sizeof node)
-    addrlen = sizeof node;
+  if (addrlen > SIZEOF_NODE)
+    addrlen = SIZEOF_NODE;
 
   su_guid_generate(NULL);
   memcpy(address, node, addrlen);
diff -ur a/libsofia-sip-ua/su/su_wait.c b/libsofia-sip-ua/su/su_wait.c
--- a/libsofia-sip-ua/su/su_wait.c	2011-03-11 16:49:19.000000000 +0200
+++ b/libsofia-sip-ua/su/su_wait.c	2017-12-07 23:26:00.524843636 +0200
@@ -224,10 +224,37 @@
 #if SU_HAVE_WINSOCK
   DWORD i;
 
-  if (n > 0)
-    i = WSAWaitForMultipleEvents(n, waits, FALSE, timeout, FALSE);
-  else
+  if (n > 0) {
+    #define WAIT_EVENT_BLOCK_SIZE WSA_MAXIMUM_WAIT_EVENTS
+
+    /* Handle at most WAIT_EVENT_BLOCK_SIZE wait objects at a time */
+    int blocks = (n + WAIT_EVENT_BLOCK_SIZE - 1) / WAIT_EVENT_BLOCK_SIZE;
+    int block_index = 0;
+    int first_wait_index = 0;
+    int millisec_per_block = timeout / blocks;
+
+    if (timeout > 0)
+      millisec_per_block  = max(1, millisec_per_block);
+
+    i = WSA_WAIT_TIMEOUT;
+    for(block_index = 0; block_index < blocks; block_index++,first_wait_index+=WAIT_EVENT_BLOCK_SIZE)
+    {
+      int remaining_blocks = n - block_index * WAIT_EVENT_BLOCK_SIZE;
+      int waits_in_current_block = min( WAIT_EVENT_BLOCK_SIZE, remaining_blocks );
+
+      i = WSAWaitForMultipleEvents(waits_in_current_block, waits + first_wait_index, FALSE, millisec_per_block, FALSE);
+      if (i != WSA_WAIT_TIMEOUT) {
+        /* Did not timeout, return something NOW, ignore remaining blocks */
+        if (i != WSA_WAIT_FAILED) {
+          /* Return the right index */
+          i += first_wait_index;
+        }
+        break;
+      }
+    }
+  } else {
     return Sleep(timeout), SU_WAIT_TIMEOUT;
+  }
 
   if (i == WSA_WAIT_TIMEOUT)
     return SU_WAIT_TIMEOUT;
diff -ur a/libsofia-sip-ua/su/test_memmem.c b/libsofia-sip-ua/su/test_memmem.c
--- a/libsofia-sip-ua/su/test_memmem.c	2011-03-11 16:49:19.000000000 +0200
+++ b/libsofia-sip-ua/su/test_memmem.c	2017-12-07 23:26:00.544843745 +0200
@@ -36,7 +36,6 @@
 #include "config.h"
 
 #include <sofia-sip/su_string.h>
-#include <sofia-sip/su_bm.h>
 
 #include <stddef.h>
 #include <stdlib.h>
@@ -44,6 +43,11 @@
 #include <stdio.h>
 #include <assert.h>
 
+#if !HAVE_MEMMEM
+void *memmem(const void *haystack, size_t haystacklen,
+	     const void *needle, size_t needlelen);
+#endif
+
 #include <string.h>
 
 static int test_flags = 0;
@@ -59,7 +63,6 @@
   exit(exitcode);
 }
 
-
 static int test_notfound(void);
 static int test_pattern(void);
 
@@ -72,29 +75,27 @@
   char const *a;
   BEGIN();
 
-  TEST_P(bm_memmem(haystack, 12, needle, 3, NULL), haystack + 2);
-  TEST_P(bm_memmem(needle, 3, haystack, 12, NULL), NULL);
+  TEST_P(memmem(haystack, 12, needle, 3), haystack + 2);
+  TEST_P(memmem(needle, 3, haystack, 12), NULL);
 
 #if HAVE_MEMMEM
-  if (bm_memmem(haystack, 12, "", 0, NULL) == NULL) {
+  if (memmem(haystack, 12, "", 0) == NULL) {
     fprintf(stderr, "test_memmem.c: "
 	    "*** WARNING: system memmem() fails with empty needle ***\n");
   }
   else
 #endif
   {
-    TEST_P(bm_memmem(haystack, 12, "", 0, NULL), haystack);
-    TEST_P(bm_memmem(haystack, 12, null, 0, NULL), haystack);
-    TEST_P(bm_memmem(haystack, 0, "", 0, NULL), haystack);
-    TEST_P(bm_memmem(haystack, 0, null, 0, NULL), haystack);
+    TEST_P(memmem(haystack, 12, "", 0), haystack);
+    TEST_P(memmem(haystack, 12, null, 0), haystack);
+    TEST_P(memmem(haystack, 0, "", 0), haystack);
+    TEST_P(memmem(haystack, 0, null, 0), haystack);
   }
 
-  TEST_P(bm_memmem(haystack + 2, 3, needle, 3, NULL), haystack + 2);
-  TEST_P(bm_memmem(haystack + 2, 2, needle, 3, NULL), NULL);
-
-  a = "a\0bc";
-  TEST_P(bm_memmem(a, 4, "a\0bc", 4, NULL), a);
-  TEST_P(bm_memmem(a, 4, "\0bc", 3, NULL), a + 1);
+  TEST_P(memmem(haystack + 2, 3, needle, 3), haystack + 2);
+  TEST_P(memmem(haystack + 2, 2, needle, 3), NULL);
+  TEST_P(memmem(a = "a\0bc", 4, "a\0bc", 4), a);
+  TEST_P(memmem(a, 4, "\0bc", 3), a + 1);
 
   END();
 }
diff -ur a/libsofia-sip-ua/su/torture_su_alloc.c b/libsofia-sip-ua/su/torture_su_alloc.c
--- a/libsofia-sip-ua/su/torture_su_alloc.c	2011-03-11 16:49:19.000000000 +0200
+++ b/libsofia-sip-ua/su/torture_su_alloc.c	2017-12-07 23:26:00.572843896 +0200
@@ -151,8 +151,7 @@
   su_home_preload(home, 1, 1024 + 2 * 8);
 
   TEST_1(c = su_zalloc(home, 64)); p0 = c; p1 = c + 1024;
-  c0 = c;
-  TEST_P(c = su_realloc(home, c0, 127), c0);
+  TEST_P(c = su_realloc(home, c0 = c, 127), c0);
 
   TEST_1(c = c0 = su_zalloc(home, 1024 - 128));
   TEST_1(p0 <= c); TEST_1(c < p1);
diff -ur a/libsofia-sip-ua/su/torture_su.c b/libsofia-sip-ua/su/torture_su.c
--- a/libsofia-sip-ua/su/torture_su.c	2011-03-11 16:49:19.000000000 +0200
+++ b/libsofia-sip-ua/su/torture_su.c	2017-12-07 23:26:00.568843875 +0200
@@ -194,7 +194,6 @@
   l = su_socket(AF_INET, SOCK_STREAM, 0); TEST_1(l != -1);
   s = su_socket(AF_INET, SOCK_STREAM, 0); TEST_1(s != -1);
 
-  TEST(su_setblocking(l, 1), 0);
   memset(&su, 0, sulen);
   su.su_len = sulen;
   su.su_family = AF_INET;
diff -ur a/libsofia-sip-ua/tport/certificates.html b/libsofia-sip-ua/tport/certificates.html
--- a/libsofia-sip-ua/tport/certificates.html	2011-03-11 16:49:19.000000000 +0200
+++ b/libsofia-sip-ua/tport/certificates.html	2017-12-07 23:26:00.624844178 +0200
@@ -1,61 +1,61 @@
-<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
-
-<html>
-<head>
-<title>Generating SSL/TLS certificates for SIP agents and proxies</title>
-</head>
-<body>
-<h1>Generating SSL/TLS certificates for SIP agents and proxies</h1>
-<h2>Prerequisites</h2>
-The openssl v0.96 or higher must be installed to create the certificates.
-
-<h2>To generate the random seed file</h2>
-<strong><pre>$ tport_rand tls_seed.dat
-</pre>
-</strong>
-
-<h2>To generate the root authority certificate</h2>
-<strong><pre>
-$ make_root_cert.pl \
-     -cn &lt;root common name&gt;\
-     -dns &lt;comma separated list of root dns names&gt;\
-    [-prefix &lt;prefix for the generated files&gt; (default root)]\
-    [-rand &lt;random seed file&gt; (default tls_seed.dat)]</pre></strong>
-
-This command will generate files <strong>&lt;prefix&gt;key.pem</strong> (root private key), 
-<strong>&lt;prefix&gt;cert.pem</strong> (root certificate) and <strong>&lt;prefix&gt;.pem</strong> (combination
-of the key and the certificate). The latter file will be used to sign the node certificates.
-
-<h2>To generate a certificate for a single node (user agent or proxy)</h2>
-<strong><pre>
-$ make_node_cert.pl \
-     -cn &lt;node common name&gt;\
-     -dns &lt;comma separated list of node dns names&gt;\
-    [-ca &lt;cafile&gt; (default root.pem)]\
-    [-prefix &lt;prefix for the generated files&gt; (default agent)]\
-    [-rand &lt;random seed file&gt; (default tls_seed.dat)]
-</pre></strong>
-This command will generate files <strong>&lt;prefix&gt;key.pem </strong> (node private key), 
-<strong>&lt;prefix&gt;cert.pem</strong> (node certificate) and <strong>&lt;prefix&gt;.pem</strong> (combination
-of the key and the certificate). The certificate has been signed with ca certificate
-contained in <strong>&lt;cafile&gt;</strong>.
-
-<h2>Installing the certificates to the nodes</h2>
-
-<ol>
-
-<li>Copy the root certificate file (<strong>rootcert.pem</strong> by default - <strong>not root.pem or rootkey.pem!</strong>), 
-the combined node certificate+key file (<strong>agent.pem</strong>) and <strong>tls_seed.dat</strong> to the tls configuration
-directory (default <strong>$HOME/.sip/auth</strong>)</li>
-
-<li>Rename <strong>rootcert.pem</strong> as <strong>cafile.pem</strong></li>
-</ol>
-<p>
-<strong>Note that files agent.pem and tls_seed.dat must be kept secret to
-ensure secure connection</strong>  
-</p>
-
-</ol>
-</body>
-</html>
-
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
+
+<html>
+<head>
+<title>Generating SSL/TLS certificates for SIP agents and proxies</title>
+</head>
+<body>
+<h1>Generating SSL/TLS certificates for SIP agents and proxies</h1>
+<h2>Prerequisites</h2>
+The openssl v0.96 or higher must be installed to create the certificates.
+
+<h2>To generate the random seed file</h2>
+<strong><pre>$ tport_rand tls_seed.dat
+</pre>
+</strong>
+
+<h2>To generate the root authority certificate</h2>
+<strong><pre>
+$ make_root_cert.pl \
+     -cn &lt;root common name&gt;\
+     -dns &lt;comma separated list of root dns names&gt;\
+    [-prefix &lt;prefix for the generated files&gt; (default root)]\
+    [-rand &lt;random seed file&gt; (default tls_seed.dat)]</pre></strong>
+
+This command will generate files <strong>&lt;prefix&gt;key.pem</strong> (root private key), 
+<strong>&lt;prefix&gt;cert.pem</strong> (root certificate) and <strong>&lt;prefix&gt;.pem</strong> (combination
+of the key and the certificate). The latter file will be used to sign the node certificates.
+
+<h2>To generate a certificate for a single node (user agent or proxy)</h2>
+<strong><pre>
+$ make_node_cert.pl \
+     -cn &lt;node common name&gt;\
+     -dns &lt;comma separated list of node dns names&gt;\
+    [-ca &lt;cafile&gt; (default root.pem)]\
+    [-prefix &lt;prefix for the generated files&gt; (default agent)]\
+    [-rand &lt;random seed file&gt; (default tls_seed.dat)]
+</pre></strong>
+This command will generate files <strong>&lt;prefix&gt;key.pem </strong> (node private key), 
+<strong>&lt;prefix&gt;cert.pem</strong> (node certificate) and <strong>&lt;prefix&gt;.pem</strong> (combination
+of the key and the certificate). The certificate has been signed with ca certificate
+contained in <strong>&lt;cafile&gt;</strong>.
+
+<h2>Installing the certificates to the nodes</h2>
+
+<ol>
+
+<li>Copy the root certificate file (<strong>rootcert.pem</strong> by default - <strong>not root.pem or rootkey.pem!</strong>), 
+the combined node certificate+key file (<strong>agent.pem</strong>) and <strong>tls_seed.dat</strong> to the tls configuration
+directory (default <strong>$HOME/.sip/auth</strong>)</li>
+
+<li>Rename <strong>rootcert.pem</strong> as <strong>cafile.pem</strong></li>
+</ol>
+<p>
+<strong>Note that files agent.pem and tls_seed.dat must be kept secret to
+ensure secure connection</strong>  
+</p>
+
+</ol>
+</body>
+</html>
+
Only in b/libsofia-sip-ua/tport: certificates-update
Only in b/libsofia-sip-ua/tport: include
diff -ur a/libsofia-sip-ua/tport/Makefile.am b/libsofia-sip-ua/tport/Makefile.am
--- a/libsofia-sip-ua/tport/Makefile.am	2011-03-11 16:49:19.000000000 +0200
+++ b/libsofia-sip-ua/tport/Makefile.am	2017-12-07 23:26:00.636844243 +0200
@@ -8,13 +8,15 @@
 # ----------------------------------------------------------------------
 # Header paths
 
-INCLUDES = 		-I$(srcdir)/../bnf -I../bnf \
+AM_CPPFLAGS = 		-I$(srcdir)/../bnf -I../bnf \
 			-I$(srcdir)/../stun -I../stun \
 			-I$(srcdir)/../ipt -I../ipt \
 			-I$(srcdir)/../msg -I../msg \
 			-I$(srcdir)/../http -I../http \
 			-I$(srcdir)/../url -I../url \
-			-I$(srcdir)/../su -I../su
+			-I$(srcdir)/../sip -I../sip \
+			-I$(srcdir)/../su -I../su \
+			-I$(srcdir)/include
 
 # ----------------------------------------------------------------------
 # Build targets
@@ -44,7 +46,7 @@
 USE_STUN_SRC = 		$(STUN_SRC)
 endif
 
-HTTP_SRC =		tport_type_connect.c
+HTTP_SRC =		tport_type_connect.c tport_type_ws.c ws.c
 if HAVE_NTH
 USE_HTTP_SRC = 		$(HTTP_SRC)
 endif
Only in b/libsofia-sip-ua/tport: make_node_cert.pl
Only in b/libsofia-sip-ua/tport: make_root_cert.pl
Only in b/libsofia-sip-ua/tport: make_test_certs.sh
diff -ur a/libsofia-sip-ua/tport/sofia-sip/tport_tag.h b/libsofia-sip-ua/tport/sofia-sip/tport_tag.h
--- a/libsofia-sip-ua/tport/sofia-sip/tport_tag.h	2011-03-11 16:49:19.000000000 +0200
+++ b/libsofia-sip-ua/tport/sofia-sip/tport_tag.h	2017-12-07 23:26:01.792850513 +0200
@@ -142,6 +142,12 @@
 TPORT_DLL extern tag_typedef_t tptag_timeout_ref;
 #define TPTAG_TIMEOUT_REF(x) tptag_timeout_ref, tag_uint_vr(&(x))
 
+TPORT_DLL extern tag_typedef_t tptag_socket_keepalive;
+#define TPTAG_SOCKET_KEEPALIVE(x) tptag_socket_keepalive, tag_uint_v((x))
+
+TPORT_DLL extern tag_typedef_t tptag_socket_keepalive_ref;
+#define TPTAG_SOCKET_KEEPALIVE_REF(x) tptag_socket_keepalive_ref, tag_uint_vr(&(x))
+
 TPORT_DLL extern tag_typedef_t tptag_keepalive;
 #define TPTAG_KEEPALIVE(x) tptag_keepalive, tag_uint_v((x))
 
@@ -180,6 +186,20 @@
 TPORT_DLL extern tag_typedef_t tptag_certificate_ref;
 #define TPTAG_CERTIFICATE_REF(x) tptag_certificate_ref, tag_str_vr(&(x))
 
+TPORT_DLL extern tag_typedef_t tptag_tls_ciphers;
+#define TPTAG_TLS_CIPHERS(x) tptag_tls_ciphers, tag_str_v((x))
+
+TPORT_DLL extern tag_typedef_t tptag_tls_ciphers_ref;
+#define TPTAG_TLS_CIPHERS_REF(x) tptag_tls_ciphers_ref, tag_str_vr(&(x))
+
+enum tport_tls_version {
+  TPTLS_VERSION_SSLv2 = (1 << 0),
+  TPTLS_VERSION_SSLv3 = (1 << 1),
+  TPTLS_VERSION_TLSv1 = (1 << 2),
+  TPTLS_VERSION_TLSv1_1 = (1 << 3),
+  TPTLS_VERSION_TLSv1_2 = (1 << 4),
+};
+
 TPORT_DLL extern tag_typedef_t tptag_tls_version;
 #define TPTAG_TLS_VERSION(x) tptag_tls_version, tag_uint_v((x))
 
@@ -198,6 +218,12 @@
   TPTLS_VERIFY_SUBJECTS_ALL = 0xF,
 };
 
+TPORT_DLL extern tag_typedef_t tptag_tls_timeout;
+#define TPTAG_TLS_TIMEOUT(x) tptag_tls_timeout, tag_uint_v((x))
+
+TPORT_DLL extern tag_typedef_t tptag_tls_timeout_ref;
+#define TPTAG_TLS_TIMEOUT_REF(x) tptag_tls_timeout_ref, tag_uint_vr(&(x))
+
 TPORT_DLL extern tag_typedef_t tptag_tls_passphrase;
 #define TPTAG_TLS_PASSPHRASE(x)  tptag_tls_passphrase, tag_str_v(x)
 
@@ -307,6 +333,12 @@
 TPORT_DLL extern tag_typedef_t tptag_dump_ref;
 #define TPTAG_DUMP_REF(x) tptag_dump_ref, tag_str_vr(&(x))
 
+TPORT_DLL extern tag_typedef_t tptag_capt;
+#define TPTAG_CAPT(x) tptag_capt, tag_str_v((x))
+
+TPORT_DLL extern tag_typedef_t tptag_capt_ref;
+#define TPTAG_CAPT_REF(x) tptag_capt_ref, tag_str_vr(&(x))
+
 SOFIA_END_DECLS
 
 #endif /* !defined TPORT_TAG_H */
diff -ur a/libsofia-sip-ua/tport/test_tport.c b/libsofia-sip-ua/tport/test_tport.c
--- a/libsofia-sip-ua/tport/test_tport.c	2011-03-11 16:49:19.000000000 +0200
+++ b/libsofia-sip-ua/tport/test_tport.c	2017-12-07 23:26:00.660844374 +0200
@@ -52,7 +52,6 @@
 
 #include <sofia-sip/su_wait.h>
 #include <sofia-sip/su_md5.h>
-#include <sofia-sip/su_localinfo.h>
 
 #include "tport_internal.h"	/* Get SU_DEBUG_*() */
 
@@ -567,26 +566,19 @@
     TEST_S(tport_name(tp)->tpn_ident, "server");
 
   {
-    su_sockaddr_t *su;
+    su_sockaddr_t su[1];
     socklen_t sulen;
     int s;
     int i, before, after;
     char port[8];
 
     tp_name_t rname[1];
-    su_localinfo_t *li, hints[1] = {{ 0 }};
 
     *rname = *myname;
 
     /* Check that we cannot bind to an already used socket */
 
-    /* Windows allows concurrent binding to a wildcard */
-    memset(hints, 0, sizeof hints);
-    if (strcmp(rname->tpn_host, "*"))
-      hints->li_canonname = (char *) rname->tpn_host;
-    TEST_1(su_getlocalinfo(hints, &li) == 0);
-    su = li->li_addr, sulen = li->li_addrlen;
-
+    memset(su, 0, sulen = sizeof(su->su_sin));
     s = su_socket(su->su_family = AF_INET, SOCK_STREAM, 0); TEST_1(s != -1);
     TEST_1(bind(s, &su->su_sa, sulen) != -1);
     TEST_1(listen(s, 5) != -1);
@@ -607,8 +599,6 @@
 
     after = count_tports(tt->tt_srv_tports);
 
-    su_freelocalinfo(li);
-
     /* Check that no new primary transports has been added by failed call */
     TEST(before, after);
 
diff -ur a/libsofia-sip-ua/tport/tport.c b/libsofia-sip-ua/tport/tport.c
--- a/libsofia-sip-ua/tport/tport.c	2011-03-11 16:49:19.000000000 +0200
+++ b/libsofia-sip-ua/tport/tport.c	2017-12-09 23:37:03.967682922 +0200
@@ -115,10 +115,10 @@
   return memcmp(a->tp_addr, b->tp_addr, a->tp_addrlen);
 }
 
-su_inline int tprb_is_inserted(tport_t const *a)
-{
-  return a->tp_dad != 0 || a->tp_left != 0 || a->tp_right != 0;
-}
+#ifdef __clang__
+#pragma clang diagnostic push
+#pragma clang diagnostic ignored "-Wunused-function"
+#endif
 
 RBTREE_PROTOS(su_inline, tprb, tport_t);
 
@@ -127,6 +127,10 @@
 	      TP_IS_RED, TP_SET_RED, TP_IS_BLACK, TP_SET_BLACK, TP_COPY_COLOR,
 	      tp_cmp, TP_INSERT, TP_REMOVE);
 
+#ifdef __clang__
+#pragma clang diagnostic pop
+#endif
+
 static void tplist_insert(tport_t **list, tport_t *tp)
 {
   if (*list == NULL)
@@ -202,7 +206,7 @@
 /** Test if transport is stream. */
 int tport_is_stream(tport_t const *self)
 {
-  return self && self->tp_addrinfo->ai_socktype == SOCK_STREAM;
+	return self && !self->tp_pre_framed && self->tp_addrinfo->ai_socktype == SOCK_STREAM;
 }
 
 /** Test if transport is dgram. */
@@ -311,12 +315,6 @@
   return self->tp_closed || self->tp_send_close || self->tp_recv_close;
 }
 
-/** Test if transport is bound */
-su_inline int tport_is_bound(tport_t const *self)
-{
-  return self->tp_protoname != NULL;
-}
-
 /** Test if transport connection has been established. @NEW_1_12_5. */
 int tport_is_connected(tport_t const *self)
 {
@@ -348,12 +346,6 @@
   return self->tp_params->tpp_mtu;
 }
 
-su_inline
-int tport_has_sigcomp(tport_t const *self)
-{
-  return self->tp_name->tpn_comp != NULL;
-}
-
 /** Set IP TOS for socket */
 void tport_set_tos(su_socket_t socket, su_addrinfo_t *ai, int tos)
 {
@@ -520,6 +512,7 @@
   tpp->tpp_idle = UINT_MAX;
   tpp->tpp_timeout = UINT_MAX;
   tpp->tpp_sigcomp_lifetime = UINT_MAX;
+  tpp->tpp_socket_keepalive = 30;
   tpp->tpp_keepalive = 0;
   tpp->tpp_pingpong = 0;
   tpp->tpp_pong2ping = 0;
@@ -885,12 +878,16 @@
     self->tp_stime = self->tp_ktime = self->tp_rtime = su_now();
 
     if (pri->pri_vtable->vtp_init_secondary &&
-	pri->pri_vtable->vtp_init_secondary(self, socket, accepted,
-					    return_reason) < 0) {
-      if (pri->pri_vtable->vtp_deinit_secondary)
-	pri->pri_vtable->vtp_deinit_secondary(self);
-      su_home_zap(self->tp_home);
-      return NULL;
+
+		pri->pri_vtable->vtp_init_secondary(self, socket, accepted, return_reason) < 0) {
+
+		if (pri->pri_vtable->vtp_deinit_secondary) {
+			pri->pri_vtable->vtp_deinit_secondary(self);
+		}
+		su_timer_destroy(self->tp_timer);
+		su_home_zap(self->tp_home);
+
+		return NULL;
     }
 
     /* Set IP TOS if it is set in primary */
@@ -899,7 +896,6 @@
 		  pri->pri_params->tpp_tos);
   }
   else {
-    su_close(socket);
     *return_reason = "malloc";
   }
 
@@ -1215,6 +1211,7 @@
 	       TPTAG_QUEUESIZE(tpp->tpp_qsize),
 	       TPTAG_IDLE(tpp->tpp_idle),
 	       TPTAG_TIMEOUT(tpp->tpp_timeout),
+	       TPTAG_SOCKET_KEEPALIVE(tpp->tpp_socket_keepalive),
 	       TPTAG_KEEPALIVE(tpp->tpp_keepalive),
 	       TPTAG_PINGPONG(tpp->tpp_pingpong),
 	       TPTAG_PONG2PING(tpp->tpp_pong2ping),
@@ -1280,6 +1277,7 @@
 	      TAG_IF(!self->tp_queue, TPTAG_QUEUESIZE_REF(tpp->tpp_qsize)),
 	      TPTAG_IDLE_REF(tpp->tpp_idle),
 	      TPTAG_TIMEOUT_REF(tpp->tpp_timeout),
+	      TPTAG_SOCKET_KEEPALIVE_REF(tpp->tpp_socket_keepalive),
 	      TPTAG_KEEPALIVE_REF(tpp->tpp_keepalive),
 	      TPTAG_PINGPONG_REF(tpp->tpp_pingpong),
 	      TPTAG_PONG2PING_REF(pong2ping),
@@ -1595,7 +1593,7 @@
 {
   char hostname[TPORT_HOSTPORTSIZE];
   char const *canon = NULL, *host, *service;
-  int error = 0, not_supported, family = 0;
+  int error = 0, family = 0;
   tport_primary_t *pri = NULL, **tbf;
   su_addrinfo_t *ai, *res = NULL;
   unsigned port, port0, port1, old;
@@ -1691,8 +1689,6 @@
 	break;
       }
 
-      not_supported = 0;
-
       if (port0 == 0 && port == 0) {
 	port = port1 = ntohs(su->su_port);
 	assert(public != tport_type_server || port != 0);
@@ -2085,6 +2081,10 @@
   SU_DEBUG_5(("%s(%p): " TPN_FORMAT "\n",
 	      __func__, (void *)self, TPN_ARGS(self->tp_name)));
 
+  if (self->tp_refs == -1) {
+	  self->tp_refs = 0;
+  }
+
   if (self->tp_closed || !tport_is_secondary(self))
     return;
 
@@ -2252,7 +2252,7 @@
   if (tport_is_closed(self)) {
     if (self->tp_refs == 0) {
       SU_DEBUG_7(("tport(%p): set timer at %u ms because %s\n",
-		  (void *)self, 0, "zap"));
+				  (void *)self, 0, "zap"));
       su_timer_set_interval(self->tp_timer, timer, self, 0);
     }
     else
@@ -2428,6 +2428,13 @@
     proto = "tcp";
 #endif
 
+#if HAVE_SOFIA_NTH
+  if (su_casematch(proto, "ws"))
+    proto = "tcp";
+  if (su_casematch(proto, "wss"))
+    proto = "tcp";
+#endif
+
 #if HAVE_SCTP
   if (su_casematch(proto, "sctp")) {
     hints->ai_protocol = IPPROTO_SCTP;
@@ -2601,8 +2608,10 @@
   /* Alloc a new transport object, then register socket events with it */
   if ((self = tport_alloc_secondary(pri, s, 1, &reason)) == NULL) {
     SU_DEBUG_3(("%s(%p): incoming secondary on "TPN_FORMAT
-                " failed. reason = %s\n", __func__, (void *)pri,
+                " failed. reason = %s\n", __func__, (void *)pri, 
                 TPN_ARGS(pri->pri_primary->tp_name), reason));
+	shutdown(s, 2);
+	su_close(s);
     return 0;
   }
   else {
@@ -2871,7 +2880,7 @@
     }
 
     if (again >= 0)
-      tport_parse(self, !again, self->tp_rtime);
+      tport_parse(self, self->tp_pre_framed ? 1 : !again, self->tp_rtime);
   }
   while (again > 1);
 
@@ -3305,7 +3314,8 @@
     self = primary->pri_primary;
   }
   else if (tport_is_secondary(self) && tport_is_clear_to_send(self)) {
-    self = self;
+	/* self = self; */
+	;
   }
   /*
    * Try to find an already open connection to the destination,
@@ -3352,7 +3362,7 @@
 
       if (!self) {
 	msg_set_errno(msg, su_errno());
-        SU_DEBUG_9(("tport_socket failed in tsend\n"));
+        SU_DEBUG_9(("tport_socket failed in tsend\n" VA_NONE));
 	return NULL;
       }
 
@@ -3408,7 +3418,7 @@
       /* ...or we are connecting */
       (self->tp_events & (SU_WAIT_CONNECT | SU_WAIT_OUT))) {
     if (tport_queue(self, msg) < 0) {
-      SU_DEBUG_9(("tport_queue failed in tsend\n"));
+      SU_DEBUG_9(("tport_queue failed in tsend\n" VA_NONE));
       return -1;
     }
     return 0;
@@ -3556,6 +3566,10 @@
 
   if (n > 0 && self->tp_master->mr_dump_file)
     tport_dump_iovec(self, msg, n, iov, iovused, "sent", "to");
+    
+  if (n > 0 && self->tp_master->mr_capt_sock)
+      tport_capt_msg(self, msg, n, iov, iovused, "sent");
+              
 
   if (tport_log->log_level >= 7) {
     size_t i, m = 0;
diff -ur a/libsofia-sip-ua/tport/tport_internal.h b/libsofia-sip-ua/tport/tport_internal.h
--- a/libsofia-sip-ua/tport/tport_internal.h	2011-03-11 16:49:19.000000000 +0200
+++ b/libsofia-sip-ua/tport/tport_internal.h	2017-12-09 23:38:24.468156903 +0200
@@ -79,7 +79,11 @@
 #endif
 
 #ifndef NONE
+#ifndef _MSC_VER
 #define NONE ((void *)-1)
+#else
+#define NONE ((void *)(INT_PTR)-1)
+#endif
 #endif
 
 SOFIA_BEGIN_DECLS
@@ -102,6 +106,7 @@
   unsigned tpp_mtu;		/**< Maximum packet size */
   unsigned tpp_idle;		/**< Allowed connection idle time. */
   unsigned tpp_timeout;		/**< Allowed idle time for message. */
+  unsigned tpp_socket_keepalive;/**< Socket keepalive interval */
   unsigned tpp_keepalive;	/**< Keepalive PING interval */
   unsigned tpp_pingpong;	/**< PONG-to-PING interval */
 
@@ -157,6 +162,7 @@
   unsigned            tp_trunc:1;
   unsigned            tp_is_connected:1; /**< Connection is established */
   unsigned            tp_verified:1;     /**< Certificate Chain was verified */
+  unsigned            tp_pre_framed:1;   /** Data is pre-framed **/
   unsigned:0;
 
   tport_t *tp_left, *tp_right, *tp_dad; /**< Links in tport tree */
@@ -296,7 +302,12 @@
   /** FILE to dump received and sent data */
   FILE               *mr_dump_file;
   char               *mr_dump;	/**< Filename for dumping received/sent data */
+  /** SOCK to dump received and sent data */
+  su_socket_t         mr_capt_sock;
+  char               *mr_capt_name;	/**< Servername for capturing received/sent data */  
   tport_primary_t    *mr_primaries;        /**< List of primary contacts */
+  unsigned	      mr_prot_ver;	/* hep version */
+  unsigned	      mr_agent_id;      /* agent version */
 
   tport_params_t      mr_params[1];
 
@@ -474,6 +485,15 @@
 		      size_t n, su_iovec_t const iov[], size_t iovused,
 		      char const *what, char const *how);
 
+void tport_capt_msg(tport_t const *self, msg_t *msg, size_t n,
+                    su_iovec_t const iov[], size_t iovused, char const *what);
+
+int tport_capt_msg_hepv2(tport_t const *self, msg_t *msg, size_t n,
+                    su_iovec_t const iov[], size_t iovused, char const *what, char **buffer);                    
+
+int tport_capt_msg_hepv3(tport_t const *self, msg_t *msg, size_t n,
+                    su_iovec_t const iov[], size_t iovused, char const *what, char **buffer);                                        
+
 int tport_tcp_ping(tport_t *self, su_time_t now);
 int tport_tcp_pong(tport_t *self);
 
diff -ur a/libsofia-sip-ua/tport/tport_logging.c b/libsofia-sip-ua/tport/tport_logging.c
--- a/libsofia-sip-ua/tport/tport_logging.c	2011-03-11 16:49:19.000000000 +0200
+++ b/libsofia-sip-ua/tport/tport_logging.c	2017-12-07 23:26:00.676844460 +0200
@@ -33,9 +33,11 @@
  */
 
 #include "config.h"
+#include "msg_internal.h"
 
 #include "tport_internal.h"
 
+#include <sofia-sip/su.h>
 #include <sofia-sip/su_string.h>
 #include <stdlib.h>
 #include <time.h>
@@ -52,8 +54,8 @@
  *
  * @sa TPORT_DUMP, TPORT_DEBUG, tport_log
  */
-#if DOXYGEN_ONLY
-char const TPORT_LOG[];	/* dummy declaration for Doxygen */
+#ifdef DOXYGEN
+extern char const TPORT_LOG[];	/* dummy declaration for Doxygen */
 #endif
 
 /**@var TPORT_DUMP
@@ -66,10 +68,25 @@
  *
  * @sa TPORT_LOG, TPORT_DEBUG, tport_log
  */
-#if DOXYGEN_ONLY
-char const TPORT_DUMP[];	/* dummy declaration for Doxygen */
+#ifdef DOXYGEN
+extern char const TPORT_DUMP[];	/* dummy declaration for Doxygen */
 #endif
 
+/**@var TPORT_CAPT
+ *
+ * Environment variable for transport data capturing.
+ *
+ * The received and sent data is dumped to the capture server specified by TPORT_CAPT
+ * environment variable. This can be used to save message traces into database and help
+ * hairy debugging tasks.
+ *
+ * @sa TPORT_LOG, TPORT_DEBUG, TPORT_CAPT, tport_log
+ */
+#ifdef DOXYGEN
+extern char const TPORT_CAPT[];	/* dummy declaration for Doxygen */
+#endif
+
+
 /**@var TPORT_DEBUG
  *
  * Environment variable determining the debug log level for @b tport module.
@@ -79,8 +96,8 @@
  *
  * @sa <sofia-sip/su_debug.h>, tport_log, SOFIA_DEBUG
  */
-#if DOXYGEN_ONLY
-char const TPORT_DEBUG[]; /* dummy declaration for Doxygen */
+#ifdef DOXYGEN
+extern char const TPORT_DEBUG[]; /* dummy declaration for Doxygen */
 #endif
 
 /**Debug log for @b tport module.
@@ -93,31 +110,184 @@
 };
 
 
+
 /** Initialize logging. */
 int tport_open_log(tport_master_t *mr, tagi_t *tags)
 {
+  int n;
   int log_msg = mr->mr_log != 0;
   char const *dump = NULL;
-  int n;
-
+  char const *capt = NULL;;
+  
+  if(mr->mr_capt_name) capt = mr->mr_capt_name;
+  
   n = tl_gets(tags,
 	      TPTAG_LOG_REF(log_msg),
 	      TPTAG_DUMP_REF(dump),
+	      TPTAG_CAPT_REF(capt),
 	      TAG_END());
 
   if (getenv("MSG_STREAM_LOG") != NULL || getenv("TPORT_LOG") != NULL)
     log_msg = 1;
   mr->mr_log = log_msg ? MSG_DO_EXTRACT_COPY : 0;
 
+  if (getenv("TPORT_CAPT"))
+    capt = getenv("TPORT_CAPT");
   if (getenv("MSG_DUMP"))
     dump = getenv("MSG_DUMP");
   if (getenv("TPORT_DUMP"))
     dump = getenv("TPORT_DUMP");
+ 
+  if(capt) {
+
+        char *captname, *p, *host_s;
+        char port[10];
+        su_addrinfo_t *ai = NULL, hints[1] = {{ 0 }};
+        unsigned len =0, iport = 0;
+        
+
+
+        if (mr->mr_capt_name && mr->mr_capt_sock && strcmp(capt, mr->mr_capt_name) == 0)                
+              return n;
+
+        captname = su_strdup(mr->mr_home, capt);
+        if (captname == NULL)
+              return n;
+                           
+        if(strncmp(captname, "udp:",4) != 0) {
+              su_log("tport_open_log: capturing. Only udp protocol supported [%s]\n", captname);          
+              return n;
+        } 
+        
+        /* separate proto and host */
+        p = captname+4;
+        if( (*(p)) == '\0') {
+                su_log("malformed ip address\n");
+                return n;
+        }
+        host_s = p;
+
+        if( (p = strrchr(p+1, ':')) == 0 ) {
+                su_log("no host or port specified\n");
+                return n;
+        }
+ 
+        /*the address contains a port number*/
+        *p = '\0';
+        p++;
+        
+        iport = atoi(p);
+
+        if (iport <1024 || iport >65536)
+        {
+                su_log("invalid port number; must be in [1024,65536]\n");
+                return n;
+        }
+        
+        snprintf(port, sizeof(port), "%d", iport);
+
+        /* default values for capture protocol and agent id */
+        mr->mr_prot_ver = 3;
+        mr->mr_agent_id = 200;                         
+        
+        /* get all params */      
+        while(p) 
+        {        
+                /* check ; in the URL */
+                if( (p = strchr(p+1, ';')) == 0 ) {                        
+                        break;
+                }
+
+                *p = '\0'; 
+                p++;                
+                
+                SU_DEBUG_7(("events HEP RRR DATA [%s]\n", p));
+                        
+                if(strncmp(p, "hep=",4) == 0) {
+                        p+=4;
+                        mr->mr_prot_ver = atoi(p);                    
+                        /* hepv3 come later */                                                                            
+                        if (mr->mr_prot_ver < 1 || mr->mr_prot_ver > 3)
+                        {
+                                su_log("invalid hep version number; must be in [1-3]\n");
+                                mr->mr_prot_ver = 3;
+                                return n;
+                        }
+                }
+                else if(strncmp(p, "capture_id=", 11) == 0) {
+                        p+=11;
+                        if((mr->mr_agent_id = atoi(p)) == 0)
+                        {
+                                mr->mr_agent_id = 200;                                
+                                su_log("invalid capture id number; must be uint32 \n");
+                                return n;
+                        }
+                }
+                else {
+                       su_log("unsupported capture param\n"); 
+                       return n;
+                }
+        }  
+                                        
+        /* check if we have [] */
+        if (host_s[0] == '[') {
+              len = strlen(host_s + 1) - 1;              
+              if(host_s[len+1] != ']') {
+                su_log("bracket not closed\n");
+                return n;            
+            }            
+            memmove(host_s, host_s + 1, len);
+            host_s[len] = '\0';
+        }                              
+
+        /* and again */
+        captname = su_strdup(mr->mr_home, capt);
+        if (captname == NULL) return n;
+        
+        su_free(mr->mr_home, mr->mr_capt_name);
+        mr->mr_capt_name = captname;
+
+        if (mr->mr_capt_sock)
+          su_close(mr->mr_capt_sock), mr->mr_capt_sock = 0;        
+
+        /* HINTS && getaddrinfo */
+        hints->ai_flags = AI_NUMERICSERV;
+        hints->ai_family = AF_UNSPEC; 
+        hints->ai_socktype = SOCK_DGRAM;
+        hints->ai_protocol = IPPROTO_UDP;
+        
+        if (su_getaddrinfo(host_s, port, hints, &ai)) {
+            su_perror("capture: su_getaddrinfo()");
+            return n;
+        }
+        
+	mr->mr_capt_sock = su_socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol);
+	if (mr->mr_capt_sock == INVALID_SOCKET) {
+	    su_perror("capture: invalid socket");
+	    return n;
+	}
+
+	su_setblocking(mr->mr_capt_sock, 0);         /* Don't block */
+
+	if (connect(mr->mr_capt_sock, ai->ai_addr, (socklen_t)(ai->ai_addrlen)) == -1) {
+	    if (errno != EINPROGRESS) {
+		    su_perror("capture: socket connect");
+		    return n;
+	    }	                
+	}
+		
+	su_freeaddrinfo(ai);        
+  }
+  else if(mr->mr_capt_sock) {
+      /* close capture server*/
+      su_close(mr->mr_capt_sock);
+      mr->mr_capt_sock = 0;
+  }
 
   if (dump) {
     time_t now;
     char *dumpname;
-
+    
     if (mr->mr_dump && strcmp(dump, mr->mr_dump) == 0)
       return n;
     dumpname = su_strdup(mr->mr_home, dump);
@@ -154,12 +324,24 @@
   char name[SU_ADDRSIZE] = "";
   su_sockaddr_t const *su;
   unsigned short second, minute, hour;
+  /* should check for ifdef HAVE_LOCALTIME_R instead -_- */
+#if defined(HAVE_GETTIMEOFDAY) || defined(HAVE_CLOCK_MONOTONIC)
+  struct tm nowtm = { 0 };
+  time_t nowtime = (now.tv_sec - SU_TIME_EPOCH); /* see su_time0.c 'now' is not really 'now', so we decrease it by SU_TIME_EPOCH */
+#endif
 
   assert(self); assert(msg);
 
+#if defined(HAVE_GETTIMEOFDAY) || defined(HAVE_CLOCK_MONOTONIC)
+  localtime_r(&nowtime, &nowtm);
+  second = nowtm.tm_sec;
+  minute = nowtm.tm_min;
+  hour = nowtm.tm_hour;
+#else
   second = (unsigned short)(now.tv_sec % 60);
   minute = (unsigned short)((now.tv_sec / 60) % 60);
   hour = (unsigned short)((now.tv_sec / 3600) % 24);
+#endif
 
   su = msg_addr(msg);
 
@@ -213,6 +395,427 @@
   fflush(mr->mr_dump_file);
 }
 
+/** Capture the data from the iovec */
+void tport_capt_msg(tport_t const *self, msg_t *msg, size_t n, 
+                    su_iovec_t const iov[], size_t iovused, char const *what)
+{
+
+   int buflen = 0, error;
+   char* buffer = NULL;
+   tport_master_t *mr;
+
+   assert(self);
+
+   mr = self->tp_master;
+
+   /* If we don't have socket, go out */
+   if (!mr->mr_capt_sock) {
+         su_log("error: capture socket is not open\n");
+         return;
+   }
+   
+   switch(mr->mr_prot_ver) 
+   {
+
+            case 3:
+                buflen = tport_capt_msg_hepv3(self, msg, n, iov, iovused, what, &buffer);
+                break;
+
+            case 2:
+            case 1:
+                buflen = tport_capt_msg_hepv2(self, msg, n, iov, iovused, what, &buffer);
+                break;
+
+            default:
+                su_log("error: unsupported hep version\n");
+                break;
+   }
+
+   if(buflen > 0) {
+            /* check if we have error i.e. capture server is down */
+            if ((error = su_soerror(mr->mr_capt_sock))) {
+                     su_perror("error: tport_logging: capture socket error");
+                     goto done;
+            }              
+            
+            su_send(mr->mr_capt_sock, buffer, buflen, 0);   
+   }                                                    
+
+
+done:
+   /* Now we release it */
+   if(buffer) free(buffer);  
+   return;
+}
+
+/** Capture the data from the iovec */
+int tport_capt_msg_hepv2 (tport_t const *self, msg_t *msg, size_t n, 
+                    su_iovec_t const iov[], size_t iovused, char const *what, char **buffer)
+{
+
+   int buflen = 0;
+   su_sockaddr_t const *su, *su_self;
+   struct hep_hdr hep_header;
+   struct hep_timehdr hep_time = {0};    
+   su_time_t now;
+#if __sun__
+   struct hep_iphdr hep_ipheader = {{{{0}}}};
+#else
+   struct hep_iphdr hep_ipheader = {{0}};  
+#endif
+#if SU_HAVE_IN6
+   struct hep_ip6hdr hep_ip6header = {{{{0}}}};
+#endif   
+   int eth_frame_len = 16000;
+   size_t i, dst = 1;
+   tport_master_t *mr;
+
+   assert(self); assert(msg);
+
+   su = msg_addr(msg);
+   su_self = self->tp_pri->pri_primary->tp_addr;
+
+   mr = self->tp_master;
+
+   /* If we don't have socket, go out */
+   if (!mr->mr_capt_sock) {
+         su_log("error: capture socket is not open\n");
+         return 0;
+   }
+
+   /*buffer for ethernet frame*/
+   *buffer = (void*)malloc(eth_frame_len);
+
+   /* VOIP Header */   
+   hep_header.hp_v =  mr->mr_prot_ver;
+   hep_header.hp_f = su->su_family; 
+   /* Header Length */   
+   hep_header.hp_l = sizeof(struct hep_hdr);   
+   
+   /* PROTOCOL */
+   if(strcmp(self->tp_name->tpn_proto, "tcp") == 0) hep_header.hp_p = IPPROTO_TCP;
+   else if(strcmp(self->tp_name->tpn_proto, "tls") == 0) hep_header.hp_p = IPPROTO_IDP; /* FAKE*/
+   else if(strcmp(self->tp_name->tpn_proto, "sctp") == 0) hep_header.hp_p = IPPROTO_SCTP;
+   else if(strcmp(self->tp_name->tpn_proto, "ws") == 0) hep_header.hp_p = IPPROTO_TCP;
+   else if(strcmp(self->tp_name->tpn_proto, "wss") == 0) hep_header.hp_p = IPPROTO_TCP;
+   else hep_header.hp_p = IPPROTO_UDP; /* DEFAULT UDP */
+
+   /* Check destination */         
+   if(strncmp("sent", what, 4) == 0) dst = 0;
+      
+   /* copy destination and source IPs*/
+   if(su->su_family == AF_INET) {
+
+       memcpy(dst ? &hep_ipheader.hp_src : &hep_ipheader.hp_dst, &su->su_sin.sin_addr.s_addr, sizeof(su->su_sin.sin_addr.s_addr));
+       memcpy(dst ? &hep_ipheader.hp_dst : &hep_ipheader.hp_src, &su_self->su_sin.sin_addr.s_addr, sizeof(su_self->su_sin.sin_addr.s_addr));
+       hep_header.hp_l += sizeof(struct hep_iphdr);
+   }
+#if SU_HAVE_IN6
+   else {   
+       memcpy(dst ? &hep_ip6header.hp6_src : &hep_ip6header.hp6_dst, &su->su_sin.sin_addr.s_addr, sizeof(su->su_sin.sin_addr.s_addr));
+       memcpy(dst ? &hep_ip6header.hp6_dst : &hep_ip6header.hp6_src, &su_self->su_sin.sin_addr.s_addr, sizeof(su_self->su_sin.sin_addr.s_addr));
+       hep_header.hp_l += sizeof(struct hep_ip6hdr);       
+   }
+#endif     
+
+   hep_header.hp_dport = dst ? su_self->su_port : su->su_port;
+   hep_header.hp_sport = dst ? su->su_port : su_self->su_port;
+
+   if (hep_header.hp_v == 2){
+           hep_header.hp_l += sizeof(struct hep_timehdr);           
+   }
+      
+   /* Copy hepheader */
+   memset(*buffer, '\0', eth_frame_len);
+   memcpy(*buffer, &hep_header, sizeof(struct hep_hdr));
+   buflen = sizeof(struct hep_hdr);
+   
+   if(su->su_family == AF_INET) {
+       memcpy(*buffer + buflen, &hep_ipheader, sizeof(struct hep_iphdr));
+       buflen += sizeof(struct hep_iphdr);      
+   }
+#if SU_HAVE_IN6   
+   else if(su->su_family == AF_INET6) {
+       memcpy(*buffer+buflen, &hep_ip6header, sizeof(struct hep_ip6hdr));
+       buflen += sizeof(struct hep_ip6hdr);   
+   }   
+#endif 
+   else {
+       su_perror("error: tport_logging: capture: unsupported protocol family");
+       goto done;
+   }           
+   
+   /* copy time header */              
+   if (hep_header.hp_v == 2) {   
+        /* now */
+        now = su_now();
+        /* should check for ifdef HAVE_LOCALTIME_R instead -_- */
+#if defined(HAVE_GETTIMEOFDAY) || defined(HAVE_CLOCK_MONOTONIC)
+        hep_time.tv_sec = (now.tv_sec - SU_TIME_EPOCH); /* see su_time0.c 'now' is not really 'now', so we decrease it by SU_TIME_EPOCH */
+#else
+        hep_time.tv_sec = now.tv_sec;
+#endif
+        hep_time.tv_usec = now.tv_usec;
+
+        hep_time.captid = mr->mr_agent_id;
+        memcpy((char*)*buffer+buflen, &hep_time, sizeof(struct hep_timehdr));
+        buflen += sizeof(struct hep_timehdr);
+   }                    
+   
+   for (i = 0; i < iovused && n > 0; i++) {
+       size_t len = iov[i].mv_len;
+       if (len > n)
+            len = n;   
+       /* if the packet too big for us */
+       if((buflen + len) > eth_frame_len) 
+              break;
+
+      memcpy(*buffer + buflen , (void*)iov[i].mv_base, len);
+      buflen +=len;
+      n -= len;
+   }
+   
+   return buflen;
+   
+done:
+   /* Now we release it */
+   if(*buffer) {
+        free(*buffer);  
+        *buffer = NULL;    
+   }
+   return 0;
+}
+
+
+/** Capture the data from the iovec */
+int tport_capt_msg_hepv3 (tport_t const *self, msg_t *msg, size_t n, 
+        su_iovec_t const iov[], size_t iovused, char const *what, char **buffer)
+{
+
+   su_sockaddr_t const *su, *su_self;
+   struct hep_generic *hg=NULL;
+   unsigned int buflen=0, iplen=0,tlen=0, payload_len = 0;
+   su_time_t now;
+   hep_chunk_ip4_t src_ip4 = {{0}}, dst_ip4 = {{0}};
+   hep_chunk_t payload_chunk;
+   int orig_n = 0;
+      
+#if SU_HAVE_IN6
+   hep_chunk_ip6_t src_ip6 = {{0}}, dst_ip6 = {{0}};
+#endif   
+
+   int eth_frame_len = 16000;
+   size_t i, dst = 1;
+   tport_master_t *mr;
+
+   assert(self); assert(msg);
+
+   su = msg_addr(msg);
+   su_self = self->tp_pri->pri_primary->tp_addr;
+
+   mr = self->tp_master;
+
+   /* If we don't have socket, go out */
+   if (!mr->mr_capt_sock) {
+         su_log("error: capture socket is not open\n");
+         return 0;
+   }
+
+   /*buffer for ethernet frame*/
+
+   hg = malloc(sizeof(struct hep_generic));
+   memset(hg, 0, sizeof(struct hep_generic));
+   
+   /* header set */
+   memcpy(hg->header.id, "\x48\x45\x50\x33", 4);
+
+   /* IP proto */
+   hg->ip_family.chunk.vendor_id = htons(0x0000);
+   hg->ip_family.chunk.type_id   = htons(0x0001);
+   hg->ip_family.data = su->su_family;
+   hg->ip_family.chunk.length = htons(sizeof(hg->ip_family));
+   
+   /* PROTOCOL */
+   if(strcmp(self->tp_name->tpn_proto, "tcp") == 0) hg->ip_proto.data = IPPROTO_TCP;
+   else if(strcmp(self->tp_name->tpn_proto, "tls") == 0) hg->ip_proto.data = IPPROTO_IDP; /* FAKE*/
+   else if(strcmp(self->tp_name->tpn_proto, "sctp") == 0) hg->ip_proto.data = IPPROTO_SCTP;
+   else if(strcmp(self->tp_name->tpn_proto, "ws") == 0) hg->ip_proto.data = IPPROTO_TCP;
+   else if(strcmp(self->tp_name->tpn_proto, "wss") == 0) hg->ip_proto.data = IPPROTO_TCP;
+   else hg->ip_proto.data = IPPROTO_UDP; /* DEFAULT UDP */
+
+   /* Proto ID */
+   hg->ip_proto.chunk.vendor_id = htons(0x0000);
+   hg->ip_proto.chunk.type_id   = htons(0x0002);
+   hg->ip_proto.chunk.length = htons(sizeof(hg->ip_proto));
+
+   /* Check destination */         
+   if(strncmp("sent", what, 4) == 0) dst = 0;
+      
+   /* copy destination and source IPs*/
+   if(su->su_family == AF_INET) {
+
+	/* SRC IP */
+        src_ip4.chunk.vendor_id = htons(0x0000);
+        src_ip4.chunk.type_id   = htons(0x0003);
+        memcpy(dst ? &src_ip4.data : &dst_ip4.data, &su->su_sin.sin_addr.s_addr, sizeof(su->su_sin.sin_addr.s_addr));
+        src_ip4.chunk.length = htons(sizeof(src_ip4));
+
+        /* DST IP */
+        dst_ip4.chunk.vendor_id = htons(0x0000);
+        dst_ip4.chunk.type_id   = htons(0x0004);
+        memcpy(dst ? &dst_ip4.data : &src_ip4.data,  &su_self->su_sin.sin_addr.s_addr, sizeof(su_self->su_sin.sin_addr.s_addr));
+        dst_ip4.chunk.length = htons(sizeof(dst_ip4));
+
+        iplen = sizeof(dst_ip4) + sizeof(src_ip4);
+   }
+#if SU_HAVE_IN6
+   else if(su->su_family == AF_INET6) {
+
+	/* SRC IPv6 */
+        src_ip6.chunk.vendor_id = htons(0x0000);
+        src_ip6.chunk.type_id   = htons(0x0005);
+        memcpy(dst ? &src_ip6.data : &dst_ip6.data, &su->su_sin.sin_addr.s_addr, sizeof(su->su_sin.sin_addr.s_addr));
+        src_ip6.chunk.length = htons(sizeof(src_ip6));
+
+        /* DST IPv6 */
+        dst_ip6.chunk.vendor_id = htons(0x0000);
+        dst_ip6.chunk.type_id   = htons(0x0006);
+        memcpy(dst ? &dst_ip6.data : &src_ip6.data, &su_self->su_sin.sin_addr.s_addr, sizeof(su_self->su_sin.sin_addr.s_addr));
+        dst_ip6.chunk.length = htons(sizeof(dst_ip6));
+
+        iplen = sizeof(dst_ip6) + sizeof(src_ip6);
+   }
+#endif     
+   else {
+       su_perror("error: tport_logging hepv3: capture: unsupported protocol family");
+       goto done;
+   }           
+
+   /* SRC PORT */
+    hg->src_port.chunk.vendor_id = htons(0x0000);
+    hg->src_port.chunk.type_id   = htons(0x0007);
+    hg->src_port.data = dst ? su->su_port : su_self->su_port;
+    hg->src_port.chunk.length = htons(sizeof(hg->src_port));
+
+    /* DST PORT */
+    hg->dst_port.chunk.vendor_id = htons(0x0000);
+    hg->dst_port.chunk.type_id   = htons(0x0008);
+    hg->dst_port.data = dst ? su_self->su_port : su->su_port;
+    hg->dst_port.chunk.length = htons(sizeof(hg->dst_port));
+
+
+    /* TIMESTAMP SEC */
+    hg->time_sec.chunk.vendor_id = htons(0x0000);
+    hg->time_sec.chunk.type_id   = htons(0x0009);
+    hg->time_sec.chunk.length = htons(sizeof(hg->time_sec));
+
+    now = su_now();
+    /* should check for ifdef HAVE_LOCALTIME_R instead -_- */
+#if defined(HAVE_GETTIMEOFDAY) || defined(HAVE_CLOCK_MONOTONIC)
+    hg->time_sec.data = htonl(now.tv_sec - SU_TIME_EPOCH); /* see su_time0.c 'now' is not really 'now', so we decrease it by SU_TIME_EPOCH */
+#else
+    hg->time_sec.data = htonl(now.tv_sec);
+#endif
+
+    /* TIMESTAMP USEC */
+    hg->time_usec.chunk.vendor_id = htons(0x0000);
+    hg->time_usec.chunk.type_id   = htons(0x000a);
+    hg->time_usec.data = htonl(now.tv_usec);
+    hg->time_usec.chunk.length = htons(sizeof(hg->time_usec));
+
+    /* Protocol TYPE */
+    hg->proto_t.chunk.vendor_id = htons(0x0000);
+    hg->proto_t.chunk.type_id   = htons(0x000b);
+    hg->proto_t.data = 0x001; //SIP
+    hg->proto_t.chunk.length = htons(sizeof(hg->proto_t));
+    
+    /* Capture ID */
+    hg->capt_id.chunk.vendor_id = htons(0x0000);
+    hg->capt_id.chunk.type_id   = htons(0x000c);
+    hg->capt_id.data = htons(mr->mr_agent_id);
+    hg->capt_id.chunk.length = htons(sizeof(hg->capt_id));
+
+
+    /* Payload caclulation */
+    orig_n = n;
+    for (i = 0; i < iovused && n > 0; i++) {
+       	size_t len = iov[i].mv_len;
+	if (len > n) len = n;   
+	if((payload_len + len) > eth_frame_len) break;
+        payload_len +=len;
+    	n -= len;
+    }
+    /* restore n */
+    n = orig_n;
+
+    /* Payload */
+    payload_chunk.vendor_id = htons(0x0000);
+    payload_chunk.type_id   = htons(0x000f);
+    payload_chunk.length    = htons(sizeof(payload_chunk) + payload_len);
+
+    tlen = sizeof(struct hep_generic) + payload_len + iplen + sizeof(hep_chunk_t);
+
+    /* total */
+    hg->header.length = htons(tlen);    
+
+    *buffer = (void*)malloc(tlen);
+
+    if (*buffer==NULL){
+       su_perror("error: tport_logging hepv3: no memory for buffer");
+       goto done;
+    }
+    
+    memcpy((void*) *buffer, hg, sizeof(struct hep_generic));
+    buflen = sizeof(struct hep_generic);
+
+    /* IPv4 */
+   if(su->su_family == AF_INET) {
+        /* SRC IP */
+        memcpy((char*) *buffer+buflen, &src_ip4, sizeof(struct hep_chunk_ip4));
+        buflen += sizeof(struct hep_chunk_ip4);
+
+        memcpy((char*) *buffer+buflen, &dst_ip4, sizeof(struct hep_chunk_ip4));
+        buflen += sizeof(struct hep_chunk_ip4);
+    }
+#if SU_HAVE_IN6
+      /* IPv6 */
+    else if(su->su_family == AF_INET6) {
+        /* SRC IPv6 */
+        memcpy((char*) *buffer+buflen, &src_ip6, sizeof(struct hep_chunk_ip6));
+        buflen += sizeof(struct hep_chunk_ip6);
+
+        memcpy((char*) *buffer+buflen, &dst_ip6, sizeof(struct hep_chunk_ip6));
+        buflen += sizeof(struct hep_chunk_ip6);
+    }
+#endif
+
+    /* PAYLOAD CHUNK */
+    memcpy((char*) *buffer+buflen, &payload_chunk,  sizeof(struct hep_chunk));
+    buflen +=  sizeof(struct hep_chunk);
+
+   /* PAYLOAD */
+   for (i = 0; i < iovused && n > 0; i++) {
+       size_t len = iov[i].mv_len;
+       if (len > n) len = n;   
+       /* if the packet too big for us */
+       if((buflen + len) > eth_frame_len) 
+              break;
+
+      memcpy(*buffer + buflen , (void*)iov[i].mv_base, len);
+      buflen +=len;
+      n -= len;
+   }
+
+   free(hg);
+   return buflen;
+ 
+done:
+   /* Now we release it */
+   if(hg) free(hg);  
+   return 0;
+}
+  
+
 /** Log the message. */
 void tport_log_msg(tport_t *self, msg_t *msg,
 		   char const *what, char const *via,
@@ -223,6 +826,7 @@
   size_t i, iovlen = msg_iovec(msg, iov, 80);
   size_t linelen = 0, n, logged = 0, truncated = 0;
   int skip_lf = 0;
+  int j, unprintable = 0;
 
 #define MSG_SEPARATOR \
   "------------------------------------------------------------------------\n"
@@ -240,39 +844,57 @@
     if (skip_lf && s < end && s[0] == '\n') { s++; logged++; skip_lf = 0; }
 
     while (s < end) {
-      if (s[0] == '\0') {
-	truncated = logged;
-	break;
-      }
-
-      n = su_strncspn(s, end - s, "\r\n");
-
-      if (linelen + n > MAX_LINELEN) {
-	n = MAX_LINELEN - linelen;
-	truncated = logged + n;
-      }
-
-      su_log("%s%.*s", linelen > 0 ? "" : "   ", (int)n, s);
-      s += n, linelen += n, logged += n;
-
-      if (truncated)
-	break;
-      if (s == end)
-	break;
-
-      linelen = 0;
-      su_log("\n");
-
-      /* Skip eol */
-      if (s[0] == '\r') {
-	s++, logged++;
-	if (s == end) {
-	  skip_lf = 1;
-	  continue;
-	}
-      }
-      if (s[0] == '\n')
-	s++, logged++;
+		if (s[0] == '\0') {
+			truncated = logged;
+			break;
+		}
+
+		n = su_strncspn(s, end - s, "\r\n");
+
+		if (linelen + n > MAX_LINELEN) {
+			n = MAX_LINELEN - linelen;
+			truncated = logged + n;
+		}
+		
+		if (!unprintable) {
+			for (j = 0; j < 4; j++) {
+				if (s[j] == 0) break;
+				if (s[j] != 9 && s[j] != 10 && s[j] != 13 && (s[j] < 32 || s[j] > 126)) {
+					unprintable++;
+				}
+			}
+		}
+
+		if (unprintable) {
+			if (unprintable == 1)
+				su_log("\n   <ENCODED DATA>");
+			unprintable++;
+		} else {
+			su_log("%s%.*s", linelen > 0 ? "" : "   ", (int)n, s);
+		}
+
+		s += n, linelen += n, logged += n;
+
+		if (truncated)
+			break;
+		if (s == end)
+			break;
+		
+		linelen = 0;
+		su_log("\n");
+		
+		/* Skip eol */
+		if (s[0] == '\r') {
+			s++, logged++;
+			if (s == end) {
+				skip_lf = 1;
+				continue;
+			}
+		}
+
+		if (s[0] == '\n') {
+			s++, logged++;
+		}
     }
   }
 
diff -ur a/libsofia-sip-ua/tport/tport_sigcomp.c b/libsofia-sip-ua/tport/tport_sigcomp.c
--- a/libsofia-sip-ua/tport/tport_sigcomp.c	2011-03-11 16:49:19.000000000 +0200
+++ b/libsofia-sip-ua/tport/tport_sigcomp.c	2017-12-07 23:26:00.684844504 +0200
@@ -453,6 +453,10 @@
       if (self->tp_master->mr_dump_file && !self->tp_pri->pri_threadpool)
 	tport_dump_iovec(self, msg, n, iovec, veclen, "recv", "from");
 
+      /* Send the received data to the capture server */
+      if (self->tp_master->mr_capt_sock && !self->tp_pri->pri_threadpool)
+	tport_dump_iovec(self, msg, 0);
+
       msg_recv_commit(msg, dlen, eos);    /* Mark buffer as used */
     }
     else {
diff -ur a/libsofia-sip-ua/tport/tport_tag.c b/libsofia-sip-ua/tport/tport_tag.c
--- a/libsofia-sip-ua/tport/tport_tag.c	2011-03-11 16:49:19.000000000 +0200
+++ b/libsofia-sip-ua/tport/tport_tag.c	2017-12-07 23:26:00.692844548 +0200
@@ -179,6 +179,14 @@
  */
 tag_typedef_t tptag_timeout = UINTTAG_TYPEDEF(timeout);
 
+/**@def TPTAG_SOCKET_KEEPALIVE(x)
+ *
+ * Keepalive interval set on socket (where supported) in seconds.
+ *
+ * If 0 or UINT_MAX, do not use keepalives. Default value is 30.
+ */
+tag_typedef_t tptag_socket_keepalive = UINTTAG_TYPEDEF(socket_keepalive);
+
 /**@def TPTAG_KEEPALIVE(x)
  *
  * Keepalive interval in milliseconds.
@@ -270,6 +278,14 @@
  */
 tag_typedef_t tptag_compartment = PTRTAG_TYPEDEF(compartment);
 
+/**@def TPTAG_TLS_CIPHERS(x)
+ *
+ * Sets the supported TLS cipher suites.
+ *
+ * Use with tport_tbind(), nua_create(), nta_agent_create(),
+ * nta_agent_add_tport(), nth_engine_create(), or initial nth_site_create().
+ */
+tag_typedef_t tptag_tls_ciphers = STRTAG_TYPEDEF(tls_ciphers);
 
 /**@def TPTAG_TLS_VERSION(x)
  *
@@ -280,6 +296,19 @@
  */
 tag_typedef_t tptag_tls_version = UINTTAG_TYPEDEF(tls_version);
 
+/**@def TPTAG_TLS_TIMEOUT(x)
+ *
+ * Sets the maximum TLS session lifetime in seconds.
+ *
+ * The default value is 300 seconds.
+ *
+ * Use with tport_tbind(), nua_create(), nta_agent_create(),
+ * nta_agent_add_tport(), nth_engine_create(), or initial nth_site_create().
+ *
+ * @NEW_UNRELEASED.
+ */
+tag_typedef_t tptag_tls_timeout = UINTTAG_TYPEDEF(tls_timeout);
+
 /**@def TPTAG_TLS_VERIFY_PEER(x)
  * @par Depreciated:
  *    Alias for TPTAG_TLS_VERIFY_POLICY(TPTLS_VERIFY_IN|TPTLS_VERIFY_OUT)
@@ -564,6 +593,19 @@
  */
 tag_typedef_t tptag_dump = STRTAG_TYPEDEF(dump);
 
+/**@def TPTAG_CAPT(x)
+ *
+ * URL for capturing unparsed messages from transport.
+ *
+ * Use with tport_tcreate(), nta_agent_create(), nua_create(),
+ * nth_engine_create(), or initial nth_site_create().
+ *
+ * @sa #TPORT_CAPT environment variable, TPTAG_LOG().
+ *
+ */
+tag_typedef_t tptag_capt = STRTAG_TYPEDEF(capt);
+
+
 /** Mark transport as trusted.
  *
  * @note Not implemented by tport module.
diff -ur a/libsofia-sip-ua/tport/tport_tls.c b/libsofia-sip-ua/tport/tport_tls.c
--- a/libsofia-sip-ua/tport/tport_tls.c	2011-03-11 16:49:19.000000000 +0200
+++ b/libsofia-sip-ua/tport/tport_tls.c	2017-12-07 23:26:00.708844634 +0200
@@ -137,7 +137,6 @@
  * Log the TLS error specified by the error code @a e and all the errors in
  * the queue. The error code @a e implies no error, and it is not logged.
  */
-static
 void tls_log_errors(unsigned level, char const *s, unsigned long e)
 {
   if (e == 0)
@@ -201,7 +200,8 @@
   i->cert = i->cert ? i->cert : "agent.pem";
   i->key = i->key ? i->key : i->cert;
   i->randFile = i->randFile ? i->randFile : "tls_seed.dat";
-  i->cipher = i->cipher ? i->cipher : "ALL:!ADH:!LOW:!EXP:!MD5:@STRENGTH";
+  i->CAfile = i->CAfile ? i->CAfile : "cafile.pem";
+  i->ciphers = i->ciphers ? i->ciphers : "!eNULL:!aNULL:!EXP:!LOW:!MD5:ALL:@STRENGTH";
   /* Default SIP cipher */
   /* "RSA-WITH-AES-128-CBC-SHA"; */
   /* RFC-2543-compatibility ciphersuite */
@@ -262,6 +262,33 @@
   return ok;
 }
 
+void tls_init(void) {
+  ONCE_INIT(tls_init_once);
+}
+
+#ifndef OPENSSL_NO_EC
+static
+int tls_init_ecdh_curve(tls_t *tls)
+{
+  int nid;
+  EC_KEY *ecdh;
+  if (!(nid = OBJ_sn2nid("prime256v1"))) {
+    tls_log_errors(1, "Couldn't find specified curve", 0);
+    errno = EIO;
+    return -1;
+  }
+  if (!(ecdh = EC_KEY_new_by_curve_name(nid))) {
+    tls_log_errors(1, "Couldn't create specified curve", 0);
+    errno = EIO;
+    return -1;
+  }
+  SSL_CTX_set_options(tls->ctx, SSL_OP_SINGLE_ECDH_USE);
+  SSL_CTX_set_tmp_ecdh(tls->ctx, ecdh);
+  EC_KEY_free(ecdh);
+  return 0;
+}
+#endif
+
 static
 int tls_init_context(tls_t *tls, tls_issues_t const *ti)
 {
@@ -290,25 +317,26 @@
   signal(SIGPIPE, SIG_IGN);
 #endif
 
-  if (tls->ctx == NULL) {
-    const SSL_METHOD *meth;
-
-    /* meth = SSLv3_method(); */
-    /* meth = SSLv23_method(); */
-
-    if (ti->version)
-      meth = TLSv1_method();
-    else
-      meth = SSLv23_method();
-
-    tls->ctx = SSL_CTX_new((SSL_METHOD*)meth);
-  }
-
-  if (tls->ctx == NULL) {
-    tls_log_errors(1, "tls_init_context", 0);
-    errno = EIO;
-    return -1;
-  }
+  if (tls->ctx == NULL)
+    if (!(tls->ctx = SSL_CTX_new((SSL_METHOD*)SSLv23_method()))) {
+      tls_log_errors(1, "SSL_CTX_new() failed", 0);
+      errno = EIO;
+      return -1;
+    }
+  if (!(ti->version & TPTLS_VERSION_SSLv2))
+    SSL_CTX_set_options(tls->ctx, SSL_OP_NO_SSLv2);
+  if (!(ti->version & TPTLS_VERSION_SSLv3))
+    SSL_CTX_set_options(tls->ctx, SSL_OP_NO_SSLv3);
+  if (!(ti->version & TPTLS_VERSION_TLSv1))
+    SSL_CTX_set_options(tls->ctx, SSL_OP_NO_TLSv1);
+  if (!(ti->version & TPTLS_VERSION_TLSv1_1))
+    SSL_CTX_set_options(tls->ctx, SSL_OP_NO_TLSv1_1);
+  if (!(ti->version & TPTLS_VERSION_TLSv1_2))
+    SSL_CTX_set_options(tls->ctx, SSL_OP_NO_TLSv1_2);
+  SSL_CTX_sess_set_remove_cb(tls->ctx, NULL);
+  SSL_CTX_set_timeout(tls->ctx, ti->timeout);
+  /* CRIME (CVE-2012-4929) mitigation */
+  SSL_CTX_set_options(tls->ctx, SSL_OP_NO_COMPRESSION);
 
   /* Set callback if we have a passphrase */
   if (ti->passphrase != NULL) {
@@ -353,6 +381,27 @@
     errno = EIO;
     return -1;
 #endif
+#ifndef OPENSSL_NO_DH
+  } else {
+    BIO *bio = BIO_new_file(ti->key, "r");
+    if (bio != NULL) {
+      DH *dh = PEM_read_bio_DHparams(bio, NULL, NULL, NULL);
+      if (dh != NULL) {
+        if (!SSL_CTX_set_tmp_dh(tls->ctx, dh)) {
+          SU_DEBUG_1(("%s: invalid DH parameters (PFS) because %s: %s\n",
+                      "tls_init_context",
+                      ERR_reason_error_string(ERR_get_error()),
+                      ti->key));
+        } else {
+          long options = SSL_OP_CIPHER_SERVER_PREFERENCE | SSL_OP_SINGLE_DH_USE;
+          options = SSL_CTX_set_options(tls->ctx, options);
+          SU_DEBUG_3(("%s\n", "tls: initialized DHE"));
+        }
+        DH_free(dh);
+      }
+      BIO_free(bio);
+    }
+#endif
   }
 
   if (!SSL_CTX_load_verify_locations(tls->ctx,
@@ -380,8 +429,14 @@
 
   SSL_CTX_set_verify_depth(tls->ctx, ti->verify_depth);
   SSL_CTX_set_verify(tls->ctx, verify, tls_verify_cb);
-
-  if (!SSL_CTX_set_cipher_list(tls->ctx, ti->cipher)) {
+#ifndef OPENSSL_NO_EC
+  if (tls_init_ecdh_curve(tls) == 0) {
+    SU_DEBUG_3(("%s\n", "tls: initialized ECDH"));
+  } else {
+    SU_DEBUG_3(("%s\n", "tls: failed to initialize ECDH"));
+  }
+#endif
+  if (!SSL_CTX_set_cipher_list(tls->ctx, ti->ciphers)) {
     SU_DEBUG_1(("%s: error setting cipher list\n", "tls_init_context"));
     tls_log_errors(3, "tls_init_context", 0);
     errno = EIO;
@@ -393,17 +448,27 @@
 
 void tls_free(tls_t *tls)
 {
+  int ret;
   if (!tls)
     return;
 
-  if (tls->con != NULL)
-    SSL_shutdown(tls->con);
+  if (tls->con != NULL) {
+    do {
+      ret = SSL_shutdown(tls->con);
+      if (ret == -1) {
+        /* The return value -1 means that the connection wasn't actually established */
+        /* so it should be safe to not call shutdown again. We need to clear the eror */
+        /* queue for other connections though. */
+        tls_log_errors(3, "tls_free", 0);
+        ret = 1;
+      }
+    } while (ret != 1);
+    SSL_free(tls->con), tls->con = NULL;
+  }
 
-  if (tls->ctx != NULL && tls->type != tls_slave)
+  if (tls->ctx != NULL && tls->type != tls_slave) {
     SSL_CTX_free(tls->ctx);
-
-  if (tls->bio_con != NULL)
-    BIO_free(tls->bio_con);
+  }
 
   su_home_unref(tls->home);
 }
@@ -442,13 +507,18 @@
 
   RAND_pseudo_bytes(sessionId, sizeof(sessionId));
 
-  SSL_CTX_set_session_id_context(tls->ctx,
+  if (!SSL_CTX_set_session_id_context(tls->ctx,
                                  (void*) sessionId,
-				 sizeof(sessionId));
+				 sizeof(sessionId))) {
+    tls_log_errors(3, "tls_init_master", 0);
+  }
 
-  if (ti->CAfile != NULL)
+  if (ti->CAfile != NULL) {
     SSL_CTX_set_client_CA_list(tls->ctx,
                                SSL_load_client_CA_file(ti->CAfile));
+    if (tls->ctx->client_CA == NULL)
+      tls_log_errors(3, "tls_init_master", 0);
+  }
 
 #if 0
   if (sock != -1) {
@@ -472,7 +542,6 @@
 
   if (tls) {
     tls->ctx = master->ctx;
-    tls->type = master->type;
     tls->accept = accept ? 1 : 0;
     tls->verify_outgoing = master->verify_outgoing;
     tls->verify_incoming = master->verify_incoming;
@@ -512,15 +581,35 @@
 int tls_post_connection_check(tport_t *self, tls_t *tls)
 {
   X509 *cert;
+  const SSL_CIPHER *cipher;
+  char cipher_description[256];
+  int cipher_bits, alg_bits;
   int extcount;
   int i, j, error;
 
   if (!tls) return -1;
 
+  if (!(cipher = SSL_get_current_cipher(tls->con))) {
+    tls_log_errors(3, "tls_post_connection_check", 0);
+    SU_DEBUG_7(("%s(%p): %s\n", __func__, (void*)self,
+                "OpenSSL failed to return an SSL_CIPHER object to us."));
+    return SSL_ERROR_SSL;
+  }
+  SU_DEBUG_9(("%s(%p): TLS cipher chosen (name): %s\n", __func__, (void*)self,
+              SSL_CIPHER_get_name(cipher)));
+  SU_DEBUG_9(("%s(%p): TLS cipher chosen (version): %s\n", __func__, (void*)self,
+              SSL_CIPHER_get_version(cipher)));
+  cipher_bits = SSL_CIPHER_get_bits(cipher, &alg_bits);
+  SU_DEBUG_9(("%s(%p): TLS cipher chosen (bits/alg_bits): %d/%d\n", __func__, (void*)self,
+              cipher_bits, alg_bits));
+  SSL_CIPHER_description(cipher, cipher_description, sizeof(cipher_description));
+  SU_DEBUG_9(("%s(%p): TLS cipher chosen (description): %s\n", __func__, (void*)self,
+              cipher_description));
+
   cert = SSL_get_peer_certificate(tls->con);
   if (!cert) {
     SU_DEBUG_7(("%s(%p): Peer did not provide X.509 Certificate.\n", 
-		 __func__, (void *) self));
+				__func__, (void *) self));
     if (self->tp_accepted && tls->verify_incoming)
       return X509_V_ERR_CERT_UNTRUSTED;
     else if (!self->tp_accepted && tls->verify_outgoing)
@@ -602,10 +691,10 @@
     int i, len = su_strlst_len(tls->subjects);
     for (i=0; i < len; i++)
       SU_DEBUG_7(("%s(%p): Peer Certificate Subject %i: %s\n", \
-	      __func__, (void *)self, i, su_strlst_item(tls->subjects, i)));
+				  __func__, (void *)self, i, su_strlst_item(tls->subjects, i)));
     if (i == 0)
       SU_DEBUG_7(("%s(%p): Peer Certificate provided no usable subjects.\n",
-		   __func__, (void *)self));
+				  __func__, (void *)self));
   }
 
   /* Verify incoming connections */
@@ -629,7 +718,7 @@
 	  return X509_V_OK;
       }
       SU_DEBUG_3(("%s(%p): Peer Subject Mismatch (incoming connection)\n", \
-		   __func__, (void *)self));
+				  __func__, (void *)self));
 
       return X509_V_ERR_CERT_UNTRUSTED;
     }
@@ -647,7 +736,7 @@
       if (tport_subject_search(subject, tls->subjects))
         return X509_V_OK; /* Subject match found in verified certificate chain */
       SU_DEBUG_3(("%s(%p): Peer Subject Mismatch (%s)\n", \
-		    __func__, (void *)self, subject));
+				  __func__, (void *)self, subject));
 
       return X509_V_ERR_CERT_UNTRUSTED;
     }
@@ -676,6 +765,7 @@
     return 0;
 
   case SSL_ERROR_SYSCALL:
+    ERR_clear_error();
     if (SSL_get_shutdown(tls->con) & SSL_RECEIVED_SHUTDOWN)
       return 0;			/* EOS */
     if (errno == 0)
@@ -804,7 +894,7 @@
   tls->write_events = 0;
 
   ret = SSL_write(tls->con, buf, size);
-  if (ret < 0)
+  if (ret <= 0)
     return tls_error(tls, ret, "tls_write: SSL_write", buf, size);
 
   return ret;
@@ -927,6 +1017,8 @@
           if ((su_wait_create(wait, self->tp_socket, self->tp_events) == -1) ||
              ((self->tp_index = su_root_register(mr->mr_root, wait, tport_wakeup,
                                                            self, 0)) == -1)) {
+
+            tls_log_errors(3, "TLS post handshake error", status);
             tport_close(self);
             tport_set_secondary_timer(self);
 	    return 0;
@@ -948,12 +1040,7 @@
 	break;
 
       default:
-        {
-	  char errbuf[64];
-	  ERR_error_string_n(status, errbuf, 64);
-          SU_DEBUG_3(("%s(%p): TLS setup failed (%s)\n",
-		    __func__, (void *)self, errbuf));
-        }
+        tls_log_errors(3, "TLS setup failed", status);
         break;
     }
   }
diff -ur a/libsofia-sip-ua/tport/tport_tls.h b/libsofia-sip-ua/tport/tport_tls.h
--- a/libsofia-sip-ua/tport/tport_tls.h	2011-03-11 16:49:19.000000000 +0200
+++ b/libsofia-sip-ua/tport/tport_tls.h	2017-12-07 23:26:00.712844655 +0200
@@ -60,11 +60,12 @@
   char *randFile;       /* Seed file for the PRNG (default: tls_seed.dat) */
   char *CAfile;		/* PEM file of CA's                           */
   char *CApath;		/* PEM file path of CA's		      */
-  char *cipher;         /* Should be one of the above defined ciphers *
-			 * or NULL (default: "ALL:!ADH:!LOW:!EXP:!MD5:@STRENGTH
+  char *ciphers;         /* Should be one of the above defined ciphers *
+			 * or NULL (default: !eNULL:!aNULL:!EXP:!LOW:!MD5:ALL:@STRENGTH)
                          */
   int   version;	/* For tls1, version is 1. When ssl3/ssl2 is
 			 * used, it is 0. */
+  unsigned timeout;	/* Maximum session lifetime in seconds */
 } tls_issues_t;
 
 typedef struct tport_tls_s {
@@ -82,6 +83,7 @@
 tls_t *tls_init_secondary(tls_t *tls_master, int sock, int accept);
 void tls_free(tls_t *tls);
 int tls_get_socket(tls_t *tls);
+void tls_log_errors(unsigned level, char const *s, unsigned long e);
 ssize_t tls_read(tls_t *tls);
 void *tls_read_buffer(tls_t *tls, size_t N);
 int tls_want_read(tls_t *tls, int events);
@@ -92,6 +94,7 @@
 int tls_want_write(tls_t *tls, int events);
 
 int tls_events(tls_t const *tls, int flags);
+void tls_init(void);
 
 SOFIA_END_DECLS
 
Only in b/libsofia-sip-ua/tport: tport_tls_test.sh
diff -ur a/libsofia-sip-ua/tport/tport_type_connect.c b/libsofia-sip-ua/tport/tport_type_connect.c
--- a/libsofia-sip-ua/tport/tport_type_connect.c	2011-03-11 16:49:19.000000000 +0200
+++ b/libsofia-sip-ua/tport/tport_type_connect.c	2017-12-07 23:26:00.716844677 +0200
@@ -201,7 +201,7 @@
   msg_set_next(response, thci->thci_stackmsg = tport_msg_alloc(tport, 512));
 
   if (tport_send_msg(tport, msg, tpn, NULL) < 0) {
-    SU_DEBUG_9(("tport_send_msg failed in tpot_http_connect\n"));
+    SU_DEBUG_9(("tport_send_msg failed in tpot_http_connect\n" VA_NONE));
     msg_destroy(msg);
     tport_zap_secondary(tport);
     return NULL;
diff -ur a/libsofia-sip-ua/tport/tport_type_sctp.c b/libsofia-sip-ua/tport/tport_type_sctp.c
--- a/libsofia-sip-ua/tport/tport_type_sctp.c	2011-03-11 16:49:19.000000000 +0200
+++ b/libsofia-sip-ua/tport/tport_type_sctp.c	2017-12-07 23:26:00.720844699 +0200
@@ -260,6 +260,9 @@
   if (self->tp_master->mr_dump_file)
     tport_dump_iovec(self, msg, N, iovec, veclen, "recv", "from");
 
+ if (self->tp_master->mr_capt_sock)
+     tport_capt_msg(self, msg, N, iovec, veclen, "recv");
+     
   msg_recv_commit(msg, N, 0);  /* Mark buffer as used */
 
   return 2;
diff -ur a/libsofia-sip-ua/tport/tport_type_stun.c b/libsofia-sip-ua/tport/tport_type_stun.c
--- a/libsofia-sip-ua/tport/tport_type_stun.c	2011-03-11 16:49:19.000000000 +0200
+++ b/libsofia-sip-ua/tport/tport_type_stun.c	2017-12-07 23:26:00.724844720 +0200
@@ -170,10 +170,10 @@
 			stun_action_t action,
 			stun_state_t event)
 {
-  tport_master_t *mr;
+  //tport_master_t *mr;
   SU_DEBUG_3(("%s: %s\n", __func__, stun_str_state(event)));
 
-  mr = pri->pri_master;
+  //mr = pri->pri_master;
 
   if (event == stun_discovery_done) {
     tport_stun_bind_done(pri, sh, sd);
diff -ur a/libsofia-sip-ua/tport/tport_type_tcp.c b/libsofia-sip-ua/tport/tport_type_tcp.c
--- a/libsofia-sip-ua/tport/tport_type_tcp.c	2011-03-11 16:49:19.000000000 +0200
+++ b/libsofia-sip-ua/tport/tport_type_tcp.c	2017-12-07 23:26:00.728844742 +0200
@@ -184,13 +184,32 @@
 int tport_tcp_init_secondary(tport_t *self, int socket, int accepted,
 			     char const **return_reason)
 {
-  int one = 1;
+  int val = 1;
 
   self->tp_has_connection = 1;
 
-  if (setsockopt(socket, SOL_TCP, TCP_NODELAY, (void *)&one, sizeof one) == -1)
+  self->tp_params->tpp_idle = UINT_MAX;
+
+  if (setsockopt(socket, SOL_TCP, TCP_NODELAY, (void *)&val, sizeof val) == -1)
     return *return_reason = "TCP_NODELAY", -1;
 
+#if defined(SO_KEEPALIVE)
+  setsockopt(socket, SOL_SOCKET, SO_KEEPALIVE, (void *)&val, sizeof val);
+#endif
+  val = (int)(self->tp_params->tpp_socket_keepalive);
+#if defined(TCP_KEEPIDLE)
+  if (val != 0 && val != UINT_MAX) {
+    SU_DEBUG_3(("%s(%p): Setting TCP_KEEPIDLE to %d\n",
+                __func__, (void *)self, val));
+    setsockopt(socket, SOL_TCP, TCP_KEEPIDLE, (void *)&val, sizeof val);}
+#endif
+#if defined(TCP_KEEPINTVL)
+  if (val != 0 && val != UINT_MAX) {
+    SU_DEBUG_3(("%s(%p): Setting TCP_KEEPINTVL to %d\n",
+                __func__, (void *)self, val));
+    setsockopt(socket, SOL_TCP, TCP_KEEPINTVL, (void *)&val, sizeof val);}
+#endif
+
   if (!accepted)
     tport_tcp_setsndbuf(socket, 64 * 1024);
 
@@ -334,6 +353,10 @@
   /* Write the received data to the message dump file */
   if (self->tp_master->mr_dump_file)
     tport_dump_iovec(self, msg, n, iovec, veclen, "recv", "from");
+    
+  if (self->tp_master->mr_capt_sock)
+      tport_capt_msg(self, msg, n, iovec, veclen, "recv");
+         
 
   /* Mark buffer as used */
   msg_recv_commit(msg, n, n == 0);
diff -ur a/libsofia-sip-ua/tport/tport_type_tls.c b/libsofia-sip-ua/tport/tport_type_tls.c
--- a/libsofia-sip-ua/tport/tport_type_tls.c	2011-03-11 16:49:19.000000000 +0200
+++ b/libsofia-sip-ua/tport/tport_type_tls.c	2017-12-07 23:26:00.732844764 +0200
@@ -180,7 +180,9 @@
   char *homedir;
   char *tbf = NULL;
   char const *path = NULL;
+  char const *tls_ciphers = NULL;
   unsigned tls_version = 1;
+  unsigned tls_timeout = 300;
   unsigned tls_verify = 0;
   char const *passphrase = NULL;
   unsigned tls_policy = TPTLS_VERIFY_NONE;
@@ -197,7 +199,9 @@
 
   tl_gets(tags,
 	  TPTAG_CERTIFICATE_REF(path),
+	  TPTAG_TLS_CIPHERS_REF(tls_ciphers),
 	  TPTAG_TLS_VERSION_REF(tls_version),
+	  TPTAG_TLS_TIMEOUT_REF(tls_timeout),
 	  TPTAG_TLS_VERIFY_PEER_REF(tls_verify),
 	  TPTAG_TLS_PASSPHRASE_REF(passphrase),
 	  TPTAG_TLS_VERIFY_POLICY_REF(tls_policy),
@@ -220,10 +224,16 @@
     ti.configured = path != tbf;
     ti.randFile = su_sprintf(autohome, "%s/%s", path, "tls_seed.dat");
     ti.key = su_sprintf(autohome, "%s/%s", path, "agent.pem");
+	if (access(ti.key, R_OK) != 0) ti.key = NULL;
+    if (!ti.key) ti.key = su_sprintf(autohome, "%s/%s", path, "tls.pem");
     ti.passphrase = su_strdup(autohome, passphrase);
     ti.cert = ti.key;
     ti.CAfile = su_sprintf(autohome, "%s/%s", path, "cafile.pem");
+	if (access(ti.CAfile, R_OK) != 0) ti.CAfile = NULL;
+    if (!ti.CAfile) ti.CAfile = su_sprintf(autohome, "%s/%s", path, "tls.pem");
+    if (tls_ciphers) ti.ciphers = su_strdup(autohome, tls_ciphers);
     ti.version = tls_version;
+    ti.timeout = tls_timeout;
     ti.CApath = su_strdup(autohome, path);
 
     SU_DEBUG_9(("%s(%p): tls key = %s\n", __func__, (void *)pri, ti.key));
diff -ur a/libsofia-sip-ua/tport/tport_type_udp.c b/libsofia-sip-ua/tport/tport_type_udp.c
--- a/libsofia-sip-ua/tport/tport_type_udp.c	2011-03-11 16:49:19.000000000 +0200
+++ b/libsofia-sip-ua/tport/tport_type_udp.c	2017-12-07 23:26:00.736844786 +0200
@@ -362,6 +362,9 @@
 
   if (self->tp_master->mr_dump_file)
     tport_dump_iovec(self, msg, n, iovec, veclen, "recv", "from");
+    
+  if (self->tp_master->mr_capt_sock)
+    tport_capt_msg(self, msg, n, iovec, veclen, "recv");
 
   *sample = *((uint8_t *)iovec[0].mv_base);
 
Only in b/libsofia-sip-ua/tport: tport_type_ws.c
Only in b/libsofia-sip-ua/tport: tport_ws.h
Only in b/libsofia-sip-ua/tport: ws.c
Only in b/libsofia-sip-ua/tport: ws.h
diff -ur a/libsofia-sip-ua/url/torture_url.c b/libsofia-sip-ua/url/torture_url.c
--- a/libsofia-sip-ua/url/torture_url.c	2011-03-11 16:49:19.000000000 +0200
+++ b/libsofia-sip-ua/url/torture_url.c	2017-12-07 23:26:00.776845003 +0200
@@ -246,7 +246,7 @@
     "?From=foo@bar&To=bar@baz#unf";
   char sip2url[] =
     "sip:user/path;tel-param:pass@host:32;param=1%3d%3d1"
-    "?From=foo@bar&body=CANNED%20MSG&To=bar@baz#unf";
+    "?From=foo@bar&To=bar@baz#unf";
   char sip2[sizeof(sipurl) + 32];
   char sipsurl[] =
     "sips:user:pass@host:32;param=1"
@@ -311,7 +311,7 @@
   TEST_S(url->url_params, "param=1%3D%3D1");
 
   TEST_S(url_query_as_header_string(home, url->url_headers),
-	 "From:foo@bar\nTo:bar@baz\n\nCANNED MSG");
+	 "From:foo@bar\nTo:bar@baz");
 
   url_digest(hash1, sizeof(hash1), url, NULL);
   url_digest(hash2, sizeof(hash2), (url_t *)sip2url, NULL);
diff -ur a/libsofia-sip-ua/url/url.c b/libsofia-sip-ua/url/url.c
--- a/libsofia-sip-ua/url/url.c	2011-03-11 16:49:19.000000000 +0200
+++ b/libsofia-sip-ua/url/url.c	2017-12-07 23:26:00.784845046 +0200
@@ -185,7 +185,7 @@
  * The number of characters in corresponding but escaped string.
  *
  * You can handle a part of URL with reserved characters like this:
- * @code
+ *Â @code
  * if (url_reserved_p(s))  {
  *   n = malloc(url_esclen(s, NULL) + 1);
  *   if (n) url_escape(n, s);
@@ -567,7 +567,7 @@
 int _url_d(url_t *url, char *s)
 {
   size_t n, p;
-  char *s0, rest_c, *host, *user;
+  char rest_c, *host, *user;
   int have_authority = 1;
 
   memset(url, 0, sizeof(*url));
@@ -578,8 +578,6 @@
     return 0;
   }
 
-  s0 = s;
-
   n = strcspn(s, ":/?#");
 
   if (n && s[n] == ':') {
@@ -1090,7 +1088,7 @@
  * @param buf     Buffer for non-constant strings copied from @a src.
  * @param bufsize Size of @a buf.
  * @param dst     Destination URL structure.
- * @param src     Source URL structure.
+ *Â @param src     Source URL structure.
  *
  * @return Number of characters required for
  * duplicating the strings in @a str, or -1 if an error
@@ -1174,7 +1172,7 @@
  * @param buf     Buffer for non-constant strings copied from @a src.
  * @param end     End of @a buf.
  * @param dst     Destination URL structure.
- * @param src     Source URL structure.
+ *Â @param src     Source URL structure.
  *
  * @return
  * The macro URL_DUP() returns pointer to first unused byte in the
@@ -2110,33 +2108,30 @@
   if (!s)
     return NULL;
 
-  for (i = 0, j = 0; query[i];) {
-    n = strcspn(query + i, "=");
-    if (!query[i + n])
+  for (i = 0, j = 0; s[i];) {
+    n = strcspn(s + i, "=");
+    if (!s[i + n])
       break;
-    if (n == 4 && su_strncasecmp(query + i, "body", 4) == 0) {
+    if (n == 4 && strncasecmp(s + i, "body", 4) == 0) {
       if (b_start)
 	break;
-      b_start = i + n + 1, b_len = strcspn(query + b_start, "&");
-      i = b_start + b_len;
-      if (!query[i])
-        break;
-      i++;
+      b_start = i + n + 1, b_len = strcspn(s + b_start, "&");
+      i = b_start + b_len + 1;
       continue;
     }
     if (i != j)
-      memcpy(s + j, query + i, n);
+      memmove(s + j, s + i, n);
     s[j + n] = ':';
     i += n + 1, j += n + 1;
-    n = strcspn(query + i, "&");
-    j += url_unescape_to(s + j, query + i, n);
+    n = strcspn(s + i, "&");
+    j += url_unescape_to(s + j, s + i, n);
     i += n;
-    if (query[i]) {
+    if (s[i]) {
       s[j++] = '\n', i++;
     }
   }
 
-  if (query[i])
+  if (s[i])
     return (void)su_free(home, s), NULL;
 
   if (b_start) {
diff -ur a/open_c/config.h b/open_c/config.h
--- a/open_c/config.h	2011-03-11 16:49:59.000000000 +0200
+++ b/open_c/config.h	2017-12-07 23:26:01.984851554 +0200
@@ -1,438 +1,438 @@
-/* config.h.in.  Template for Open C  */
-
-/* Define to 1 if using `alloca.c'. */
-/* #undef C_ALLOCA */
-
-/* Define to the random number source name. */
-/* #undef DEV_URANDOM */
-
-/* Define to 1 if you have addrinfo structure. */
-#define HAVE_ADDRINFO 1
-
-/* Define to 1 if you have the `alarm' function. */
-/* #undef HAVE_ALARM */
-
-/* Define to 1 if you have `alloca', as a function or macro. */
-/* #undef HAVE_ALLOCA */
-
-/* Define to 1 if you have <alloca.h> and it should be used (not on Ultrix).
-   */
-/* #undef HAVE_ALLOCA_H 1 */
-
-/* Define to 1 if you have the <arpa/inet.h> header file. */
-#define HAVE_ARPA_INET_H 1
-
-/* Define to 1 if you have the `clock_getcpuclockid' function. */
-/* #undef HAVE_CLOCK_GETCPUCLOCKID */
-
-/* Define to 1 if you have the `clock_gettime' function. */
-/* #undef HAVE_CLOCK_GETTIME */
-
-/* Define to 1 if you have /dev/urandom. */
-/* #undef HAVE_DEV_URANDOM */
-
-/* Define to 1 if you have the <dirent.h> header file. */
-#define HAVE_DIRENT_H 1
-
-/* Define to 1 if you have the <dlfcn.h> header file. */
-#define HAVE_DLFCN_H 1
-
-/* Define to 1 if you have epoll interface. */
-/* #undef HAVE_EPOLL */
-
-/* Define to 1 if you have the `epoll_create' function. */
-/* #undef HAVE_EPOLL_CREATE */
-
-/* Define to 1 if you have the <fcntl.h> header file. */
-#define HAVE_FCNTL_H 1
-
-/* Define to 1 if you have WIN32 FILETIME type and GetSystemTimeAsFileTime().
-   */
-/* #undef HAVE_FILETIME */
-
-/* Define to 1 if you have the `flock' function. */
-/* #undef HAVE_FLOCK */
-
-/* Define to 1 if you have the `freeaddrinfo' function. */
-#define HAVE_FREEADDRINFO 1
-
-/* Define to 1 if the C compiler supports __func__ */
-#define HAVE_FUNC 1
-
-/* Define to 1 if the C compiler supports __FUNCTION__ */
-#define HAVE_FUNCTION 1
-
-/* Define to 1 if you have the `gai_strerror' function. */
-#define HAVE_GAI_STRERROR 1
-
-/* Define to 1 if you have the `getaddrinfo' function. */
-#define HAVE_GETADDRINFO 1
-
-/* Define to 1 if you have the `getdelim' function. */
-/* #undef HAVE_GETDELIM */
-
-/* Define to 1 if you have the `gethostbyname' function. */
-#define HAVE_GETHOSTBYNAME 1
-
-/* Define to 1 if you have the `gethostname' function. */
-#define HAVE_GETHOSTNAME 1
-
-/* Define to 1 if you have the `getifaddrs' function. */
-/* #undef HAVE_GETIFADDRS 1 */
-
-/* Define to 1 if you have the `getipnodebyname' function. */
-#define HAVE_GETIPNODEBYNAME 1
-
-/* Define to 1 if you have the `getline' function. */
-/* #undef HAVE_GETLINE */
-
-/* Define to 1 if you have the `getnameinfo' function. */
-#define HAVE_GETNAMEINFO 1
-
-/* Define to 1 if you have the `getpass' function. */
-#define HAVE_GETPASS 1
-
-/* Define to 1 if you have the `gettimeofday' function. */
-#define HAVE_GETTIMEOFDAY 1
-
-/* Define to 1 if you have the <ifaddr.h> header file. */
-/* #undef HAVE_IFADDR_H */
-
-/* Define to 1 if you have SIOCGIFCONF */
-#define HAVE_IFCONF 1
-
-/* Define to 1 if you have SIOCGIFNUM ioctl */
-/* #undef HAVE_IFNUM */
-
-/* Define to 1 if you have ifr_ifindex in <net/if.h> */
-/* #undef HAVE_IFR_IFINDEX */
-
-/* Define to 1 if you have ifr_index in <net/if.h> */
-#define HAVE_IFR_INDEX 1
-
-/* Define to 1 if you have the `if_nameindex' function. */
-#define HAVE_IF_NAMEINDEX 1
-
-/* Define to 1 if you have the `inet_ntop' function. */
-#define HAVE_INET_NTOP 1
-
-/* Define to 1 if you have the `inet_pton' function. */
-#define HAVE_INET_PTON 1
-
-/* Define to 1 if you have the `initstate' function. */
-#define HAVE_INITSTATE 1
-
-/* Define to 1 if you have inlining compiler */
-#define HAVE_INLINE 1
-
-/* Define to 1 if you have WIN32 INTERFACE_INFO_EX type. */
-/* #undef HAVE_INTERFACE_INFO_EX */
-
-/* Define to 1 if you have the <inttypes.h> header file. */
-#define HAVE_INTTYPES_H 1
-
-/* Define to 1 if you have the <iphlpapi.h> header file. */
-/* #undef HAVE_IPHLPAPI_H */
-
-/* Define to 1 if you have IPV6_RECVERR in <netinet/in6.h> */
-/* #undef HAVE_IPV6_RECVERR */
-
-/* Define to 1 if you have IP_RECVERR in <netinet/in.h> */
-/* #undef HAVE_IP_RECVERR */
-
-/* Define to 1 if you have the `kqueue' function. */
-/* #undef HAVE_KQUEUE 1 */
-
-/* Define to 1 if you use kqueue in su_port. */
-/* #undef HAVE_KQUEUE_PORT 1 */
-
-/* Define to 1 if you have the `crypto' library (-lcrypto). */
-#define HAVE_LIBCRYPTO 1
-
-/* Define to 1 if you have the `pthread' library (-lpthread). */
-#define HAVE_LIBPTHREAD 1
-
-/* Define to 1 if you have the `socket' library (-lsocket). */
-/* #undef HAVE_LIBSOCKET */
-
-/* Define to 1 if you have the `ssl' library (-lssl). */
-#define HAVE_LIBSSL 1
-
-/* Define to 1 if you have the `memccpy' function. */
-#define HAVE_MEMCCPY 1
-
-/* Define to 1 if you have the `memcspn' function. */
-/* #undef HAVE_MEMCSPN */
-
-/* Define to 1 if you have the `memmem' function. */
-/* #undef HAVE_MEMMEM */
-
-/* Define to 1 if you have the <memory.h> header file. */
-#define HAVE_MEMORY_H 1
-
-/* Define to 1 if you have the `memspn' function. */
-/* #undef HAVE_MEMSPN */
-
-/* Define to 1 if you are compiling in MinGW environment */
-/* #undef HAVE_MINGW */
-
-/* Define to 1 if you have MSG_TRUNC flag */
-#define HAVE_MSG_TRUNC 1
-
-/* Define to 1 if you have the <netdb.h> header file. */
-#define HAVE_NETDB_H 1
-
-/* Define to 1 if you have the <netinet/in.h> header file. */
-#define HAVE_NETINET_IN_H 1
-
-/* Define to 1 if you have the <netinet/sctp.h> header file. */
-/* #undef HAVE_NETINET_SCTP_H */
-
-/* Define to 1 if you have the <netinet/tcp.h> header file. */
-/* #undef HAVE_NETINET_TCP_H */
-
-/* Define to 1 if you have the <netpacket/packet.h> header file. */
-/* #undef HAVE_NETPACKET_PACKET_H */
-
-/* Define to 1 if you have the <net/if.h> header file. */
-#define HAVE_NET_IF_H 1
-
-/* Define to 1 if you have the <net/if_types.h> header file. */
-/* #undef HAVE_NET_IF_TYPES_H 1 */
-
-/* Define to 1 if you have OpenSSL */
-#define HAVE_OPENSSL 1
-
-/* Define to 1 if you have the <openssl/tls1.h> header file. */
-#define HAVE_OPENSSL_TLS1_H 1
-
-/* Define to 1 if you have the `poll' function. */
-/* #undef HAVE_POLL 1 */
-
-/* Define to 1 if you use poll in su_port. */
-#define HAVE_POLL_PORT 1
-
-/* Define to 1 if you have /proc/net/if_inet6 control file */
-/* #undef HAVE_PROC_NET_IF_INET6 */
-
-/* Define to 1 if you have working pthread_rwlock_t implementation. A thread
-   may hold multiple concurrent read locks on rwlock - that is, successfully
-   call the pthread_rwlock_rdlock() function n times. If so, the application
-   shall ensure that the thread performs matching unlocks - that is, it calls
-   the pthread_rwlock_unlock() function n times. */
-#define HAVE_PTHREAD_RWLOCK 1
-
-/* Define to 1 if you have the `random' function. */
-#define HAVE_RANDOM 1
-
-/* Define to 1 if you have sa_len in struct sockaddr */
-/* #undef HAVE_SA_LEN */
-
-/* Define to 1 if you have SCTP */
-/* #undef HAVE_SCTP */
-
-/* Define to 1 if you have the `select' function. */
-#define HAVE_SELECT 1
-
-/* Define to 1 if you have Sofia sigcomp >= 2.5 */
-/* #undef HAVE_SIGCOMP */
-
-/* Define to 1 if you have the <sigcomp.h> header file. */
-/* #undef HAVE_SIGCOMP_H */
-
-/* Define to 1 if you have the `signal' function. */
-/* #undef HAVE_SIGNAL */
-
-/* Define to 1 if you have SIGPIPE */
-/* #undef HAVE_SIGPIPE */
-
-/* Define to 1 if you have IPv6 structures and constants */
-/* #undef HAVE_SIN6 */
-
-/* Define to 1 if you have WIN32 WSAIoctl SIO_ADDRESS_LIST_QUERY. */
-/* #undef HAVE_SIO_ADDRESS_LIST_QUERY */
-
-/* Define to 1 if you have the `socketpair' function. */
-/* #undef HAVE_SOCKETPAIR */
-
-/* Define to 1 if we use NTH library */
-/* #undef HAVE_SOFIA_NTH */
-
-/* Define to 1 if we use NTLM library */
-/* #undef HAVE_SOFIA_NTLM */
-
-/* Define to 1 if you have Sofia sigcomp >= 2.5 */
-/* #undef HAVE_SOFIA_SIGCOMP */
-
-/* Define to 1 always */
-#define HAVE_SOFIA_SIP 1
-
-/* Define to 1 if we use S/MIME library */
-#define HAVE_SOFIA_SMIME 0
-
-/* Define to 1 if we use DNS library */
-#define HAVE_SOFIA_SRESOLV 1
-
-/* Define to 1 if we use STUN library */
-#define HAVE_SOFIA_STUN 1
-
-/* Define to 1 if we use SRTP */
-#define HAVE_SRTP 0
-
-/* Define to 1 if you have the <stdint.h> header file. */
-#define HAVE_STDINT_H 1
-
-/* Define to 1 if you have the <stdlib.h> header file. */
-#define HAVE_STDLIB_H 1
-
-/* Define to 1 if you have the `strcasestr' function. */
-#define HAVE_STRCASESTR 1
-
-/* Define to 1 if you have the `strerror' function. */
-#define HAVE_STRERROR 1
-
-/* Define to 1 if you have the <strings.h> header file. */
-#define HAVE_STRINGS_H 1
-
-/* Define to 1 if you have the <string.h> header file. */
-#define HAVE_STRING_H 1
-
-/* Define to 1 if you have the `strtoull' function. */
-/* #undef HAVE_STRTOULL */
-
-/* Define to 1 if your CC supports C99 struct initialization */
-#define HAVE_STRUCT_KEYWORDS 1
-
-/* Define to 1 if you have the <sys/epoll.h> header file. */
-/* #undef HAVE_SYS_EPOLL_H */
-
-/* Define to 1 if you have the <sys/event.h> header file. */
-#define HAVE_SYS_EVENT_H 1
-
-/* Define to 1 if you have the <sys/filio.h> header file. */
-/* #undef HAVE_SYS_FILIO_H */
-
-/* Define to 1 if you have the <sys/ioctl.h> header file. */
-#define HAVE_SYS_IOCTL_H 1
-
-/* Define to 1 if you have the <sys/select.h> header file. */
-#define HAVE_SYS_SELECT_H 1
-
-/* Define to 1 if you have the <sys/socket.h> header file. */
-#define HAVE_SYS_SOCKET_H 1
-
-/* Define to 1 if you have the <sys/sockio.h> header file. */
-#define HAVE_SYS_SOCKIO_H 1
-
-/* Define to 1 if you have the <sys/stat.h> header file. */
-#define HAVE_SYS_STAT_H 1
-
-/* Define to 1 if you have the <sys/time.h> header file. */
-#define HAVE_SYS_TIME_H 1
-
-/* Define to 1 if you have the <sys/types.h> header file. */
-#define HAVE_SYS_TYPES_H 1
-
-/* Define to 1 if you have the `tcsetattr' function. */
-#define HAVE_TCSETATTR 1
-
-/* Define to 1 if you have TLS */
-/* #undef HAVE_TLS */
-
-/* Define to 1 if you have the <unistd.h> header file. */
-#define HAVE_UNISTD_H 1
-
-/* Define to 1 if we use UPnP */
-#define HAVE_UPNP 0
-
-/* Define to 1 you have WIN32 */
-/* #undef HAVE_WIN32 */
-
-/* Define to 1 if you have the <windef.h> header file. */
-/* #undef HAVE_WINDEF_H */
-
-/* Define to 1 if you have the <winsock2.h> header file. */
-/* #undef HAVE_WINSOCK2_H */
-
-/* Define to 1 if you have the <ws2tcpip.h> header file. */
-/* #undef HAVE_WS2TCPIP_H */
-
-/* Define to format (%lli) for long long */
-#define LLI "%lli"
-
-/* Define to format (%llu) for unsigned long long */
-#define LLU "%llu"
-
-/* Define to format (%llx) for long long hex */
-#define LLX "%llx"
-
-/* Define printf() modifier for ssize_t */
-#define MOD_ZD "%zd"
-
-/* Define printf() modifier for size_t */
-#define MOD_ZU "%zu"
-
-/* Name of package */
-#define PACKAGE "sofia-sip"
-
-/* Define to the address where bug reports for this package should be sent. */
-#define PACKAGE_BUGREPORT ""
-
-/* Define to the full name of this package. */
-#define PACKAGE_NAME "sofia-sip"
-
-/* Define to the full name and version of this package. */
-#define PACKAGE_STRING "sofia-sip 1.12.5work"
-
-/* Define to the one symbol short name of this package. */
-#define PACKAGE_TARNAME "sofia-sip"
-
-/* Define to the version of this package. */
-#define PACKAGE_VERSION "1.12.5work"
-
-/* Define as the return type of signal handlers (`int' or `void'). */
-#define RETSIGTYPE void
-
-/* If using the C implementation of alloca, define if you know the
-   direction of stack growth for your system; otherwise it will be
-   automatically deduced at run-time.
-	STACK_DIRECTION > 0 => grows toward higher addresses
-	STACK_DIRECTION < 0 => grows toward lower addresses
-	STACK_DIRECTION = 0 => direction of growth unknown */
-/* #undef STACK_DIRECTION */
-
-/* Define to 1 if you have the ANSI C header files. */
-#define STDC_HEADERS 1
-
-/* Define to 1 if you can safely include both <sys/time.h> and <time.h>. */
-#define TIME_WITH_SYS_TIME 1
-
-/* Version number of package */
-#define VERSION "1.12.5work"
-
-/* Define to 1 if your processor stores words with the most significant byte
-   first (like Motorola and SPARC, unlike Intel and VAX). */
-/* #undef WORDS_BIGENDIAN */
-
-/* Enable GNU extensions on systems that have them.  */
-#ifndef _GNU_SOURCE
-# define _GNU_SOURCE 1
-#endif
-
-/* Define to empty if `const' does not conform to ANSI C. */
-/* #undef const */
-
-/* Define to `__inline__' or `__inline' if that's what the C compiler
-   calls it, or to nothing if 'inline' is not supported under any name.  */
-#ifndef __cplusplus
-/* #undef inline */
-#endif
-
-/* Define to a at least 64-bit int type */
-#define longlong long long
-
-/* Define to `unsigned' if <sys/types.h> does not define. */
-/* #undef size_t */
-
-/* Define to 1 if compiling on Open C environment */
-#define HAVE_OPEN_C 1
+/* config.h.in.  Template for Open C  */
+
+/* Define to 1 if using `alloca.c'. */
+/* #undef C_ALLOCA */
+
+/* Define to the random number source name. */
+/* #undef DEV_URANDOM */
+
+/* Define to 1 if you have addrinfo structure. */
+#define HAVE_ADDRINFO 1
+
+/* Define to 1 if you have the `alarm' function. */
+/* #undef HAVE_ALARM */
+
+/* Define to 1 if you have `alloca', as a function or macro. */
+/* #undef HAVE_ALLOCA */
+
+/* Define to 1 if you have <alloca.h> and it should be used (not on Ultrix).
+   */
+/* #undef HAVE_ALLOCA_H 1 */
+
+/* Define to 1 if you have the <arpa/inet.h> header file. */
+#define HAVE_ARPA_INET_H 1
+
+/* Define to 1 if you have the `clock_getcpuclockid' function. */
+/* #undef HAVE_CLOCK_GETCPUCLOCKID */
+
+/* Define to 1 if you have the `clock_gettime' function. */
+/* #undef HAVE_CLOCK_GETTIME */
+
+/* Define to 1 if you have /dev/urandom. */
+/* #undef HAVE_DEV_URANDOM */
+
+/* Define to 1 if you have the <dirent.h> header file. */
+#define HAVE_DIRENT_H 1
+
+/* Define to 1 if you have the <dlfcn.h> header file. */
+#define HAVE_DLFCN_H 1
+
+/* Define to 1 if you have epoll interface. */
+/* #undef HAVE_EPOLL */
+
+/* Define to 1 if you have the `epoll_create' function. */
+/* #undef HAVE_EPOLL_CREATE */
+
+/* Define to 1 if you have the <fcntl.h> header file. */
+#define HAVE_FCNTL_H 1
+
+/* Define to 1 if you have WIN32 FILETIME type and GetSystemTimeAsFileTime().
+   */
+/* #undef HAVE_FILETIME */
+
+/* Define to 1 if you have the `flock' function. */
+/* #undef HAVE_FLOCK */
+
+/* Define to 1 if you have the `freeaddrinfo' function. */
+#define HAVE_FREEADDRINFO 1
+
+/* Define to 1 if the C compiler supports __func__ */
+#define HAVE_FUNC 1
+
+/* Define to 1 if the C compiler supports __FUNCTION__ */
+#define HAVE_FUNCTION 1
+
+/* Define to 1 if you have the `gai_strerror' function. */
+#define HAVE_GAI_STRERROR 1
+
+/* Define to 1 if you have the `getaddrinfo' function. */
+#define HAVE_GETADDRINFO 1
+
+/* Define to 1 if you have the `getdelim' function. */
+/* #undef HAVE_GETDELIM */
+
+/* Define to 1 if you have the `gethostbyname' function. */
+#define HAVE_GETHOSTBYNAME 1
+
+/* Define to 1 if you have the `gethostname' function. */
+#define HAVE_GETHOSTNAME 1
+
+/* Define to 1 if you have the `getifaddrs' function. */
+/* #undef HAVE_GETIFADDRS 1 */
+
+/* Define to 1 if you have the `getipnodebyname' function. */
+#define HAVE_GETIPNODEBYNAME 1
+
+/* Define to 1 if you have the `getline' function. */
+/* #undef HAVE_GETLINE */
+
+/* Define to 1 if you have the `getnameinfo' function. */
+#define HAVE_GETNAMEINFO 1
+
+/* Define to 1 if you have the `getpass' function. */
+#define HAVE_GETPASS 1
+
+/* Define to 1 if you have the `gettimeofday' function. */
+#define HAVE_GETTIMEOFDAY 1
+
+/* Define to 1 if you have the <ifaddr.h> header file. */
+/* #undef HAVE_IFADDR_H */
+
+/* Define to 1 if you have SIOCGIFCONF */
+#define HAVE_IFCONF 1
+
+/* Define to 1 if you have SIOCGIFNUM ioctl */
+/* #undef HAVE_IFNUM */
+
+/* Define to 1 if you have ifr_ifindex in <net/if.h> */
+/* #undef HAVE_IFR_IFINDEX */
+
+/* Define to 1 if you have ifr_index in <net/if.h> */
+#define HAVE_IFR_INDEX 1
+
+/* Define to 1 if you have the `if_nameindex' function. */
+#define HAVE_IF_NAMEINDEX 1
+
+/* Define to 1 if you have the `inet_ntop' function. */
+#define HAVE_INET_NTOP 1
+
+/* Define to 1 if you have the `inet_pton' function. */
+#define HAVE_INET_PTON 1
+
+/* Define to 1 if you have the `initstate' function. */
+#define HAVE_INITSTATE 1
+
+/* Define to 1 if you have inlining compiler */
+#define HAVE_INLINE 1
+
+/* Define to 1 if you have WIN32 INTERFACE_INFO_EX type. */
+/* #undef HAVE_INTERFACE_INFO_EX */
+
+/* Define to 1 if you have the <inttypes.h> header file. */
+#define HAVE_INTTYPES_H 1
+
+/* Define to 1 if you have the <iphlpapi.h> header file. */
+/* #undef HAVE_IPHLPAPI_H */
+
+/* Define to 1 if you have IPV6_RECVERR in <netinet/in6.h> */
+/* #undef HAVE_IPV6_RECVERR */
+
+/* Define to 1 if you have IP_RECVERR in <netinet/in.h> */
+/* #undef HAVE_IP_RECVERR */
+
+/* Define to 1 if you have the `kqueue' function. */
+/* #undef HAVE_KQUEUE 1 */
+
+/* Define to 1 if you use kqueue in su_port. */
+/* #undef HAVE_KQUEUE_PORT 1 */
+
+/* Define to 1 if you have the `crypto' library (-lcrypto). */
+#define HAVE_LIBCRYPTO 1
+
+/* Define to 1 if you have the `pthread' library (-lpthread). */
+#define HAVE_LIBPTHREAD 1
+
+/* Define to 1 if you have the `socket' library (-lsocket). */
+/* #undef HAVE_LIBSOCKET */
+
+/* Define to 1 if you have the `ssl' library (-lssl). */
+#define HAVE_LIBSSL 1
+
+/* Define to 1 if you have the `memccpy' function. */
+#define HAVE_MEMCCPY 1
+
+/* Define to 1 if you have the `memcspn' function. */
+/* #undef HAVE_MEMCSPN */
+
+/* Define to 1 if you have the `memmem' function. */
+/* #undef HAVE_MEMMEM */
+
+/* Define to 1 if you have the <memory.h> header file. */
+#define HAVE_MEMORY_H 1
+
+/* Define to 1 if you have the `memspn' function. */
+/* #undef HAVE_MEMSPN */
+
+/* Define to 1 if you are compiling in MinGW environment */
+/* #undef HAVE_MINGW */
+
+/* Define to 1 if you have MSG_TRUNC flag */
+#define HAVE_MSG_TRUNC 1
+
+/* Define to 1 if you have the <netdb.h> header file. */
+#define HAVE_NETDB_H 1
+
+/* Define to 1 if you have the <netinet/in.h> header file. */
+#define HAVE_NETINET_IN_H 1
+
+/* Define to 1 if you have the <netinet/sctp.h> header file. */
+/* #undef HAVE_NETINET_SCTP_H */
+
+/* Define to 1 if you have the <netinet/tcp.h> header file. */
+/* #undef HAVE_NETINET_TCP_H */
+
+/* Define to 1 if you have the <netpacket/packet.h> header file. */
+/* #undef HAVE_NETPACKET_PACKET_H */
+
+/* Define to 1 if you have the <net/if.h> header file. */
+#define HAVE_NET_IF_H 1
+
+/* Define to 1 if you have the <net/if_types.h> header file. */
+/* #undef HAVE_NET_IF_TYPES_H 1 */
+
+/* Define to 1 if you have OpenSSL */
+#define HAVE_OPENSSL 1
+
+/* Define to 1 if you have the <openssl/tls1.h> header file. */
+#define HAVE_OPENSSL_TLS1_H 1
+
+/* Define to 1 if you have the `poll' function. */
+/* #undef HAVE_POLL 1 */
+
+/* Define to 1 if you use poll in su_port. */
+#define HAVE_POLL_PORT 1
+
+/* Define to 1 if you have /proc/net/if_inet6 control file */
+/* #undef HAVE_PROC_NET_IF_INET6 */
+
+/* Define to 1 if you have working pthread_rwlock_t implementation. A thread
+   may hold multiple concurrent read locks on rwlock - that is, successfully
+   call the pthread_rwlock_rdlock() function n times. If so, the application
+   shall ensure that the thread performs matching unlocks - that is, it calls
+   the pthread_rwlock_unlock() function n times. */
+#define HAVE_PTHREAD_RWLOCK 1
+
+/* Define to 1 if you have the `random' function. */
+#define HAVE_RANDOM 1
+
+/* Define to 1 if you have sa_len in struct sockaddr */
+/* #undef HAVE_SA_LEN */
+
+/* Define to 1 if you have SCTP */
+/* #undef HAVE_SCTP */
+
+/* Define to 1 if you have the `select' function. */
+#define HAVE_SELECT 1
+
+/* Define to 1 if you have Sofia sigcomp >= 2.5 */
+/* #undef HAVE_SIGCOMP */
+
+/* Define to 1 if you have the <sigcomp.h> header file. */
+/* #undef HAVE_SIGCOMP_H */
+
+/* Define to 1 if you have the `signal' function. */
+/* #undef HAVE_SIGNAL */
+
+/* Define to 1 if you have SIGPIPE */
+/* #undef HAVE_SIGPIPE */
+
+/* Define to 1 if you have IPv6 structures and constants */
+/* #undef HAVE_SIN6 */
+
+/* Define to 1 if you have WIN32 WSAIoctl SIO_ADDRESS_LIST_QUERY. */
+/* #undef HAVE_SIO_ADDRESS_LIST_QUERY */
+
+/* Define to 1 if you have the `socketpair' function. */
+/* #undef HAVE_SOCKETPAIR */
+
+/* Define to 1 if we use NTH library */
+/* #undef HAVE_SOFIA_NTH */
+
+/* Define to 1 if we use NTLM library */
+/* #undef HAVE_SOFIA_NTLM */
+
+/* Define to 1 if you have Sofia sigcomp >= 2.5 */
+/* #undef HAVE_SOFIA_SIGCOMP */
+
+/* Define to 1 always */
+#define HAVE_SOFIA_SIP 1
+
+/* Define to 1 if we use S/MIME library */
+#define HAVE_SOFIA_SMIME 0
+
+/* Define to 1 if we use DNS library */
+#define HAVE_SOFIA_SRESOLV 1
+
+/* Define to 1 if we use STUN library */
+#define HAVE_SOFIA_STUN 1
+
+/* Define to 1 if we use SRTP */
+#define HAVE_SRTP 0
+
+/* Define to 1 if you have the <stdint.h> header file. */
+#define HAVE_STDINT_H 1
+
+/* Define to 1 if you have the <stdlib.h> header file. */
+#define HAVE_STDLIB_H 1
+
+/* Define to 1 if you have the `strcasestr' function. */
+#define HAVE_STRCASESTR 1
+
+/* Define to 1 if you have the `strerror' function. */
+#define HAVE_STRERROR 1
+
+/* Define to 1 if you have the <strings.h> header file. */
+#define HAVE_STRINGS_H 1
+
+/* Define to 1 if you have the <string.h> header file. */
+#define HAVE_STRING_H 1
+
+/* Define to 1 if you have the `strtoull' function. */
+/* #undef HAVE_STRTOULL */
+
+/* Define to 1 if your CC supports C99 struct initialization */
+#define HAVE_STRUCT_KEYWORDS 1
+
+/* Define to 1 if you have the <sys/epoll.h> header file. */
+/* #undef HAVE_SYS_EPOLL_H */
+
+/* Define to 1 if you have the <sys/event.h> header file. */
+#define HAVE_SYS_EVENT_H 1
+
+/* Define to 1 if you have the <sys/filio.h> header file. */
+/* #undef HAVE_SYS_FILIO_H */
+
+/* Define to 1 if you have the <sys/ioctl.h> header file. */
+#define HAVE_SYS_IOCTL_H 1
+
+/* Define to 1 if you have the <sys/select.h> header file. */
+#define HAVE_SYS_SELECT_H 1
+
+/* Define to 1 if you have the <sys/socket.h> header file. */
+#define HAVE_SYS_SOCKET_H 1
+
+/* Define to 1 if you have the <sys/sockio.h> header file. */
+#define HAVE_SYS_SOCKIO_H 1
+
+/* Define to 1 if you have the <sys/stat.h> header file. */
+#define HAVE_SYS_STAT_H 1
+
+/* Define to 1 if you have the <sys/time.h> header file. */
+#define HAVE_SYS_TIME_H 1
+
+/* Define to 1 if you have the <sys/types.h> header file. */
+#define HAVE_SYS_TYPES_H 1
+
+/* Define to 1 if you have the `tcsetattr' function. */
+#define HAVE_TCSETATTR 1
+
+/* Define to 1 if you have TLS */
+/* #undef HAVE_TLS */
+
+/* Define to 1 if you have the <unistd.h> header file. */
+#define HAVE_UNISTD_H 1
+
+/* Define to 1 if we use UPnP */
+#define HAVE_UPNP 0
+
+/* Define to 1 you have WIN32 */
+/* #undef HAVE_WIN32 */
+
+/* Define to 1 if you have the <windef.h> header file. */
+/* #undef HAVE_WINDEF_H */
+
+/* Define to 1 if you have the <winsock2.h> header file. */
+/* #undef HAVE_WINSOCK2_H */
+
+/* Define to 1 if you have the <ws2tcpip.h> header file. */
+/* #undef HAVE_WS2TCPIP_H */
+
+/* Define to format (%lli) for long long */
+#define LLI "%lli"
+
+/* Define to format (%llu) for unsigned long long */
+#define LLU "%llu"
+
+/* Define to format (%llx) for long long hex */
+#define LLX "%llx"
+
+/* Define printf() modifier for ssize_t */
+#define MOD_ZD "%zd"
+
+/* Define printf() modifier for size_t */
+#define MOD_ZU "%zu"
+
+/* Name of package */
+#define PACKAGE "sofia-sip"
+
+/* Define to the address where bug reports for this package should be sent. */
+#define PACKAGE_BUGREPORT ""
+
+/* Define to the full name of this package. */
+#define PACKAGE_NAME "sofia-sip"
+
+/* Define to the full name and version of this package. */
+#define PACKAGE_STRING "sofia-sip 1.12.5work"
+
+/* Define to the one symbol short name of this package. */
+#define PACKAGE_TARNAME "sofia-sip"
+
+/* Define to the version of this package. */
+#define PACKAGE_VERSION "1.12.5work"
+
+/* Define as the return type of signal handlers (`int' or `void'). */
+#define RETSIGTYPE void
+
+/* If using the C implementation of alloca, define if you know the
+   direction of stack growth for your system; otherwise it will be
+   automatically deduced at run-time.
+	STACK_DIRECTION > 0 => grows toward higher addresses
+	STACK_DIRECTION < 0 => grows toward lower addresses
+	STACK_DIRECTION = 0 => direction of growth unknown */
+/* #undef STACK_DIRECTION */
+
+/* Define to 1 if you have the ANSI C header files. */
+#define STDC_HEADERS 1
+
+/* Define to 1 if you can safely include both <sys/time.h> and <time.h>. */
+#define TIME_WITH_SYS_TIME 1
+
+/* Version number of package */
+#define VERSION "1.12.5work"
+
+/* Define to 1 if your processor stores words with the most significant byte
+   first (like Motorola and SPARC, unlike Intel and VAX). */
+/* #undef WORDS_BIGENDIAN */
+
+/* Enable GNU extensions on systems that have them.  */
+#ifndef _GNU_SOURCE
+# define _GNU_SOURCE 1
+#endif
+
+/* Define to empty if `const' does not conform to ANSI C. */
+/* #undef const */
+
+/* Define to `__inline__' or `__inline' if that's what the C compiler
+   calls it, or to nothing if 'inline' is not supported under any name.  */
+#ifndef __cplusplus
+/* #undef inline */
+#endif
+
+/* Define to a at least 64-bit int type */
+#define longlong long long
+
+/* Define to `unsigned' if <sys/types.h> does not define. */
+/* #undef size_t */
+
+/* Define to 1 if compiling on Open C environment */
+#define HAVE_OPEN_C 1
diff -ur a/open_c/config.h.in b/open_c/config.h.in
--- a/open_c/config.h.in	2011-03-11 16:49:19.000000000 +0200
+++ b/open_c/config.h.in	2017-12-07 23:26:01.992851598 +0200
@@ -1,438 +1,438 @@
-/* config.h.in.  Template for Open C  */
-
-/* Define to 1 if using `alloca.c'. */
-/* #undef C_ALLOCA */
-
-/* Define to the random number source name. */
-/* #undef DEV_URANDOM */
-
-/* Define to 1 if you have addrinfo structure. */
-#define HAVE_ADDRINFO 1
-
-/* Define to 1 if you have the `alarm' function. */
-/* #undef HAVE_ALARM */
-
-/* Define to 1 if you have `alloca', as a function or macro. */
-/* #undef HAVE_ALLOCA */
-
-/* Define to 1 if you have <alloca.h> and it should be used (not on Ultrix).
-   */
-/* #undef HAVE_ALLOCA_H 1 */
-
-/* Define to 1 if you have the <arpa/inet.h> header file. */
-#define HAVE_ARPA_INET_H 1
-
-/* Define to 1 if you have the `clock_getcpuclockid' function. */
-/* #undef HAVE_CLOCK_GETCPUCLOCKID */
-
-/* Define to 1 if you have the `clock_gettime' function. */
-/* #undef HAVE_CLOCK_GETTIME */
-
-/* Define to 1 if you have /dev/urandom. */
-/* #undef HAVE_DEV_URANDOM */
-
-/* Define to 1 if you have the <dirent.h> header file. */
-#define HAVE_DIRENT_H 1
-
-/* Define to 1 if you have the <dlfcn.h> header file. */
-#define HAVE_DLFCN_H 1
-
-/* Define to 1 if you have epoll interface. */
-/* #undef HAVE_EPOLL */
-
-/* Define to 1 if you have the `epoll_create' function. */
-/* #undef HAVE_EPOLL_CREATE */
-
-/* Define to 1 if you have the <fcntl.h> header file. */
-#define HAVE_FCNTL_H 1
-
-/* Define to 1 if you have WIN32 FILETIME type and GetSystemTimeAsFileTime().
-   */
-/* #undef HAVE_FILETIME */
-
-/* Define to 1 if you have the `flock' function. */
-/* #undef HAVE_FLOCK */
-
-/* Define to 1 if you have the `freeaddrinfo' function. */
-#define HAVE_FREEADDRINFO 1
-
-/* Define to 1 if the C compiler supports __func__ */
-#define HAVE_FUNC 1
-
-/* Define to 1 if the C compiler supports __FUNCTION__ */
-#define HAVE_FUNCTION 1
-
-/* Define to 1 if you have the `gai_strerror' function. */
-#define HAVE_GAI_STRERROR 1
-
-/* Define to 1 if you have the `getaddrinfo' function. */
-#define HAVE_GETADDRINFO 1
-
-/* Define to 1 if you have the `getdelim' function. */
-/* #undef HAVE_GETDELIM */
-
-/* Define to 1 if you have the `gethostbyname' function. */
-#define HAVE_GETHOSTBYNAME 1
-
-/* Define to 1 if you have the `gethostname' function. */
-#define HAVE_GETHOSTNAME 1
-
-/* Define to 1 if you have the `getifaddrs' function. */
-/* #undef HAVE_GETIFADDRS 1 */
-
-/* Define to 1 if you have the `getipnodebyname' function. */
-#define HAVE_GETIPNODEBYNAME 1
-
-/* Define to 1 if you have the `getline' function. */
-/* #undef HAVE_GETLINE */
-
-/* Define to 1 if you have the `getnameinfo' function. */
-#define HAVE_GETNAMEINFO 1
-
-/* Define to 1 if you have the `getpass' function. */
-#define HAVE_GETPASS 1
-
-/* Define to 1 if you have the `gettimeofday' function. */
-#define HAVE_GETTIMEOFDAY 1
-
-/* Define to 1 if you have the <ifaddr.h> header file. */
-/* #undef HAVE_IFADDR_H */
-
-/* Define to 1 if you have SIOCGIFCONF */
-#define HAVE_IFCONF 1
-
-/* Define to 1 if you have SIOCGIFNUM ioctl */
-/* #undef HAVE_IFNUM */
-
-/* Define to 1 if you have ifr_ifindex in <net/if.h> */
-/* #undef HAVE_IFR_IFINDEX */
-
-/* Define to 1 if you have ifr_index in <net/if.h> */
-#define HAVE_IFR_INDEX 1
-
-/* Define to 1 if you have the `if_nameindex' function. */
-#define HAVE_IF_NAMEINDEX 1
-
-/* Define to 1 if you have the `inet_ntop' function. */
-#define HAVE_INET_NTOP 1
-
-/* Define to 1 if you have the `inet_pton' function. */
-#define HAVE_INET_PTON 1
-
-/* Define to 1 if you have the `initstate' function. */
-#define HAVE_INITSTATE 1
-
-/* Define to 1 if you have inlining compiler */
-#define HAVE_INLINE 1
-
-/* Define to 1 if you have WIN32 INTERFACE_INFO_EX type. */
-/* #undef HAVE_INTERFACE_INFO_EX */
-
-/* Define to 1 if you have the <inttypes.h> header file. */
-#define HAVE_INTTYPES_H 1
-
-/* Define to 1 if you have the <iphlpapi.h> header file. */
-/* #undef HAVE_IPHLPAPI_H */
-
-/* Define to 1 if you have IPV6_RECVERR in <netinet/in6.h> */
-/* #undef HAVE_IPV6_RECVERR */
-
-/* Define to 1 if you have IP_RECVERR in <netinet/in.h> */
-/* #undef HAVE_IP_RECVERR */
-
-/* Define to 1 if you have the `kqueue' function. */
-/* #undef HAVE_KQUEUE 1 */
-
-/* Define to 1 if you use kqueue in su_port. */
-/* #undef HAVE_KQUEUE_PORT 1 */
-
-/* Define to 1 if you have the `crypto' library (-lcrypto). */
-#define HAVE_LIBCRYPTO 1
-
-/* Define to 1 if you have the `pthread' library (-lpthread). */
-#define HAVE_LIBPTHREAD 1
-
-/* Define to 1 if you have the `socket' library (-lsocket). */
-/* #undef HAVE_LIBSOCKET */
-
-/* Define to 1 if you have the `ssl' library (-lssl). */
-#define HAVE_LIBSSL 1
-
-/* Define to 1 if you have the `memccpy' function. */
-#define HAVE_MEMCCPY 1
-
-/* Define to 1 if you have the `memcspn' function. */
-/* #undef HAVE_MEMCSPN */
-
-/* Define to 1 if you have the `memmem' function. */
-/* #undef HAVE_MEMMEM */
-
-/* Define to 1 if you have the <memory.h> header file. */
-#define HAVE_MEMORY_H 1
-
-/* Define to 1 if you have the `memspn' function. */
-/* #undef HAVE_MEMSPN */
-
-/* Define to 1 if you are compiling in MinGW environment */
-/* #undef HAVE_MINGW */
-
-/* Define to 1 if you have MSG_TRUNC flag */
-#define HAVE_MSG_TRUNC 1
-
-/* Define to 1 if you have the <netdb.h> header file. */
-#define HAVE_NETDB_H 1
-
-/* Define to 1 if you have the <netinet/in.h> header file. */
-#define HAVE_NETINET_IN_H 1
-
-/* Define to 1 if you have the <netinet/sctp.h> header file. */
-/* #undef HAVE_NETINET_SCTP_H */
-
-/* Define to 1 if you have the <netinet/tcp.h> header file. */
-/* #undef HAVE_NETINET_TCP_H */
-
-/* Define to 1 if you have the <netpacket/packet.h> header file. */
-/* #undef HAVE_NETPACKET_PACKET_H */
-
-/* Define to 1 if you have the <net/if.h> header file. */
-#define HAVE_NET_IF_H 1
-
-/* Define to 1 if you have the <net/if_types.h> header file. */
-/* #undef HAVE_NET_IF_TYPES_H 1 */
-
-/* Define to 1 if you have OpenSSL */
-#define HAVE_OPENSSL 1
-
-/* Define to 1 if you have the <openssl/tls1.h> header file. */
-#define HAVE_OPENSSL_TLS1_H 1
-
-/* Define to 1 if you have the `poll' function. */
-/* #undef HAVE_POLL 1 */
-
-/* Define to 1 if you use poll in su_port. */
-#define HAVE_POLL_PORT 1
-
-/* Define to 1 if you have /proc/net/if_inet6 control file */
-/* #undef HAVE_PROC_NET_IF_INET6 */
-
-/* Define to 1 if you have working pthread_rwlock_t implementation. A thread
-   may hold multiple concurrent read locks on rwlock - that is, successfully
-   call the pthread_rwlock_rdlock() function n times. If so, the application
-   shall ensure that the thread performs matching unlocks - that is, it calls
-   the pthread_rwlock_unlock() function n times. */
-#define HAVE_PTHREAD_RWLOCK 1
-
-/* Define to 1 if you have the `random' function. */
-#define HAVE_RANDOM 1
-
-/* Define to 1 if you have sa_len in struct sockaddr */
-/* #undef HAVE_SA_LEN */
-
-/* Define to 1 if you have SCTP */
-/* #undef HAVE_SCTP */
-
-/* Define to 1 if you have the `select' function. */
-#define HAVE_SELECT 1
-
-/* Define to 1 if you have Sofia sigcomp >= 2.5 */
-/* #undef HAVE_SIGCOMP */
-
-/* Define to 1 if you have the <sigcomp.h> header file. */
-/* #undef HAVE_SIGCOMP_H */
-
-/* Define to 1 if you have the `signal' function. */
-/* #undef HAVE_SIGNAL */
-
-/* Define to 1 if you have SIGPIPE */
-/* #undef HAVE_SIGPIPE */
-
-/* Define to 1 if you have IPv6 structures and constants */
-/* #undef HAVE_SIN6 */
-
-/* Define to 1 if you have WIN32 WSAIoctl SIO_ADDRESS_LIST_QUERY. */
-/* #undef HAVE_SIO_ADDRESS_LIST_QUERY */
-
-/* Define to 1 if you have the `socketpair' function. */
-/* #undef HAVE_SOCKETPAIR */
-
-/* Define to 1 if we use NTH library */
-/* #undef HAVE_SOFIA_NTH */
-
-/* Define to 1 if we use NTLM library */
-/* #undef HAVE_SOFIA_NTLM */
-
-/* Define to 1 if you have Sofia sigcomp >= 2.5 */
-/* #undef HAVE_SOFIA_SIGCOMP */
-
-/* Define to 1 always */
-#define HAVE_SOFIA_SIP 1
-
-/* Define to 1 if we use S/MIME library */
-#define HAVE_SOFIA_SMIME 0
-
-/* Define to 1 if we use DNS library */
-#define HAVE_SOFIA_SRESOLV 1
-
-/* Define to 1 if we use STUN library */
-#define HAVE_SOFIA_STUN 1
-
-/* Define to 1 if we use SRTP */
-#define HAVE_SRTP 0
-
-/* Define to 1 if you have the <stdint.h> header file. */
-#define HAVE_STDINT_H 1
-
-/* Define to 1 if you have the <stdlib.h> header file. */
-#define HAVE_STDLIB_H 1
-
-/* Define to 1 if you have the `strcasestr' function. */
-#define HAVE_STRCASESTR 1
-
-/* Define to 1 if you have the `strerror' function. */
-#define HAVE_STRERROR 1
-
-/* Define to 1 if you have the <strings.h> header file. */
-#define HAVE_STRINGS_H 1
-
-/* Define to 1 if you have the <string.h> header file. */
-#define HAVE_STRING_H 1
-
-/* Define to 1 if you have the `strtoull' function. */
-/* #undef HAVE_STRTOULL */
-
-/* Define to 1 if your CC supports C99 struct initialization */
-#define HAVE_STRUCT_KEYWORDS 1
-
-/* Define to 1 if you have the <sys/epoll.h> header file. */
-/* #undef HAVE_SYS_EPOLL_H */
-
-/* Define to 1 if you have the <sys/event.h> header file. */
-#define HAVE_SYS_EVENT_H 1
-
-/* Define to 1 if you have the <sys/filio.h> header file. */
-/* #undef HAVE_SYS_FILIO_H */
-
-/* Define to 1 if you have the <sys/ioctl.h> header file. */
-#define HAVE_SYS_IOCTL_H 1
-
-/* Define to 1 if you have the <sys/select.h> header file. */
-#define HAVE_SYS_SELECT_H 1
-
-/* Define to 1 if you have the <sys/socket.h> header file. */
-#define HAVE_SYS_SOCKET_H 1
-
-/* Define to 1 if you have the <sys/sockio.h> header file. */
-#define HAVE_SYS_SOCKIO_H 1
-
-/* Define to 1 if you have the <sys/stat.h> header file. */
-#define HAVE_SYS_STAT_H 1
-
-/* Define to 1 if you have the <sys/time.h> header file. */
-#define HAVE_SYS_TIME_H 1
-
-/* Define to 1 if you have the <sys/types.h> header file. */
-#define HAVE_SYS_TYPES_H 1
-
-/* Define to 1 if you have the `tcsetattr' function. */
-#define HAVE_TCSETATTR 1
-
-/* Define to 1 if you have TLS */
-/* #undef HAVE_TLS */
-
-/* Define to 1 if you have the <unistd.h> header file. */
-#define HAVE_UNISTD_H 1
-
-/* Define to 1 if we use UPnP */
-#define HAVE_UPNP 0
-
-/* Define to 1 you have WIN32 */
-/* #undef HAVE_WIN32 */
-
-/* Define to 1 if you have the <windef.h> header file. */
-/* #undef HAVE_WINDEF_H */
-
-/* Define to 1 if you have the <winsock2.h> header file. */
-/* #undef HAVE_WINSOCK2_H */
-
-/* Define to 1 if you have the <ws2tcpip.h> header file. */
-/* #undef HAVE_WS2TCPIP_H */
-
-/* Define to format (%lli) for long long */
-#define LLI "%lli"
-
-/* Define to format (%llu) for unsigned long long */
-#define LLU "%llu"
-
-/* Define to format (%llx) for long long hex */
-#define LLX "%llx"
-
-/* Define printf() modifier for ssize_t */
-#define MOD_ZD "%zd"
-
-/* Define printf() modifier for size_t */
-#define MOD_ZU "%zu"
-
-/* Name of package */
-#define PACKAGE "sofia-sip"
-
-/* Define to the address where bug reports for this package should be sent. */
-#define PACKAGE_BUGREPORT ""
-
-/* Define to the full name of this package. */
-#define PACKAGE_NAME "sofia-sip"
-
-/* Define to the full name and version of this package. */
-#define PACKAGE_STRING "sofia-sip 1.12.5work"
-
-/* Define to the one symbol short name of this package. */
-#define PACKAGE_TARNAME "sofia-sip"
-
-/* Define to the version of this package. */
-#define PACKAGE_VERSION "1.12.5work"
-
-/* Define as the return type of signal handlers (`int' or `void'). */
-#define RETSIGTYPE void
-
-/* If using the C implementation of alloca, define if you know the
-   direction of stack growth for your system; otherwise it will be
-   automatically deduced at run-time.
-	STACK_DIRECTION > 0 => grows toward higher addresses
-	STACK_DIRECTION < 0 => grows toward lower addresses
-	STACK_DIRECTION = 0 => direction of growth unknown */
-/* #undef STACK_DIRECTION */
-
-/* Define to 1 if you have the ANSI C header files. */
-#define STDC_HEADERS 1
-
-/* Define to 1 if you can safely include both <sys/time.h> and <time.h>. */
-#define TIME_WITH_SYS_TIME 1
-
-/* Version number of package */
-#define VERSION "1.12.5work"
-
-/* Define to 1 if your processor stores words with the most significant byte
-   first (like Motorola and SPARC, unlike Intel and VAX). */
-/* #undef WORDS_BIGENDIAN */
-
-/* Enable GNU extensions on systems that have them.  */
-#ifndef _GNU_SOURCE
-# define _GNU_SOURCE 1
-#endif
-
-/* Define to empty if `const' does not conform to ANSI C. */
-/* #undef const */
-
-/* Define to `__inline__' or `__inline' if that's what the C compiler
-   calls it, or to nothing if 'inline' is not supported under any name.  */
-#ifndef __cplusplus
-/* #undef inline */
-#endif
-
-/* Define to a at least 64-bit int type */
-#define longlong long long
-
-/* Define to `unsigned' if <sys/types.h> does not define. */
-/* #undef size_t */
-
-/* Define to 1 if compiling on Open C environment */
-#define HAVE_OPEN_C 1
+/* config.h.in.  Template for Open C  */
+
+/* Define to 1 if using `alloca.c'. */
+/* #undef C_ALLOCA */
+
+/* Define to the random number source name. */
+/* #undef DEV_URANDOM */
+
+/* Define to 1 if you have addrinfo structure. */
+#define HAVE_ADDRINFO 1
+
+/* Define to 1 if you have the `alarm' function. */
+/* #undef HAVE_ALARM */
+
+/* Define to 1 if you have `alloca', as a function or macro. */
+/* #undef HAVE_ALLOCA */
+
+/* Define to 1 if you have <alloca.h> and it should be used (not on Ultrix).
+   */
+/* #undef HAVE_ALLOCA_H 1 */
+
+/* Define to 1 if you have the <arpa/inet.h> header file. */
+#define HAVE_ARPA_INET_H 1
+
+/* Define to 1 if you have the `clock_getcpuclockid' function. */
+/* #undef HAVE_CLOCK_GETCPUCLOCKID */
+
+/* Define to 1 if you have the `clock_gettime' function. */
+/* #undef HAVE_CLOCK_GETTIME */
+
+/* Define to 1 if you have /dev/urandom. */
+/* #undef HAVE_DEV_URANDOM */
+
+/* Define to 1 if you have the <dirent.h> header file. */
+#define HAVE_DIRENT_H 1
+
+/* Define to 1 if you have the <dlfcn.h> header file. */
+#define HAVE_DLFCN_H 1
+
+/* Define to 1 if you have epoll interface. */
+/* #undef HAVE_EPOLL */
+
+/* Define to 1 if you have the `epoll_create' function. */
+/* #undef HAVE_EPOLL_CREATE */
+
+/* Define to 1 if you have the <fcntl.h> header file. */
+#define HAVE_FCNTL_H 1
+
+/* Define to 1 if you have WIN32 FILETIME type and GetSystemTimeAsFileTime().
+   */
+/* #undef HAVE_FILETIME */
+
+/* Define to 1 if you have the `flock' function. */
+/* #undef HAVE_FLOCK */
+
+/* Define to 1 if you have the `freeaddrinfo' function. */
+#define HAVE_FREEADDRINFO 1
+
+/* Define to 1 if the C compiler supports __func__ */
+#define HAVE_FUNC 1
+
+/* Define to 1 if the C compiler supports __FUNCTION__ */
+#define HAVE_FUNCTION 1
+
+/* Define to 1 if you have the `gai_strerror' function. */
+#define HAVE_GAI_STRERROR 1
+
+/* Define to 1 if you have the `getaddrinfo' function. */
+#define HAVE_GETADDRINFO 1
+
+/* Define to 1 if you have the `getdelim' function. */
+/* #undef HAVE_GETDELIM */
+
+/* Define to 1 if you have the `gethostbyname' function. */
+#define HAVE_GETHOSTBYNAME 1
+
+/* Define to 1 if you have the `gethostname' function. */
+#define HAVE_GETHOSTNAME 1
+
+/* Define to 1 if you have the `getifaddrs' function. */
+/* #undef HAVE_GETIFADDRS 1 */
+
+/* Define to 1 if you have the `getipnodebyname' function. */
+#define HAVE_GETIPNODEBYNAME 1
+
+/* Define to 1 if you have the `getline' function. */
+/* #undef HAVE_GETLINE */
+
+/* Define to 1 if you have the `getnameinfo' function. */
+#define HAVE_GETNAMEINFO 1
+
+/* Define to 1 if you have the `getpass' function. */
+#define HAVE_GETPASS 1
+
+/* Define to 1 if you have the `gettimeofday' function. */
+#define HAVE_GETTIMEOFDAY 1
+
+/* Define to 1 if you have the <ifaddr.h> header file. */
+/* #undef HAVE_IFADDR_H */
+
+/* Define to 1 if you have SIOCGIFCONF */
+#define HAVE_IFCONF 1
+
+/* Define to 1 if you have SIOCGIFNUM ioctl */
+/* #undef HAVE_IFNUM */
+
+/* Define to 1 if you have ifr_ifindex in <net/if.h> */
+/* #undef HAVE_IFR_IFINDEX */
+
+/* Define to 1 if you have ifr_index in <net/if.h> */
+#define HAVE_IFR_INDEX 1
+
+/* Define to 1 if you have the `if_nameindex' function. */
+#define HAVE_IF_NAMEINDEX 1
+
+/* Define to 1 if you have the `inet_ntop' function. */
+#define HAVE_INET_NTOP 1
+
+/* Define to 1 if you have the `inet_pton' function. */
+#define HAVE_INET_PTON 1
+
+/* Define to 1 if you have the `initstate' function. */
+#define HAVE_INITSTATE 1
+
+/* Define to 1 if you have inlining compiler */
+#define HAVE_INLINE 1
+
+/* Define to 1 if you have WIN32 INTERFACE_INFO_EX type. */
+/* #undef HAVE_INTERFACE_INFO_EX */
+
+/* Define to 1 if you have the <inttypes.h> header file. */
+#define HAVE_INTTYPES_H 1
+
+/* Define to 1 if you have the <iphlpapi.h> header file. */
+/* #undef HAVE_IPHLPAPI_H */
+
+/* Define to 1 if you have IPV6_RECVERR in <netinet/in6.h> */
+/* #undef HAVE_IPV6_RECVERR */
+
+/* Define to 1 if you have IP_RECVERR in <netinet/in.h> */
+/* #undef HAVE_IP_RECVERR */
+
+/* Define to 1 if you have the `kqueue' function. */
+/* #undef HAVE_KQUEUE 1 */
+
+/* Define to 1 if you use kqueue in su_port. */
+/* #undef HAVE_KQUEUE_PORT 1 */
+
+/* Define to 1 if you have the `crypto' library (-lcrypto). */
+#define HAVE_LIBCRYPTO 1
+
+/* Define to 1 if you have the `pthread' library (-lpthread). */
+#define HAVE_LIBPTHREAD 1
+
+/* Define to 1 if you have the `socket' library (-lsocket). */
+/* #undef HAVE_LIBSOCKET */
+
+/* Define to 1 if you have the `ssl' library (-lssl). */
+#define HAVE_LIBSSL 1
+
+/* Define to 1 if you have the `memccpy' function. */
+#define HAVE_MEMCCPY 1
+
+/* Define to 1 if you have the `memcspn' function. */
+/* #undef HAVE_MEMCSPN */
+
+/* Define to 1 if you have the `memmem' function. */
+/* #undef HAVE_MEMMEM */
+
+/* Define to 1 if you have the <memory.h> header file. */
+#define HAVE_MEMORY_H 1
+
+/* Define to 1 if you have the `memspn' function. */
+/* #undef HAVE_MEMSPN */
+
+/* Define to 1 if you are compiling in MinGW environment */
+/* #undef HAVE_MINGW */
+
+/* Define to 1 if you have MSG_TRUNC flag */
+#define HAVE_MSG_TRUNC 1
+
+/* Define to 1 if you have the <netdb.h> header file. */
+#define HAVE_NETDB_H 1
+
+/* Define to 1 if you have the <netinet/in.h> header file. */
+#define HAVE_NETINET_IN_H 1
+
+/* Define to 1 if you have the <netinet/sctp.h> header file. */
+/* #undef HAVE_NETINET_SCTP_H */
+
+/* Define to 1 if you have the <netinet/tcp.h> header file. */
+/* #undef HAVE_NETINET_TCP_H */
+
+/* Define to 1 if you have the <netpacket/packet.h> header file. */
+/* #undef HAVE_NETPACKET_PACKET_H */
+
+/* Define to 1 if you have the <net/if.h> header file. */
+#define HAVE_NET_IF_H 1
+
+/* Define to 1 if you have the <net/if_types.h> header file. */
+/* #undef HAVE_NET_IF_TYPES_H 1 */
+
+/* Define to 1 if you have OpenSSL */
+#define HAVE_OPENSSL 1
+
+/* Define to 1 if you have the <openssl/tls1.h> header file. */
+#define HAVE_OPENSSL_TLS1_H 1
+
+/* Define to 1 if you have the `poll' function. */
+/* #undef HAVE_POLL 1 */
+
+/* Define to 1 if you use poll in su_port. */
+#define HAVE_POLL_PORT 1
+
+/* Define to 1 if you have /proc/net/if_inet6 control file */
+/* #undef HAVE_PROC_NET_IF_INET6 */
+
+/* Define to 1 if you have working pthread_rwlock_t implementation. A thread
+   may hold multiple concurrent read locks on rwlock - that is, successfully
+   call the pthread_rwlock_rdlock() function n times. If so, the application
+   shall ensure that the thread performs matching unlocks - that is, it calls
+   the pthread_rwlock_unlock() function n times. */
+#define HAVE_PTHREAD_RWLOCK 1
+
+/* Define to 1 if you have the `random' function. */
+#define HAVE_RANDOM 1
+
+/* Define to 1 if you have sa_len in struct sockaddr */
+/* #undef HAVE_SA_LEN */
+
+/* Define to 1 if you have SCTP */
+/* #undef HAVE_SCTP */
+
+/* Define to 1 if you have the `select' function. */
+#define HAVE_SELECT 1
+
+/* Define to 1 if you have Sofia sigcomp >= 2.5 */
+/* #undef HAVE_SIGCOMP */
+
+/* Define to 1 if you have the <sigcomp.h> header file. */
+/* #undef HAVE_SIGCOMP_H */
+
+/* Define to 1 if you have the `signal' function. */
+/* #undef HAVE_SIGNAL */
+
+/* Define to 1 if you have SIGPIPE */
+/* #undef HAVE_SIGPIPE */
+
+/* Define to 1 if you have IPv6 structures and constants */
+/* #undef HAVE_SIN6 */
+
+/* Define to 1 if you have WIN32 WSAIoctl SIO_ADDRESS_LIST_QUERY. */
+/* #undef HAVE_SIO_ADDRESS_LIST_QUERY */
+
+/* Define to 1 if you have the `socketpair' function. */
+/* #undef HAVE_SOCKETPAIR */
+
+/* Define to 1 if we use NTH library */
+/* #undef HAVE_SOFIA_NTH */
+
+/* Define to 1 if we use NTLM library */
+/* #undef HAVE_SOFIA_NTLM */
+
+/* Define to 1 if you have Sofia sigcomp >= 2.5 */
+/* #undef HAVE_SOFIA_SIGCOMP */
+
+/* Define to 1 always */
+#define HAVE_SOFIA_SIP 1
+
+/* Define to 1 if we use S/MIME library */
+#define HAVE_SOFIA_SMIME 0
+
+/* Define to 1 if we use DNS library */
+#define HAVE_SOFIA_SRESOLV 1
+
+/* Define to 1 if we use STUN library */
+#define HAVE_SOFIA_STUN 1
+
+/* Define to 1 if we use SRTP */
+#define HAVE_SRTP 0
+
+/* Define to 1 if you have the <stdint.h> header file. */
+#define HAVE_STDINT_H 1
+
+/* Define to 1 if you have the <stdlib.h> header file. */
+#define HAVE_STDLIB_H 1
+
+/* Define to 1 if you have the `strcasestr' function. */
+#define HAVE_STRCASESTR 1
+
+/* Define to 1 if you have the `strerror' function. */
+#define HAVE_STRERROR 1
+
+/* Define to 1 if you have the <strings.h> header file. */
+#define HAVE_STRINGS_H 1
+
+/* Define to 1 if you have the <string.h> header file. */
+#define HAVE_STRING_H 1
+
+/* Define to 1 if you have the `strtoull' function. */
+/* #undef HAVE_STRTOULL */
+
+/* Define to 1 if your CC supports C99 struct initialization */
+#define HAVE_STRUCT_KEYWORDS 1
+
+/* Define to 1 if you have the <sys/epoll.h> header file. */
+/* #undef HAVE_SYS_EPOLL_H */
+
+/* Define to 1 if you have the <sys/event.h> header file. */
+#define HAVE_SYS_EVENT_H 1
+
+/* Define to 1 if you have the <sys/filio.h> header file. */
+/* #undef HAVE_SYS_FILIO_H */
+
+/* Define to 1 if you have the <sys/ioctl.h> header file. */
+#define HAVE_SYS_IOCTL_H 1
+
+/* Define to 1 if you have the <sys/select.h> header file. */
+#define HAVE_SYS_SELECT_H 1
+
+/* Define to 1 if you have the <sys/socket.h> header file. */
+#define HAVE_SYS_SOCKET_H 1
+
+/* Define to 1 if you have the <sys/sockio.h> header file. */
+#define HAVE_SYS_SOCKIO_H 1
+
+/* Define to 1 if you have the <sys/stat.h> header file. */
+#define HAVE_SYS_STAT_H 1
+
+/* Define to 1 if you have the <sys/time.h> header file. */
+#define HAVE_SYS_TIME_H 1
+
+/* Define to 1 if you have the <sys/types.h> header file. */
+#define HAVE_SYS_TYPES_H 1
+
+/* Define to 1 if you have the `tcsetattr' function. */
+#define HAVE_TCSETATTR 1
+
+/* Define to 1 if you have TLS */
+/* #undef HAVE_TLS */
+
+/* Define to 1 if you have the <unistd.h> header file. */
+#define HAVE_UNISTD_H 1
+
+/* Define to 1 if we use UPnP */
+#define HAVE_UPNP 0
+
+/* Define to 1 you have WIN32 */
+/* #undef HAVE_WIN32 */
+
+/* Define to 1 if you have the <windef.h> header file. */
+/* #undef HAVE_WINDEF_H */
+
+/* Define to 1 if you have the <winsock2.h> header file. */
+/* #undef HAVE_WINSOCK2_H */
+
+/* Define to 1 if you have the <ws2tcpip.h> header file. */
+/* #undef HAVE_WS2TCPIP_H */
+
+/* Define to format (%lli) for long long */
+#define LLI "%lli"
+
+/* Define to format (%llu) for unsigned long long */
+#define LLU "%llu"
+
+/* Define to format (%llx) for long long hex */
+#define LLX "%llx"
+
+/* Define printf() modifier for ssize_t */
+#define MOD_ZD "%zd"
+
+/* Define printf() modifier for size_t */
+#define MOD_ZU "%zu"
+
+/* Name of package */
+#define PACKAGE "sofia-sip"
+
+/* Define to the address where bug reports for this package should be sent. */
+#define PACKAGE_BUGREPORT ""
+
+/* Define to the full name of this package. */
+#define PACKAGE_NAME "sofia-sip"
+
+/* Define to the full name and version of this package. */
+#define PACKAGE_STRING "sofia-sip 1.12.5work"
+
+/* Define to the one symbol short name of this package. */
+#define PACKAGE_TARNAME "sofia-sip"
+
+/* Define to the version of this package. */
+#define PACKAGE_VERSION "1.12.5work"
+
+/* Define as the return type of signal handlers (`int' or `void'). */
+#define RETSIGTYPE void
+
+/* If using the C implementation of alloca, define if you know the
+   direction of stack growth for your system; otherwise it will be
+   automatically deduced at run-time.
+	STACK_DIRECTION > 0 => grows toward higher addresses
+	STACK_DIRECTION < 0 => grows toward lower addresses
+	STACK_DIRECTION = 0 => direction of growth unknown */
+/* #undef STACK_DIRECTION */
+
+/* Define to 1 if you have the ANSI C header files. */
+#define STDC_HEADERS 1
+
+/* Define to 1 if you can safely include both <sys/time.h> and <time.h>. */
+#define TIME_WITH_SYS_TIME 1
+
+/* Version number of package */
+#define VERSION "1.12.5work"
+
+/* Define to 1 if your processor stores words with the most significant byte
+   first (like Motorola and SPARC, unlike Intel and VAX). */
+/* #undef WORDS_BIGENDIAN */
+
+/* Enable GNU extensions on systems that have them.  */
+#ifndef _GNU_SOURCE
+# define _GNU_SOURCE 1
+#endif
+
+/* Define to empty if `const' does not conform to ANSI C. */
+/* #undef const */
+
+/* Define to `__inline__' or `__inline' if that's what the C compiler
+   calls it, or to nothing if 'inline' is not supported under any name.  */
+#ifndef __cplusplus
+/* #undef inline */
+#endif
+
+/* Define to a at least 64-bit int type */
+#define longlong long long
+
+/* Define to `unsigned' if <sys/types.h> does not define. */
+/* #undef size_t */
+
+/* Define to 1 if compiling on Open C environment */
+#define HAVE_OPEN_C 1
diff -ur a/README b/README
--- a/README	2011-03-11 16:49:18.000000000 +0200
+++ b/README	2017-12-07 23:25:58.892834785 +0200
@@ -21,7 +21,7 @@
 is the usual:
 
 sh> sh autogen.sh (if building from darcs)
-sh> ./configure
+sh> ./configure.gnu
 sh> make
 sh> make install
 
@@ -50,6 +50,7 @@
 ----------
 
 Project website:
+- https://github.com/pinfutech/sofia-sip_FreeSWITCH
 - http://sofia-sip.sourceforge.net
 - http://www.sourceforge.net/projects/sofia-sip
 
@@ -63,4 +64,4 @@
 ---------
 
 Sofia-SIP is licensed under terms of the GNU LGPL.
-See the file "COPYING" for more information.
+See the file "COPYING" and "LICENSE" for more information.
diff -ur a/win32/pthread/ChangeLog b/win32/pthread/ChangeLog
--- a/win32/pthread/ChangeLog	2011-03-11 16:49:19.000000000 +0200
+++ b/win32/pthread/ChangeLog	2017-12-07 23:26:02.668855264 +0200
@@ -1,2351 +1,2351 @@
-1999-10-30  Ross Johnson  <rpj@ixobrychus.canberra.edu.au>
-
-	* create.c (pthread_create): Explicitly initialise thread state to
-	default values.
-
-	* cancel.c (pthread_setcancelstate): Check for NULL 'oldstate'
-	for compatibility with Solaris pthreads;
-	(pthread_setcanceltype): ditto:
-	- Erik Hensema <erik.hensema@group2000.nl>
-
-1999-10-23  Ross Johnson  <rpj@ixobrychus.canberra.edu.au>
-
-	* pthread.h (ctime_r): Fix incorrect argument "_tm"
-	- Erik Hensema <erik.hensema@group2000.nl>
-
-1999-10-21  Ross Johnson  <rpj@ixobrychus.canberra.edu.au>
-
-	* pthread.h (_POSIX_THREADS): Only define it if it isn't
-	already defined. Projects may need to define this on
-	the CC command line under Win32 as it doesn't have unistd.h
-	- Aurelio Medina <aureliom@crt.com>
-
-1999-10-17  Ross Johnson  <rpj@ixobrychus.canberra.edu.au>
-
-	* rwlock.c (pthread_rwlock_destroy): Add cast to remove compile
-	warning.
-
-	* condvar.c (pthread_cond_broadcast): Only release semaphores
-	if there are waiting threads.
-
-1999-10-15  Ross Johnson  <rpj@ixobrychus.canberra.edu.au>
-
-	* condvar.c (cond_wait_cleanup): New static cleanup handler for
-	cond_timedwait;
-	(cond_timedwait): pthread_cleanup_push args changed;
-	canceling a thread while it's in pthread_cond_wait
-	will now decrement the waiters count and cleanup if it's the
-	last waiter.
-	- Lorin Hochstein <lmh@xiphos.ca> and 
-	  Peter Slacik <Peter.Slacik@tatramed.sk>;
-	the last waiter will now reset the CV's wasBroadcast flag
-	- Graham Dumpleton <Graham.Dumpleton@ra.pad.otc.telstra.com.au>.
-
-Thu Sep 16 1999  Ross Johnson  <rpj@swan.canberra.edu.au>
-
-	* rwlock.c (pthread_rwlock_destroy): Add serialisation.
-	(_rwlock_check_need_init): Check for detroyed rwlock.
-	* rwlock.c: Check return codes from _rwlock_check_need_init();
-	modify comments; serialise access to rwlock objects during
-	operations; rename rw_mutex to rw_lock.
-	* implement.h: Rename rw_mutex to rw_lock.
-	* mutex.c (pthread_mutex_destroy): Add serialisation.
-	(_mutex_check_need_init): Check for detroyed mutex.
-	* condvar.c (pthread_cond_destroy): Add serialisation.
-	(_cond_check_need_init): Check for detroyed condvar.
-	* mutex.c: Modify comments.
-	* condvar.c: Modify comments.
-
-Sat Sep 10 12:56:13 1999  Ross Johnson  <rpj@swan.canberra.edu.au>
-
-	The following code for POSIX read/write locks was contributed
-	by Aurelio Medina.
-
-	* implement.h (pthread_rwlock_t_): Add.
-	* pthread.h (pthread_rwlock_t): Add.
-	(PTHREAD_RWLOCK_INITIALIZER): Add.
-	Add rwlock function prototypes.
-	* rwlock.c: New module.
-	* pthread.def: Add new rwlock functions.
-	* private.c (_pthread_processInitialize): initialise
-	_pthread_rwlock_test_init_lock critical section.
-	* global.c (_pthread_rwlock_test_init_lock): Add.
-
-	* mutex.c (pthread_mutex_destroy): Don't free mutex memory
-	if mutex is PTHREAD_MUTEX_INITIALIZER and has not been
-	initialised yet.
-
-Wed Sep  8 12:56:13 1999  Ross Johnson  <rpj@swan.canberra.edu.au>
-
-	* mutex.c (pthread_mutex_destroy): Free mutex memory.
-	- Milan Gardian <mg@tatramed.sk>
-
-1999-08-22  Ross Johnson  <rpj@ixobrychus.canberra.edu.au>
-
-	* exit.c (pthread_exit): Fix reference to potentially
-	uninitialised pointer.
-
-1999-08-21  Ross Johnson  <rpj@ixobrychus.canberra.edu.au>
-
-	* private.c (_pthread_threadStart): Apply fix of 1999-08-19
-	this time to C++ and non-trapped C versions. Ommitted to
-	do this the first time through.
-
-1999-08-19  Ross Johnson  <rpj@ixobrychus.canberra.edu.au>
-
-	* private.c (_pthread_threadStart): Return exit status from
-	the application thread startup routine.
-	- Milan Gardian <mg@tatramed.sk>
-
-1999-08-18  Ross Johnson  <rpj@ixobrychus.canberra.edu.au>
-
-	* exit.c (pthread_exit): Put status into pthread_t->exitStatus
-	- John Bossom <john.Bossom@cognos.com>
-	* private.c (_pthread_threadStart): Set pthread->exitStatus
-	on exit of try{} block.
-	- John Bossom <john.Bossom@cognos.com>
-	* sync.c (pthread_join): use pthread_exitStatus value if the
-	thread exit doesn't return a value (for Mingw32 CRTDLL
-	which uses endthread instead of _endthreadex).
-	- John Bossom <john.Bossom@cognos.com>
-
-Tue Aug 17 20:17:58 CDT 1999  Mumit Khan  <khan@xraylith.wisc.edu>
-
-        * create.c (pthread_create): Add CRTDLL suppport.
-        * exit.c (pthread_exit): Likewise.
-        * private.c (_pthread_threadStart): Likewise.
-        (_pthread_threadDestroy): Likewise.
-        * sync.c (pthread_join): Likewise.
-        * tests/join1.c (main): Warn about partial support for CRTDLL.
-
-Tue Aug 17 20:00:08 1999  Mumit Khan  <khan@xraylith.wisc.edu>
-
-        * Makefile.in (LD): Delete entry point.
-        * acconfig.h (STDCALL): Delete unused macro.
-        * configure.in: Remove test for STDCALL.
-        * config.h.in: Regenerate.
-        * errno.c (_errno): Fix self type.
-        * pthread.h (PT_STDCALL): Move from here to
-        * implement.h (PT_STDCALL): here.
-        (_pthread_threadStart): Fix prototype.
-        * private.c (_pthread_threadStart): Likewise.
-
-1999-08-14  Ross Johnson  <rpj@ixobrychus.canberra.edu.au>
-
-	* exit.c (pthread_exit): Don't call pthread_self() but
-	get thread handle directly from TSD for efficiency.
-	
-1999-08-12  Ross Johnson  <rpj@ixobrychus.canberra.edu.au>
-
-	* private.c (_pthread_threadStart): ei[] only declared if _MSC_VER.
-
-	* exit.c (pthread_exit): Check for implicitly created threads
-	to avoid raising an unhandled exception.
-	
-1999-07-12  Ross Johnson  <rpj@ixobrychus.canberra.edu.au>
-
-	* condvar.c (pthread_cond_destroy): Add critical section.
-	(cond_timedwait): Add critical section; check for timeout
-	waiting on semaphore.
-	(pthread_cond_broadcast): Add critical section.
-	- Peter Slacik <Peter.Slacik@tatramed.sk>
-
-1999-07-09  Ross Johnson  <rpj@ixobrychus.canberra.edu.au>
-
-	The following changes fix a bug identified by
-	Lorin Hochstein <lmh@xiphos.ca> and solved by
-	John Bossom <John.Bossom@Cognos.COM>.
-
-	The problem was that cleanup handlers were not executed when
-	pthread_exit() was called.
-
-	* implement.h (pthread_t_): Add exceptionInformation element for
-	C++ per-thread exception information.
-	(general): Define and rename exceptions.
-
-
-	* misc.c (CancelableWait):  _PTHREAD_EPS_CANCEL (SEH) and
-	Pthread_exception_cancel (C++) used to identify the exception.
-
-	* cancel.c (pthread_testcancel): _PTHREAD_EPS_CANCEL (SEH) and
-	Pthread_exception_cancel (C++) used to identify the exception.
-
-	* exit.c (pthread_exit): throw/raise an exception to return to
-	_pthread_threadStart() to exit the thread. _PTHREAD_EPS_EXIT (SEH)
-	and Pthread_exception_exit (C++) used to identify the exception.
-
-	* private.c (_pthread_threadStart): Add pthread_exit exception trap;
-	clean up and exit the thread directly rather than via pthread_exit().
-
-Sun May 30 00:25:02 1999  Ross Johnson  <rpj@ixobrychus.canberra.edu.au>
-
-	* semaphore.h (mode_t): Conditionally typedef it.
-
-Fri May 28 13:33:05 1999  Ross Johnson  <rpj@swan.canberra.edu.au>
-
-	* condvar.c (pthread_cond_broadcast): Fix possible memory fault
-	- Mark E. Armstrong <avail@pacbell.net>
-	
-Thu May 27 13:08:46 1999  Ross Johnson  <rpj@swan.canberra.edu.au>
-
-	* condvar.c (pthread_cond_broadcast): Fix logic bug
-	- Peter Slacik <Peter.Slacik@tatramed.sk>;
-	optimise sem_post loop
-	- Bossom, John <John.Bossom@Cognos.COM>.
-
-Fri May 14 12:13:18 1999  Ross Johnson  <rpj@swan.canberra.edu.au>
-
-	* attr.c (pthread_attr_setdetachstate): Fix logic bug
-	- Mike Russo <miker@eai.com>.
-
-Sat May  8 09:42:30 1999  Ross Johnson  <rpj@ixobrychus.canberra.edu.au>
-
-	* pthread.def (sem_open): Add.
-	(sem_close): Add.
-	(sem_unlink): Add.
-	(sem_getvalue): Add.
-
-	* FAQ (Question 3): Add.
-
-Thu Apr  8 01:16:23 1999  Ross Johnson  <rpj@ixobrychus.canberra.edu.au>
-
-	* semaphore.c (sem_open): New function; returns an error (ENOSYS).
-	(sem_close): ditto.
-	(sem_unlink): ditto.
-	(sem_getvalue): ditto.
-
-	* semaphore.h (_POSIX_SEMAPHORES): define.
-	
-Wed Apr  7 14:09:52 1999  Ross Johnson  <rpj@swan.canberra.edu.au>
-
-	* errno.c (_REENTRANT || _MT): Invert condition.
-
-	* pthread.h (_errno): Conditionally include prototype.
-
-Wed Apr  7 09:37:00 1999  Ross Johnson  <rpj@ixobrychus.canberra.edu.au>
-
-	* *.c (comments): Remove individual attributions - these are
-	documented sufficiently elsewhere.
-
-	* implement.h (pthread.h): Remove extraneous include.
-
-Sun Apr  4 11:05:57 1999  Ross Johnson  <rpj@ixobrychus.canberra.edu.au>
-
-	* sched.c (sched.h): Include.
-
-	* sched.h: New file for POSIX 1b scheduling.
-
-	* pthread.h: Move opaque structures to implement.h; move sched_*
-	prototypes out and into sched.h.
-
-	* implement.h: Add opaque structures from pthread.h.
-
-	* sched.c (sched_yield): New function.
-
-	* condvar.c (_pthread_sem_*): Rename to sem_*; except for
-	_pthread_sem_timedwait which is an private function.
-
-Sat Apr  3 23:28:00 1999  Ross Johnson  <rpj@ixobrychus.canberra.edu.au>
-
-	* Makefile.in (OBJS): Add errno.o.
-
-Fri Apr  2 11:08:50 1999  Ross Johnson  <rpj@ixobrychus.canberra.edu.au>
-
-	* implement.h (_pthread_sem_*): Remove prototypes now defined in
-	semaphore.h.
-
-	* pthread.h (sempahore.h): Include.
-
-	* semaphore.h: New file for POSIX 1b semaphores.
-
-	* pthread.h (_pthread_sem_t): Change to sem_t. 
-
-	* semaphore.c (_pthread_sem_*): Change to sem_*; these functions
-	will be exported from the library; set errno on error.
-	- John Bossom <jebossom@cognos.com>
-	(_pthread_sem_timedwait): Moved to private.c.
-
-	* private.c (_pthread_sem_timedwait): Moved from semaphore.c;
-	set errno on error.
-
-	* errno.c (_errno): New file. New function.
-	- John Bossom
-
-	* pthread.h (pthread_t_): Add per-thread errno element.
-
-Fri Mar 26 14:11:45 1999  Ross Johnson  <rpj@swan.canberra.edu.au>
-
-	* semaphore.c (_pthread_sem_timedwait): Check for negative
-	milliseconds.
-	- Tor Lillqvist <tml@iki.fi>
-
-Wed Mar 24 11:32:07 1999  Ross Johnson  <rpj@swan.canberra.edu.au>
-
-	* misc.c (CancelableWait): Initialise exceptionInformation[2].
-	(pthread_self): Get a real Win32 thread handle for implicit threads.
-	- John Bossom <jebossom@cognos.com>
-
-	* cancel.c (pthread_testcancel): Initialise exceptionInformation[2].
-	- John Bossom <jebossom@cognos.com>
-
-	* implement.h (SE_INFORMATION): Fix values.
-	- John Bossom <jebossom@cognos.com>
-
-	* private.c (_pthread_threadDestroy): Close the thread handle.
-	- John Bossom <jebossom@cognos.com>
-
-Fri Mar 19 12:57:27 1999  Ross Johnson  <rpj@swan.canberra.edu.au>
-
-	* cancel.c (comments): Update and cleanup.
-
-Fri Mar 19 09:12:59 1999  Ross Johnson  <rpj@ixobrychus.canberra.edu.au>
-
-	* private.c (_pthread_threadStart): status returns PTHREAD_CANCELED.
-
-	* pthread.h (PTHREAD_CANCELED): defined.
-
-Tue Mar 16  1999  Ross Johnson  <rpj@ixobrychus.canberra.edu.au>
-
-	* all: Add GNU LGPL and Copyright and Warranty.
-	
-Mon Mar 15 00:20:13 1999  Ross Johnson  <rpj@ixobrychus.canberra.edu.au>
-
-	* condvar.c (pthread_cond_init): fix possible uninitialised use
-	of cv.
-
-Sun Mar 14 21:01:59 1999  Ross Johnson  <rpj@ixobrychus.canberra.edu.au>
-
-	* condvar.c (pthread_cond_destroy): don't do full cleanup if
-	static initialised cv has never been used.
-	(cond_timedwait): check result of auto-initialisation.
-
-Thu Mar 11 09:01:48 1999  Ross Johnson  <rpj@ixobrychus.canberra.edu.au>
-
-	* pthread.h (pthread_mutex_t): revert to (pthread_mutex_t *);
-	define a value to serve as PTHREAD_MUTEX_INITIALIZER.
-	(pthread_mutex_t_): remove staticinit and valid elements.
-	(pthread_cond_t): revert to (pthread_cond_t_ *);
-	define a value to serve as PTHREAD_COND_INITIALIZER.
-	(pthread_cond_t_): remove staticinit and valid elements.
-
-	* mutex.c (pthread_mutex_t args): adjust indirection of references.
-	(all functions): check for PTHREAD_MUTEX_INITIALIZER value;
-	check for NULL (invalid).
-
-	* condvar.c (pthread_cond_t args): adjust indirection of references.
-	(all functions): check for PTHREAD_COND_INITIALIZER value;
-	check for NULL (invalid).
-
-Wed Mar 10 17:18:12 1999  Ross Johnson  <rpj@ixobrychus.canberra.edu.au>
-
-	* misc.c (CancelableWait): Undo changes from Mar 8 and 7.
-
-Mon Mar  8 11:18:59 1999  Ross Johnson  <rpj@ixobrychus.canberra.edu.au>
-
-	* misc.c (CancelableWait): Ensure cancelEvent handle is the lowest
-	indexed element in the handles array. Enhance test for abandoned
-	objects.
-
-	* pthread.h (PTHREAD_MUTEX_INITIALIZER): Trailing elements not
-	initialised are set to zero by the compiler. This avoids the
-	problem of initialising the opaque critical section element in it.
-	(PTHREAD_COND_INITIALIZER): Ditto.
-
-	* semaphore.c (_pthread_sem_timedwait): Check sem == NULL earlier.
-
-Sun Mar  7 12:31:14 1999  Ross Johnson  <rpj@ixobrychus.canberra.edu.au>
-
-	* condvar.c (pthread_cond_init): set semaphore initial value
-	to 0, not 1. cond_timedwait was returning signaled immediately.
-
-	* misc.c (CancelableWait): Place the cancel event handle first
-	in the handle table for WaitForMultipleObjects. This ensures that
-	the cancel event is recognised and acted apon if both objects
-	happen to be signaled together.
-
-	* private.c (_pthread_cond_test_init_lock): Initialise and destroy.
-
-	* implement.h (_pthread_cond_test_init_lock): Add extern.
-
-	* global.c (_pthread_cond_test_init_lock): Add declaration. 
-
-	* condvar.c (pthread_cond_destroy): check for valid initialised CV;
-	flag destroyed CVs as invalid.
-	(pthread_cond_init): pthread_cond_t is no longer just a pointer.
-	This is because PTHREAD_COND_INITIALIZER needs state info to reside
-	in pthread_cond_t so that it can initialise on first use. Will work on
-	making pthread_cond_t (and other objects like it) opaque again, if
-	possible, later.
-	(cond_timedwait): add check for statically initialisation of
-	CV; initialise on first use.
-	(pthread_cond_signal): check for valid CV.
-	(pthread_cond_broadcast): check for valid CV.
-	(_cond_check_need_init): Add.
-
-	* pthread.h (PTHREAD_COND_INITIALIZER): Fix.
-	(pthread_cond_t): no longer a pointer to pthread_cond_t_.
-	(pthread_cond_t_): add 'staticinit' and 'valid' elements.
-
-Sat Mar 6 1999  Ross Johnson  <rpj@ixobrychus.canberra.edu.au>
-
-	* implement.h: Undate comments.
-
-Sun Feb 21 1999  Ross Johnson  <rpj@ixobrychus.canberra.edu.au>
-
-	* pthread.h (PTHREAD_MUTEX_INITIALIZER): missing braces around
-	cs element initialiser.
-
-1999-02-21  Ben Elliston  <bje@cygnus.com>
-
-	* pthread.h (pthread_exit): The return type of this function is
-	void, not int.
-
-	* exit.c (pthread_exit): Do not return 0.
-
-Sat Feb 20 16:03:30 1999  Ross Johnson  <rpj@ixobrychus.canberra.edu.au>
-
-	* dll.c (DLLMain): Expand TryEnterCriticalSection support test.
-
-	* mutex.c (pthread_mutex_trylock): The check for
-	_pthread_try_enter_critical_section == NULL should have been
-	removed long ago.
-
-Fri Feb 19 16:03:30 1999  Ross Johnson  <rpj@ixobrychus.canberra.edu.au>
-
-	* sync.c (pthread_join): Fix pthread_equal() test.
-
-	* mutex.c (pthread_mutex_trylock): Check mutex != NULL before
-	using it.
-
-Thu Feb 18 16:17:30 1999  Ross Johnson  <rpj@ixobrychus.canberra.edu.au>
-
-	* misc.c (pthread_equal): Fix inverted result.
-
-	* Makefile.in: Use libpthread32.a as the name of the DLL export
-	library instead of pthread.lib.
-
-	* condvar.c (pthread_cond_init): cv could have been used unitialised;
-	initialise.
-
-	* create.c (pthread_create): parms could have been used unitialised;
-	initialise.
-
-	* pthread.h (struct pthread_once_t_): Remove redefinition.
-
-Sat Feb 13 03:03:30 1999  Ross Johnson  <rpj@ixobrychus.canberra.edu.au>
-
-	* pthread.h (struct pthread_once_t_): Replaced.
-
-	* misc.c (pthread_once): Replace with John Bossom's version;
-	has lighter weight serialisation; fixes problem of not holding
-	competing threads until after the init_routine completes.
-
-Thu Feb 11 13:34:14 1999  Ross Johnson  <rpj@ixobrychus.canberra.edu.au>
-
-	* misc.c (CancelableWait): Change C++ exception throw.
-
-	* sync.c (pthread_join): Change FIXME comment - issue resolved.
-
-Wed Feb 10 12:49:11 1999  Ross Johnson  <rpj@ixobrychus.canberra.edu.au>
-
-	* configure: Various temporary changes.
-	- Kevin Ruland <Kevin.Ruland@anheuser-busch.com>
-
-	* README: Update.
-
-	* pthread.def (pthread_attr_getstackaddr): uncomment
-	(pthread_attr_setstackaddr): uncomment
-
-Fri Feb  5 13:42:30 1999  Ross Johnson  <rpj@swan.canberra.edu.au>
-
-	* semaphore.c: Comment format changes.
-
-Thu Feb  4 10:07:28 1999  Ross Johnson  <rpj@ixobrychus.canberra.edu.au>
-
-	* global.c: Remove Pthread_exception instantiation.
-
-	* cancel.c (pthread_testcancel): Change C++ exception throw.
-
-	* implement.h: Remove extern declaration.
-
-Wed Feb  3 13:04:44 1999  Ross Johnson  <rpj@swan.canberra.edu.au>
-
-	* cleanup.c: Rename _pthread_*_cleanup() to pthread_*_cleanup().
-
-	* pthread.def: Ditto.
-	
-	* pthread.h: Ditto.
-
-	* pthread.def (pthread_cleanup_push): Remove from export list;
-	the function is defined as a macro under all compilers.
-	(pthread_cleanup_pop): Ditto.
-
-	* pthread.h: Remove #if defined().
-
-Wed Feb  3 10:13:48 1999  Ross Johnson  <rpj@ixobrychus.canberra.edu.au>
-
-	* sync.c (pthread_join): Check for NULL value_ptr arg;
-	check for detached threads.
-
-Tue Feb  2 18:07:43 1999  Ross Johnson  <rpj@swan.canberra.edu.au>
-
-	* implement.h: Add #include <pthread.h>.
-	Change sem_t to _pthread_sem_t.
-
-	Various patches by Kevin Ruland <Kevin.Ruland@anheuser-busch.com>
-
-	* signal.c (pthread_sigmask): Add and modify casts.
-	Reverse LHS/RHS bitwise assignments.
-
-	* pthread.h: Remove #include <semaphore.h>.
-	(_PTHREAD_ATTR_VALID): Add cast.
-	(struct pthread_t_): Add sigmask element.
-
-	* dll.c: Add "extern C" for DLLMain.
-	(DllMain): Add cast.
-
-	* create.c (pthread_create): Set sigmask in thread.
-
-	* condvar.c: Remove #include. Change sem_* to _pthread_sem_*.
-
-	* attr.c: Changed #include.
-
-	* Makefile.in: Additional targets and changes to build the library
-	as a DLL.
-
-Fri Jan 29 11:56:28 1999  Ross Johnson  <rpj@swan.canberra.edu.au>
-
-	* Makefile.in (OBJS): Add semaphore.o to list.
-
-	* semaphore.c (_pthread_sem_timedwait): Move from private.c.
-	Rename sem_* to _pthread_sem_*.
-
-	* pthread.h (pthread_cond_t): Change type of sem_t.
-	_POSIX_SEMAPHORES no longer defined.
-
-	* semaphore.h: Contents moved to implement.h.
-	Removed from source tree.
-
-	* implement.h: Add semaphore function prototypes and ename all
-	functions to prepend '_pthread_'. They are
-	now private to the pthreads-win32 implementation.
-
-	* private.c: Change #warning.
-	Move _pthread_sem_timedwait() to semaphore.c.
-
-	* cleanup.c: Change #warning.
-
-	* misc.c: Remove #include <errno.h>
-
-	* pthread.def: Cleanup CVS merge conflicts.
-
-	* global.c: Ditto.
-
-	* ChangeLog: Ditto.
-
-	* cleanup.c: Ditto.
-
-Sun Jan 24 01:34:52 1999  Ross Johnson  <rpj@ixobrychus.canberra.edu.au>
-
-	* semaphore.c (sem_wait): Remove second arg to 
-	pthreadCancelableWait() call.
-
-Sat Jan 23 17:36:40 1999  Ross Johnson  <rpj@ixobrychus.canberra.edu.au>
-
-	* pthread.def: Add new functions to export list.
-
-	* pthread.h (PTHREAD_MUTEX_AUTO_CS_NP): New.
-	(PTHREAD_MUTEX_FORCE_CS_NP): New.
-
-	* README: Updated.
-
-Fri Jan 22 14:31:59 1999  Ross Johnson  <rpj@swan.canberra.edu.au>
-
-	* Makefile.in (CFLAGS): Remove -fhandle-exceptions. Not needed
-	with egcs. Add -g for debugging.
-
-	* create.c (pthread_create): Replace __stdcall with PT_STDCALL
-	macro. This is a hack and must be fixed.
-
-	* misc.c (CancelableWait): Remove redundant statement.
-
-	* mutex.c (pthread_mutexattr_init): Cast calloc return value.
-
-	* misc.c (CancelableWait): Add cast.
-	(pthread_self): Add cast.
-
-	* exit.c (pthread_exit): Add cast.
-
-	* condvar.c (pthread_condattr_init): Cast calloc return value.
-
-	* cleanup.c: Reorganise conditional compilation.
-
-	* attr.c (pthread_attr_init): Remove unused 'result'.
-	Cast malloc return value.
-
-	* private.c (_pthread_callUserDestroyRoutines): Redo conditional
-	compilation.
-
-	* misc.c (CancelableWait): C++ version uses 'throw'.
-
-	* cancel.c (pthread_testcancel): Ditto.
-
-	* implement.h (class pthread_exception): Define for C++.
-
-	* pthread.h: Fix C, C++, and Win32 SEH condition compilation
-	mayhem around pthread_cleanup_* defines. C++ version now uses John
-	Bossom's cleanup handlers.
-	(pthread_attr_t): Make 'valid' unsigned.
-	Define '_timeb' as 'timeb' for Ming32.
-	Define PT_STDCALL as nothing for Mingw32. May be temporary.
-
-	* cancel.c (pthread_testcancel): Cast return value.
-
-Wed Jan 20 09:31:28 1999  Ross Johnson  <rpj@ixobrychus.canberra.edu.au>
-
-	* pthread.h (pthread_mutexattr_t): Changed to a pointer.
-
-	* mutex.c (pthread_mutex_init): Conditionally create Win32 mutex
-	- from John Bossom's implementation.
-	(pthread_mutex_destroy): Conditionally close Win32 mutex
-	- from John Bossom's implementation.
-	(pthread_mutexattr_init): Replaced by John Bossom's version.
-	(pthread_mutexattr_destroy): Ditto.
-	(pthread_mutexattr_getpshared): New function from John Bossom's
-	implementation.
-	(pthread_mutexattr_setpshared): New function from John Bossom's
-	implementation.
-
-Tue Jan 19 18:27:42 1999  Ross Johnson  <rpj@swan.canberra.edu.au>
-
-	* pthread.h (pthreadCancelableTimedWait): New prototype.
-	(pthreadCancelableWait): Remove second argument.
-
-	* misc.c (CancelableWait): New static function is 
-	pthreadCancelableWait() renamed.
-	(pthreadCancelableWait): Now just calls CancelableWait() with
-	INFINITE timeout.
-	(pthreadCancelableTimedWait): Just calls CancelableWait()
-	with passed in timeout.
-
-	* private.c (_pthread_sem_timedwait): 'abstime' arg really is
-	absolute time. Calculate relative time to wait from current
-	time before passing timeout to new routine 
-	pthreadCancelableTimedWait().
-	- Scott Lightner <scott@curriculum.com>
-
-Tue Jan 19 10:27:39 1999  Ross Johnson  <rpj@ixobrychus.canberra.edu.au>
-
-	* pthread.h (pthread_mutexattr_setforcecs_np): New prototype.
-	
-	* mutex.c (pthread_mutexattr_init): Init 'pshared' and 'forcecs'
-	attributes to 0.
-	(pthread_mutexattr_setforcecs_np): New function (not portable).
-
-	* pthread.h (pthread_mutex_t): 
-	Add 'mutex' element. Set to NULL in PTHREAD_MUTEX_INITIALIZER.
-	The pthread_mutex_*() routines will try to optimise performance
-	by choosing either mutexes or critical sections as the basis
-	for pthread mutexes for each indevidual mutex.
-	(pthread_mutexattr_t_): Add 'forcecs' element.
-	Some applications may choose to force use of critical sections
-	if they know that:-
-	     the mutex is PROCESS_PRIVATE and, 
-	         either the OS supports TryEnterCriticalSection() or
-	         pthread_mutex_trylock() will never be called on the mutex.
-	This attribute will be setable via a non-portable routine.
-
-	Note: We don't yet support PROCESS_SHARED mutexes, so the
-	implementation as it stands will default to Win32 mutexes only if
-	the OS doesn't support TryEnterCriticalSection. On Win9x, and early
-	versions of NT 'forcecs' will need to be set in order to get
-	critical section based mutexes.
-
-Sun Jan 17 12:01:26 1999  Ross Johnson  <rpj@ixobrychus.canberra.edu.au>
-
-	* pthread.h (PTHREAD_MUTEX_INITIALIZER): Init new 'staticinit'
-	value to '1' and existing 'valid' value to '1'.
-
-	* global.c (_pthread_mutex_test_init_lock): Add.
-
-	* implement.h (_pthread_mutex_test_init_lock.): Add extern.
-
-	* private.c (_pthread_processInitialize): Init critical section for
-	global lock used by _mutex_check_need_init().
-	(_pthread_processTerminate): Ditto (:s/Init/Destroy/).
-
-	* dll.c (dllMain): Move call to FreeLibrary() so that it is only
-	called once when the process detaches.
-
-	* mutex.c (_mutex_check_need_init): New static function to test
-	and init PTHREAD_MUTEX_INITIALIZER mutexes. Provides serialised
-	access to the internal state of the uninitialised static mutex. 
-	Called from pthread_mutex_trylock() and pthread_mutex_lock() which
-	do a quick unguarded test to check if _mutex_check_need_init()
-	needs to be called. This is safe as the test is conservative
- 	and is repeated inside the guarded section of 
-	_mutex_check_need_init(). Thus in all calls except the first
-	calls to lock static mutexes, the additional overhead to lock any
-	mutex is a single memory fetch and test for zero.
-
-	* pthread.h (pthread_mutex_t_): Add 'staticinit' member. Mutexes
-	initialised by PTHREAD_MUTEX_INITIALIZER aren't really initialised
-	until the first attempt to lock it. Using the 'valid'
-	flag (which flags the mutex as destroyed or not) to record this
-	information would be messy. It is possible for a statically
-	initialised mutex such as this to be destroyed before ever being
-	used.
-
-	* mutex.c (pthread_mutex_trylock): Call _mutex_check_need_init()
-	to test/init PTHREAD_MUTEX_INITIALIZER mutexes.
-	(pthread_mutex_lock): Ditto.
-	(pthread_mutex_unlock): Add check to ensure we don't try to unlock
-	an unitialised static mutex.
-	(pthread_mutex_destroy): Add check to ensure we don't try to delete
-	a critical section that we never created. Allows us to destroy
-	a static mutex that has never been locked (and hence initialised).
-	(pthread_mutex_init): Set 'staticinit' flag to 0 for the new mutex.
-
-Sun Jan 17 12:01:26 1999  Ross Johnson  <rpj@ixobrychus.canberra.edu.au>
-
-	* private.c (_pthread_sem_timedwait): Move from semaphore.c.
-
-	* semaphore.c : Remove redundant #includes.
-	(_pthread_sem_timedwait): Move to private.c.
-	(sem_wait): Add missing abstime arg to pthreadCancelableWait() call.
-
-Fri Jan 15 23:38:05 1999  Ross Johnson  <rpj@ixobrychus.canberra.edu.au>
-
-	* condvar.c (cond_timedwait): Remove comment.
-
-Fri Jan 15 15:41:28 1999  Ross Johnson  <rpj@swan.canberra.edu.au>
-
-	* pthread.h: Add new 'abstime' arg to pthreadCancelableWait()
-	prototype.
-
-	* condvar.c (cond_timedwait): New generalised function called by
-	both pthread_cond_wait() and pthread_cond_timedwait(). This is
-	essentially pthread_cond_wait() renamed and modified to add the
-	'abstime' arg and call the new _pthread_sem_timedwait() instead of
-	sem_wait().
-	(pthread_cond_wait): Now just calls the internal static
-	function cond_timedwait() with an INFINITE wait.
-	(pthread_cond_timedwait): Now implemented. Calls the internal
-	static function cond_timedwait().
-
-	* implement.h (_pthread_sem_timedwait): New internal function
-	prototype.
-
-	* misc.c (pthreadCancelableWait): Added new 'abstime' argument
-	to allow shorter than INFINITE wait.
-
-	* semaphore.c (_pthread_sem_timedwait): New function for internal
-	use.  This is essentially sem_wait() modified to add the
-        'abstime' arg and call the modified (see above)
-        pthreadCancelableWait().
-
-Thu Jan 14 14:27:13 1999  Ross Johnson  <rpj@swan.canberra.edu.au>
-
-	* cleanup.c: Correct _cplusplus to __cplusplus wherever used.
-
-	* Makefile.in: Add CC=g++ and add -fhandle-exceptions to CFLAGS.
-	The derived Makefile will compile all units of the package as C++
-	so that those which include try/catch exception handling should work
-	properly. The package should compile ok if CC=gcc, however, exception
-	handling will not be included and thus thread cancellation, for
- 	example, will not work.
-
-	* cleanup.c (_pthread_pop_cleanup): Add #warning to compile this
- 	file as C++ if using a cygwin32 environment. Perhaps the whole package
-	should be compiled using g++ under cygwin.
-
-	* private.c (_pthread_threadStart): Change #error directive
-	into #warning and bracket for __CYGWIN__ and derivative compilers.
-
-Wed Jan 13 09:34:52 1999  Ross Johnson  <rpj@ixobrychus.canberra.edu.au>
-
-	* build.bat: Delete old binaries before compiling/linking.
-
-Tue Jan 12 09:58:38 1999  Ross Johnson  <rpj@ixobrychus.canberra.edu.au>
-
-	* dll.c: The Microsoft compiler pragmas probably are more
-	appropriately protected by _MSC_VER than by _WIN32.
-	- Tor Lillqvist <tml@iki.fi>.
-
-	* condvar.c (pthread_cond_timedwait): Fix function description
-	comments.
-
-	* pthread.h: Define ETIMEDOUT. This should be returned by
-	pthread_cond_timedwait which is not implemented yet as of
-	snapshot-1999-01-04-1305. It was implemented in the older version.
-	The Microsoft compiler pragmas probably are more appropriately
-	protected by _MSC_VER than by _WIN32.
-	- Tor Lillqvist <tml@iki.fi>.
-
-	* pthread.def: pthread_mutex_destroy was missing from the def file
-	- Tor Lillqvist <tml@iki.fi>.
-
-	* condvar.c (pthread_cond_broadcast): Ensure we only wait on threads
-	if there were any waiting on the condition.
-	I think pthread_cond_broadcast should do the WaitForSingleObject
-	only if cv->waiters > 0? Otherwise it seems to hang, at least in the
-	testg thread program from glib.
-	- Tor Lillqvist <tml@iki.fi>. 
-
-	* semaphore.c (sem_post): Correct typo in comment.
-
-Mon Jan 11 20:33:19 1999  Ross Johnson  <rpj@ixobrychus.canberra.edu.au>
-
-	* pthread.h: Re-arrange conditional compile of pthread_cleanup-*
-	macros.
-
-	* cleanup.c (_pthread_push_cleanup): Provide conditional 
-	compile of cleanup->prev.
-
-1999-01-11  Ben Elliston  <bje@cygnus.com>
-
-	* condvar.c (pthread_cond_init): Invert logic when testing the
-	return value from calloc().
-	- Tor Lillqvist <tml@iki.fi>.
-
-Sat Jan  9 14:32:08 1999  Ross Johnson  <rpj@ixobrychus.canberra.edu.au>
-
-	* implement.h: Compile-time switch for CYGWIN derived environments
-	to use CreateThread instead of _beginthreadex. Ditto for ExitThread.
-	Patch provided by Anders Norlander  <anorland@hem2.passagen.se>.
-
-Tue Jan  5 16:33:04 1999  Ross Johnson  <rpj@swan.canberra.edu.au>
-
-	* cleanup.c (_pthread_pop_cleanup): Add C++ version of __try/__except
-	block. Move trailing "}" out of #ifdef _WIN32 block left there by
-	(rpj's) mistake.
-
-	* private.c: Remove #include <errno.h> which is included by pthread.h.
-
-1998-12-11  Ben Elliston  <bje@toilet.to.cygnus.com>
-
-	* README: Update info about subscribing to the mailing list.
-
-Mon Jan  4 11:23:40 1999  Ross Johnson  <rpj@ixobrychus.canberra.edu.au>
-
-	* all: No code changes, just cleanup.
-	- remove #if 0 /* Pre Bossom */ enclosed code.
-	- Remove some redundant #includes.
-	* pthread.h: Update implemented/unimplemented routines list.
-	* Tag the bossom merge branch getting ready to merge back to main
-	trunk.
-
-Tue Dec 29 13:11:16 1998  Ross Johnson  <rpj@ixobrychus.canberra.edu.au>
-
-	* implement.h: Move the following struct definitions to pthread.h:
-	pthread_t_, pthread_attr_t_, pthread_mutex_t_, pthread_mutex_t_,
-	pthread_mutexattr_t_, pthread_key_t_, pthread_cond_t_,
-	pthread_condattr_t_, pthread_once_t_.
-
-	* pthread.h: Add "_" prefix to pthread_push_cleanup and 
-	pthread_pop_cleanup internal routines, and associated struct and
-	typedefs.
-
-	* buildlib.bat: Add compile command for semaphore.c
-
-	* pthread.def: Comment out pthread_atfork routine name. 
-	Now unimplemented.
-
-	* tsd.c (pthread_setspecific): Rename tkAssocCreate to
-	_pthread_tkAssocCreate.
-	(pthread_key_delete): Rename tkAssocDestroy to
-	_pthread_tkAssocDestroy.
-
-	* sync.c (pthread_join): Rename threadDestroy to _pthread_threadDestroy
-
-	* sched.c (is_attr): attr is now **attr (was *attr), so add extra
-	NULL pointer test.
-	(pthread_attr_setschedparam): Increase redirection for attr which is
-	now a **.
-	(pthread_attr_getschedparam): Ditto.
-	(pthread_setschedparam): Change thread validation and rename "thread"
- 	Win32 thread Handle element name to match John Bossom's version.
-	(pthread_getschedparam): Ditto.
-
-	* private.c (_pthread_threadDestroy): Rename call to
-	callUserDestroyRoutines() as _pthread_callUserDestroyRoutines()
-
-	* misc.c: Add #include "implement.h".
-
-	* dll.c: Remove defined(KLUDGE) wrapped code.
-
-	* fork.c: Remove redefinition of ENOMEM.
-	Remove pthread_atfork() and fork() with #if 0/#endif.
-
-	* create.c (pthread_create): Rename threadStart and threadDestroy calls
-	to _pthread_threadStart and _pthread_threadDestroy.
-
-	* implement.h: Rename "detachedstate" to "detachstate".
-
-	* attr.c: Rename "detachedstate" to "detachstate".
-
-Mon Dec 28 09:54:39 1998  Ross Johnson  <rpj@ixobrychus.canberra.edu.au>
-
-	* semaphore.c: Initial version. From John Bossom's implementation.
-	* semaphore.h: Initial version. From John Bossom's implementation.
-
-Mon Dec 28 09:54:39 1998  Ross Johnson  <rpj@ixobrychus.canberra.edu.au>
-
-	* pthread.h (pthread_attr_t_): Change to *pthread_attr_t.
-
-	* attr.c (pthread_attr_setstacksize): Merge with John Bossom's version.
-	(pthread_attr_getstacksize): Merge with John Bossom's version.
-	(pthread_attr_setstackaddr): Merge with John Bossom's version.
-	(pthread_attr_getstackaddr): Merge with John Bossom's version.
-	(pthread_attr_init): Merge with John Bossom's version.
-	(pthread_attr_destroy): Merge with John Bossom's version.
-	(pthread_attr_getdetachstate): Merge with John Bossom's version.
-	(pthread_attr_setdetachstate): Merge with John Bossom's version.
-	(is_attr): attr is now **attr (was *attr), so add extra NULL pointer
-	test.
-
-	* implement.h (pthread_attr_t_): Add and rename elements in JEB's
-	version to correspond to original, so that it can be used with
-	original attr routines.
-
-	* pthread.h: Add #endif at end which was truncated in merging.
-
-Sun Dec 20 14:51:58 1998  Ross Johnson  <rpj@ixobrychus.canberra.edu.au>
-
-	* misc.c (pthreadCancelableWait): New function by John Bossom. Non-standard
-	but provides a hook that can be used to implement cancellation points in
-	applications that use this library.
-
-	* pthread.h (pthread_cleanup_pop): C++ (non-WIN32) version uses
-	try/catch to emulate John Bossom's WIN32 __try/__finally behaviour.
-	In the WIN32 version __finally block, add a test for AbnormalTermination otherwise
-	cleanup is only run if the cleanup_pop execute arg is non-zero. Cancellation
-	should cause the cleanup to run irrespective of the execute arg.
-
-	* condvar.c (pthread_condattr_init): Replaced by John Bossom's version.
-	(pthread_condattr_destroy): Replaced by John Bossom's version.
-	(pthread_condattr_getpshared): Replaced by John Bossom's version.
-	(pthread_condattr_setpshared): Replaced by John Bossom's version.
-	(pthread_cond_init): Replaced by John Bossom's version.
-	Fix comment (refered to mutex rather than condition variable).
-	(pthread_cond_destroy): Replaced by John Bossom's version.
-	(pthread_cond_wait): Replaced by John Bossom's version.
-	(pthread_cond_timedwait): Replaced by John Bossom's version.
-	(pthread_cond_signal): Replaced by John Bossom's version.
-	(pthread_cond_broadcast): Replaced by John Bossom's version.
-
-Thu Dec 17 19:10:46 1998  Ross Johnson  <rpj@ixobrychus.canberra.edu.au>
-
-	* tsd.c (pthread_key_create): Replaced by John Bossom's version.
-	(pthread_key_delete): Replaced by John Bossom's version.
-	(pthread_setspecific): Replaced by John Bossom's version.
-	(pthread_getspecific): Replaced by John Bossom's version.
-
-Mon Dec  7 09:44:40 1998  Ross Johnson  <rpj@ixobrychus.canberra.edu.au>
-
-	* cancel.c (pthread_setcancelstate): Replaced by John Bossom's version.
-	(pthread_setcanceltype): Replaced by John Bossom's version.
-	(pthread_testcancel): Replaced by John Bossom's version.
-	(pthread_cancel): Replaced by John Bossom's version.
-	
-	* exit.c (pthread_exit): Replaced by John Bossom's version.
-
-	* misc.c (pthread_self): Replaced by John Bossom's version.
-	(pthread_equal): Replaced by John Bossom's version.
-
-	* sync.c (pthread_detach): Replaced by John Bossom's version.
-	(pthread_join): Replaced by John Bossom's version.
-
-	* create.c (pthread_create): Replaced by John Bossom's version.
-
-	* private.c (_pthread_processInitialize): New by John Bossom.
-	(_pthread_processTerminate): Non-public function by John Bossom.
-	(_pthread_threadStart): Non-public function by John Bossom.
- 	(_pthread_threadDestroy): Non-public function by John Bossom.
-	(_pthread_cleanupStack): Non-public function by John Bossom.
-	(_pthread_tkAssocCreate): Non-public function by John Bossom.
-	(_pthread_tkAssocDestroy): Non-public function by John Bossom.
-	(_pthread_callUserDestroyRoutines): Non-public function by John Bossom.
-
-	* implement.h: Added John Bossom's non-API structures and
-	declarations.
-
-	* dll.c (PthreadsEntryPoint): Cast return value of GetProcAddress
-	to resolve compile warning from MSVC.
-
-	* dll.c (DLLmain): Replaced by John Bossom's version.
-	* dll.c (PthreadsEntryPoint):
-	Re-applied Anders Norlander's patch:-
-	Initialize _pthread_try_enter_critical_section at startup
-	and release kernel32 handle when DLL is being unloaded.
-
-Sun Dec  6 21:54:35 1998  Ross Johnson  <rpj@ixobrychus.canberra.edu.au>
-
-	* buildlib.bat: Fix args to CL when building the .DLL
-
-	* cleanup.c (_pthread_destructor_run_all): Fix TSD key management.
-	This is a tidy-up before TSD and Thread management is completely
-	replaced by John Bossom's code.
-
-	* tsd.c (pthread_key_create): Fix TSD key management.
-
-	* global.c (_pthread_key_virgin_next): Initialise.
-
-	* build.bat: New DOS script to compile and link a pthreads app
-	using Microsoft's CL compiler linker.
-	* buildlib.bat: New DOS script to compile all the object files
-	and create pthread.lib and pthread.dll using Microsoft's CL
-	compiler linker.
-
-1998-12-05  Anders Norlander  <anorland@hem2.passagen.se>
-
-	* implement.h (_pthread_try_enter_critical_section): New extern
-	* dll.c (_pthread_try_enter_critical_section): New pointer to
-	TryEnterCriticalSection if it exists; otherwise NULL.
-	* dll.c (PthreadsEntryPoint):
-	Initialize _pthread_try_enter_critical_section at startup
-	and release kernel32 handle when DLL is being unloaded.
-	* mutex.c (pthread_mutex_trylock): Replaced check for NT with
-	a check if _pthread_try_enter_critical_section is valid
-	pointer to a function. Call _pthread_try_enter_critical_section
-	instead of TryEnterCriticalSection to avoid errors on Win95.
-
-Thu Dec 3 13:32:00 1998  Ross Johnson  <rpj@ise.canberra.edu.au>
-
-	* README: Correct cygwin32 compatibility statement.
-
-Sun Nov 15 21:24:06 1998  Ross Johnson  <rpj@ixobrychus.canberra.edu.au>
-
-	* cleanup.c (_pthread_destructor_run_all): Declare missing void * arg.
-	Fixup CVS merge conflicts.
-
-1998-10-30  Ben Elliston  <bje@cygnus.com>
-
-	* condvar.c (cond_wait): Fix semantic error. Test for equality
-	instead of making an assignment.
-
-Fri Oct 30 15:15:50 1998  Ross Johnson  <rpj@swan.canberra.edu.au>
-
-	* cleanup.c (_pthread_handler_push): Fixed bug appending new
-	handler to list reported by Peter Slacik
-	<Peter.Slacik@leibinger.freinet.de>.
-	(new_thread): Rename poorly named local variable to
-	"new_handler".
-
-Sat Oct 24 18:34:59 1998  Ross Johnson  <rpj@ixobrychus.canberra.edu.au>
-
-	* global.c: Add TSD key management array and index declarations.
-
-	* implement.h: Ditto for externs.
-
-Fri Oct 23 00:08:09 1998  Ross Johnson  <rpj@ixobrychus.canberra.edu.au>
-
-	* implement.h (_PTHREAD_TSD_KEY_REUSE): Add enum.
-
-	* private.c (_pthread_delete_thread): Add call to
-	_pthread_destructor_run_all() to clean up the threads keys.
-
-	* cleanup.c (_pthread_destructor_run_all): Check for no more dirty
-	keys to run destructors on. Assume that the destructor call always
-	succeeds and set the key value to NULL.
-
-Thu Oct 22 21:44:44 1998  Ross Johnson  <rpj@ixobrychus.canberra.edu.au>
-
-	* tsd.c (pthread_setspecific): Add key management code.
-	(pthread_key_create): Ditto.
-	(pthread_key_delete): Ditto.
-
-	* implement.h (struct _pthread_tsd_key): Add status member.
-
-	* tsd.c: Add description of pthread_key_delete() from the
-	standard as a comment.
-
-Fri Oct 16 17:38:47 1998  Ross Johnson  <rpj@swan.canberra.edu.au>
-
-	* cleanup.c (_pthread_destructor_run_all): Fix and improve
-	stepping through the key table.
-
-Thu Oct 15 14:05:01 1998  Ross Johnson  <rpj@swan.canberra.edu.au>
-
-	* private.c (_pthread_new_thread): Remove init of destructorstack.
-	No longer an element of pthread_t.
-
-	* tsd.c (pthread_setspecific): Fix type declaration and cast.
-	(pthread_getspecific): Ditto.
-	(pthread_getspecific): Change error return value to NULL if key
-	is not in use.
-
-Thu Oct 15 11:53:21 1998  Ross Johnson  <rpj@ixobrychus.canberra.edu.au>
-
-	* global.c (_pthread_tsd_key_table): Fix declaration.
-
-	* implement.h(_pthread_TSD_keys_TlsIndex): Add missing extern.
-	(_pthread_tsd_mutex): Ditto.
-
-	* create.c (_pthread_start_call): Fix "keys" array declaration.
-	Add comment.
-
-	* tsd.c (pthread_setspecific): Fix type declaration and cast.
-	(pthread_getspecific): Ditto.
-
-	* cleanup.c (_pthread_destructor_run_all): Declare missing loop
-	counter.
-
-Wed Oct 14 21:09:24 1998  Ross Johnson  <rpj@ixobrychus.canberra.edu.au>
-
-	* private.c (_pthread_new_thread): Increment _pthread_threads_count.
-	(_pthread_delete_thread): Decrement _pthread_threads_count.
-	Remove some comments.
-
-	* exit.c (_pthread_exit): : Fix two pthread_mutex_lock() calls that
- 	should have been pthread_mutex_unlock() calls.
-	(_pthread_vacuum): Remove call to _pthread_destructor_pop_all().
-
-	* create.c (pthread_create): Fix two pthread_mutex_lock() calls that
- 	should have been pthread_mutex_unlock() calls.
-
-	* global.c (_pthread_tsd_mutex): Add mutex for TSD operations.
-
-	* tsd.c (pthread_key_create): Add critical section.
-	(pthread_setspecific): Ditto.
-	(pthread_getspecific): Ditto.
-	(pthread_key_delete): Ditto.
-
-	* sync.c (pthread_join): Fix two pthread_mutex_lock() calls that
- 	should have been pthread_mutex_unlock() calls.
-
-Mon Oct 12 00:00:44 1998  Ross Johnson  <rpj@ixobrychus.canberra.edu.au>
-
-	* implement.h (_pthread_tsd_key_table): New.
-
-	* create.c (_pthread_start_call): Initialise per-thread TSD keys
-	to NULL.
-
-	* misc.c (pthread_once): Correct typo in comment.
-
-	* implement.h (_pthread_destructor_push): Remove.
-	(_pthread_destructor_pop): Remove.
-	(_pthread_destructor_run_all): Rename from _pthread_destructor_pop_all.
-	(_PTHREAD_TSD_KEY_DELETED): Add enum.
-	(_PTHREAD_TSD_KEY_INUSE): Add enum.
-
-	* cleanup.c (_pthread_destructor_push): Remove.
-	(_pthread_destructor_pop): Remove.
-	(_pthread_destructor_run_all): Totally revamped TSD.
-
-	* dll.c (_pthread_TSD_keys_TlsIndex): Initialise.
-
-	* tsd.c (pthread_setspecific): Totally revamped TSD.
-	(pthread_getspecific): Ditto.
-	(pthread_create): Ditto.
-	(pthread_delete): Ditto.
-
-Sun Oct 11 22:44:55 1998  Ross Johnson  <rpj@ixobrychus.canberra.edu.au>
-
-	* global.c (_pthread_tsd_key_table): Add new global.
-
-	* implement.h (_pthread_tsd_key_t and struct _pthread_tsd_key):
-	Add.
-	(struct _pthread): Remove destructorstack.
-
-	* cleanup.c (_pthread_destructor_run_all): Rename from
- 	_pthread_destructor_pop_all. The key destructor stack was made
- 	global rather than per-thread. No longer removes destructor nodes
-	from the stack. Comments updated.
-
-1998-10-06  Ben Elliston  <bje@cygnus.com>
-
-	* condvar.c (cond_wait): Use POSIX, not Win32 mutex calls.
-	(pthread_cond_broadcast): Likewise.
-	(pthread_cond_signal): Likewise.
-
-1998-10-05  Ben Elliston  <bje@cygnus.com>
-
-	* pthread.def: Update. Some functions aren't available yet, others
-	are macros in <pthread.h>.
-
-	* tests/join.c: Remove; useless.
-
-Mon Oct  5 14:25:08 1998  Ross Johnson  <rpj@ixobrychus.canberra.edu.au>
-
-	* pthread.def: New file for building the DLL.
-
-1998-10-05  Ben Elliston  <bje@cygnus.com>
-
-	* misc.c (pthread_equal): Correct inverted logic bug.
-	(pthread_once): Use the POSIX mutex primitives, not Win32. Remove
-	irrelevant FIXME comment.
-
-	* global.c (PTHREAD_MUTEX_INITIALIZER): Move to pthread.h.
-
-	* pthread.h (PTHREAD_MUTEX_INITIALIZER): Define.
-	(pthread_mutex_t): Reimplement as a struct containing a valid
-	flag. If the flag is ever down upon entry to a mutex operation,
-	we call pthread_mutex_create() to initialise the object. This
-	fixes the problem of how to handle statically initialised objects
-	that can't call InitializeCriticalSection() due to their context.
-	(PTHREAD_ONCE_INIT): Define.
-
-	* mutex.c (pthread_mutex_init): Set valid flag.
-	(pthread_mutex_destroy): Clear valid flag.
-	(pthread_mutex_lock): Check and handle the valid flag.
-	(pthread_mutex_unlock): Likewise.
-	(pthread_mutex_trylock): Likewise.
-
-	* tests/mutex3.c: New file; test for the static initialisation
-	macro. Passes.
-
-	* tests/create1.c: New file; test pthread_create(). Passes.
-	
-	* tests/equal.c: Poor test; remove.
-	
-	* tests/equal1.c New file; test pthread_equal(). Passes.
-
-	* tests/once1.c: New file; test for pthread_once(). Passes.
-
-	* tests/self.c: Remove; rename to self1.c.
-
-	* tests/self1.c: This is the old self.c.
-
-	* tests/self2.c: New file. Test pthread_self() with a single
-	thread. Passes.
-
-	* tests/self3.c: New file. Test pthread_self() with a couple of
-	threads to ensure their thread IDs differ. Passes.
-	
-1998-10-04  Ben Elliston  <bje@cygnus.com>
-
-	* tests/mutex2.c: Test pthread_mutex_trylock(). Passes.
-
-	* tests/mutex1.c: New basic test for mutex functions (it passes).
-	(main): Eliminate warning.
-
-	* configure.in: Test for __stdcall, not _stdcall. Typo.
-
-	* configure: Regenerate.
-
-	* attr.c (pthread_attr_setstackaddr): Remove FIXME comment. Win32
-	does know about ENOSYS after all.
-	(pthread_attr_setstackaddr): Likewise.
-
-1998-10-03  Ben Elliston  <bje@cygnus.com>
-
-	* configure.in: Test for the `_stdcall' keyword.  Define `STDCALL'
-	to `_stdcall' if we have it, null otherwise.
-
-	* configure: Regenerate.
-
-	* acconfig.h (STDCALL): New define.
-
-	* config.h.in: Regenerate.
-
-	* create.c (_pthread_start_call): Add STDCALL prefix.
-	
-	* mutex.c (pthread_mutex_init): Correct function signature.
-
-	* attr.c (pthread_attr_init): Only zero out the `sigmask' member
-	if we have the sigset_t type.
-
-	* pthread.h: No need to include <unistd.h>.  It doesn't even exist
-	on Win32! Again, an artifact of cross-compilation.	
-	(pthread_sigmask): Only provide if we have the sigset_t type.
-
-	* process.h: Remove. This was a stand-in before we started doing
-	native compilation under Win32.
-
-	* pthread.h (pthread_mutex_init): Make `attr' argument const.
-
-1998-10-02  Ben Elliston  <bje@cygnus.com>
-
-	* COPYING: Remove.
-
-	* COPYING.LIB: Add. This library is under the LGPL.
-
-1998-09-13  Ben Elliston  <bje@cygnus.com>
-
-	* configure.in: Test for required system features.
-
-	* configure: Generate. 
-
-	* acconfig.h: New file.
-
-	* config.h.in: Generate.
-
-	* Makefile.in: Renamed from Makefile.
-
-	* COPYING: Import from a recent GNU package.
-
-	* config.guess: Likewise.
-
-	* config.sub: Likewise.
-
-	* install-sh: Likewise.
-
-	* config.h: Remove.  
-
-	* Makefile: Likewise.
-
-1998-09-12  Ben Elliston  <bje@cygnus.com>
-
-	* windows.h: No longer needed; remove.
-
-	* windows.c: Likewise.
-
-Sat Sep 12 20:09:24 1998  Ross Johnson  <rpj@ixobrychus.canberra.edu.au>
-
-	* windows.h: Remove error number definitions. These are in <errno.h>
-	
-	* tsd.c: Add comment explaining rationale for not building
-	POSIX TSD on top of Win32 TLS.
-
-1998-09-12  Ben Elliston  <bje@cygnus.com>
-
-	* {most}.c: Include <errno.h> to get POSIX error values.
-
-	* signal.c (pthread_sigmask): Only provide if HAVE_SIGSET_T is
-	defined.
- 
-	* config.h: #undef features, don't #define them.  This will be
-	generated by autoconf very soon.
-	
-1998-08-11  Ben Elliston  <bje@cygnus.com>
-
-	* Makefile (LIB): Define.
-	(clean): Define target.
-	(all): Build a library not just the object files.
-
-	* pthread.h: Provide a definition for struct timespec if we don't
-	already have one.
-
-	* windows.c (TlsGetValue): Bug fix.
-	
-Thu Aug  6 15:19:22 1998  Ross Johnson  <rpj@swan.canberra.edu.au>
-
-	* misc.c (pthread_once): Fix arg 1 of EnterCriticalSection()
- 	and LeaveCriticalSection() calls to pass address-of lock.
-
-	* fork.c (pthread_atfork): Typecast (void (*)(void *)) funcptr
-	in each _pthread_handler_push() call.
-
-	* exit.c (_pthread_exit): Fix attr arg in 
-	pthread_attr_getdetachstate() call.
-
-	* private.c (_pthread_new_thread): Typecast (HANDLE) NULL.
-	(_pthread_delete_thread): Ditto.
-
-	* implement.h: (_PTHREAD_MAX_THREADS): Add define. This keeps
-	changing in an attempt to make thread administration data types
-	opaque and cleanup DLL startup.
-
-	* dll.c (PthreadsEntryPoint): 
-	(_pthread_virgins): Remove malloc() and free() calls.
-	(_pthread_reuse): Ditto.
-	(_pthread_win32handle_map): Ditto.
-	(_pthread_threads_mutex_table): Ditto.
-
-	* global.c (_POSIX_THREAD_THREADS_MAX): Initialise with 
-	_PTHREAD_MAX_THREADS.
-	(_pthread_virgins): Ditto.
-	(_pthread_reuse): Ditto.
-	(_pthread_win32handle_map): Ditto.
-	(_pthread_threads_mutex_table): Ditto.
-
-	* create.c (pthread_create): Typecast (HANDLE) NULL.
-	Typecast (unsigned (*)(void *)) start_routine.
-
-	* condvar.c (pthread_cond_init): Add address-of operator & to
-	arg 1 of pthread_mutex_init() call.
-	(pthread_cond_destroy): Add address-of operator & to
-	arg 1 of pthread_mutex_destroy() call. 
-
-	* cleanup.c (_pthread_destructor_pop_all): Add (int) cast to 
-	pthread_getspecific() arg.
-	(_pthread_destructor_pop): Add (void *) cast to "if" conditional.
-	(_pthread_destructor_push): Add (void *) cast to
-	_pthread_handler_push() "key" arg.
-	(malloc.h): Add include.
-
-	* implement.h (_pthread_destructor_pop): Add prototype.
-
-	* tsd.c (implement.h): Add include.
-
-	* sync.c (pthread_join): Remove target_thread_mutex and it's
-	initialisation. Rename getdetachedstate to getdetachstate.
-	Remove unused variable "exitcode".
-	(pthread_detach): Remove target_thread_mutex and it's
-	initialisation. Rename getdetachedstate to getdetachstate.
-	Rename setdetachedstate to setdetachstate.
-
-	* signal.c (pthread_sigmask): Rename SIG_SET to SIG_SETMASK.
-	Cast "set" to (long *) in assignment to passify compiler warning.
-	Add address-of operator & to thread->attr.sigmask in memcpy() call
-	and assignment.
-	(pthread_sigmask): Add address-of operator & to thread->attr.sigmask
-	in memcpy() call and assignment.
-
-	* windows.h (THREAD_PRIORITY_ERROR_RETURN): Add.
-	(THREAD_PRIORITY_LOWEST): Add.
-	(THREAD_PRIORITY_HIGHEST): Add.
-
-	* sched.c (is_attr): Add function.
-	(implement.h): Add include.
-	(pthread_setschedparam): Rename all instances of "sched_policy"
-	to "sched_priority".
-	(pthread_getschedparam): Ditto.
-
-Tue Aug  4 16:57:58 1998  Ross Johnson  <rpj@swan.canberra.edu.au>
-
-	* private.c (_pthread_delete_thread): Fix typo. Add missing ';'.
-
-	* global.c (_pthread_virgins): Change types from pointer to 
-	array pointer.
-	(_pthread_reuse): Ditto.
-	(_pthread_win32handle_map): Ditto.
-	(_pthread_threads_mutex_table): Ditto.
-
-	* implement.h(_pthread_virgins): Change types from pointer to 
-	array pointer.
-	(_pthread_reuse): Ditto.
-	(_pthread_win32handle_map): Ditto.
-	(_pthread_threads_mutex_table): Ditto.
-
-	* private.c (_pthread_delete_thread): Fix "entry" should be "thread".
-
-	* misc.c (pthread_self): Add extern for _pthread_threadID_TlsIndex.
-
-	* global.c: Add comment.
-
-	* misc.c (pthread_once): Fix member -> dereferences.
-	Change _pthread_once_flag to once_control->flag in "if" test.
-
-Tue Aug  4 00:09:30 1998  Ross Johnson  <rpj@ixobrychus.canberra.edu.au>
-
-	* implement.h(_pthread_virgins): Add extern.
-	(_pthread_virgin_next): Ditto.
-	(_pthread_reuse): Ditto.
-	(_pthread_reuse_top): Ditto.
-	(_pthread_win32handle_map): Ditto.
-	(_pthread_threads_mutex_table): Ditto.
-
-	* global.c (_pthread_virgins): Changed from array to pointer.
-	Storage allocation for the array moved into dll.c.
-	(_pthread_reuse): Ditto.
-	(_pthread_win32handle_map): Ditto.
-	(_pthread_threads_mutex_table): Ditto.
-
-	* dll.c (PthreadsEntryPoint): Set up thread admin storage when
-	DLL is loaded.
-
-	* fork.c (pthread_atfork): Fix function pointer arg to all
-	_pthread_handler_push() calls. Change "arg" arg to NULL in child push.
-
-	* exit.c: Add windows.h and process.h includes.
-	(_pthread_exit): Add local detachstate declaration.
-	(_pthread_exit): Fix incorrect name for pthread_attr_getdetachstate().
-
-	* pthread.h (_POSIX_THREAD_ATTR_STACKSIZE): Move from global.c
-	(_POSIX_THREAD_ATTR_STACKADDR): Ditto.
-
-	* create.c (pthread_create): Fix #if should be #ifdef.
-	(_pthread_start_call): Remove usused variables.
-
-	* process.h: Create.
-
-	* windows.h: Move _beginthreadex and _endthreadex into
-	process.h
-
-Mon Aug  3 21:19:57 1998  Ross Johnson  <rpj@ixobrychus.canberra.edu.au>
-
-	* condvar.c (pthread_cond_init): Add NULL attr to
-	pthread_mutex_init() call - default attributes will be used.
-	(cond_wait): Fix typo.
-	(cond_wait): Fix typo - cv was ev.
-	(pthread_cond_broadcast): Fix two identical typos.
-
-	* cleanup.c (_pthread_destructor_pop_all): Remove _ prefix from
-	PTHREAD_DESTRUCTOR_ITERATIONS.
-
-	* pthread.h: Move _POSIX_* values into posix.h
-
-	* pthread.h: Fix typo in pthread_mutex_init() prototype.
-
-	* attr.c (pthread_attr_init): Fix error in priority member init.
-
-	* windows.h (THREAD_PRIORITY_NORMAL): Add.
-
-	* pthread.h (sched_param): Add missing ';' to struct definition. 
-
-	* attr.c (pthread_attr_init): Remove obsolete pthread_attr_t
-	member initialisation - cancelstate, canceltype, cancel_pending.
-	(is_attr): Make arg "attr" a const.
-
-	* implement.h (_PTHREAD_HANDLER_POP_LIFO): Remove definition.
-	(_PTHREAD_HANDLER_POP_FIFO): Ditto.
-	(_PTHREAD_VALID): Add missing newline escape (\).
-	(_pthread_handler_node): Make element "next" a pointer.
-
-1998-08-02  Ben Elliston  <bje@cygnus.com>
-
-	* windows.h: Remove duplicate TlsSetValue() prototype.  Add 
-	TlsGetValue() prototype.
-	(FALSE): Define.
-	(TRUE): Likewise.
-	Add forgotten errno values.  Guard against multiple #includes.
-
-	* windows.c: New file.  Implement stubs for Win32 functions.
-
-	* Makefile (SRCS): Remove.  Not explicitly needed.
-	(CFLAGS): Add -Wall for all warnings with GCC.
-
-Sun Aug  2 19:03:42 1998  Ross Johnson  <rpj@ixobrychus.canberra.edu.au>
-
-	* config.h: Create. This is a temporary stand-in for autoconf yet
-	to be done.
- 	(HAVE_SIGNAL_H): Add.
-
-	* pthread.h: Minor rearrangement for temporary config.h.
-
-Fri Jul 31 14:00:29 1998  Ross Johnson  <rpj@swan.canberra.edu.au>
-
-	* cleanup.c (_pthread_destructor_pop): Implement. Removes
-	destructors associated with a key without executing them.
-	(_pthread_destructor_pop_all): Add FIXME comment.
-
-	* tsd.c (pthread_key_delete): Add call to _pthread_destructor_pop().
-
-Fri Jul 31 00:05:45 1998  Ross Johnson  <rpj@ixobrychus.canberra.edu.au>
-
-	* tsd.c (pthread_key_create): Update to properly associate
-	the destructor routine with the key.
-	(pthread_key_delete): Add FIXME comment.
-
-	* exit.c (_pthread_vacuum): Add call to
-	_pthread_destructor_pop_all().
-
-	* implement.h (_pthread_handler_pop_all): Add prototype.
-	(_pthread_destructor_pop_all): Ditto.
-
-	* cleanup.c (_pthread_destructor_push): Implement. This is just a
-	call to _pthread_handler_push().
-	(_pthread_destructor_pop_all): Implement. This is significantly
-	different to _pthread_handler_pop_all().
-
-	* Makefile (SRCS): Create. Preliminary.
-
-	* windows.h: Create. Contains Win32 definitions for compile
-	testing. This is just a standin for the real one.
-
-	* pthread.h (SIG_UNBLOCK): Fix typo. Was SIG_BLOCK.
-	(windows.h): Add include. Required for CRITICAL_SECTION.
-	(pthread_cond_t): Move enum declaration outside of struct
-	definition.
-	(unistd.h): Add include - may be temporary.
-
-	* condvar.c (windows.h): Add include.
-
-	* implement.h (_PTHREAD_THIS): Remove - no longer required.
-	(_PTHREAD_STACK): Use pthread_self() instead of _PTHREAD_THIS.
-
-Thu Jul 30 23:12:45 1998  Ross Johnson  <rpj@ixobrychus.canberra.edu.au>
-
-	* implement.h: Remove _pthread_find_entry() prototype.
-
-	* private.c: Extend comments.
-	Remove _pthread_find_entry() - no longer needed.
-
-	* create.c (_pthread_start_call): Add call to TlsSetValue() to
-	store the thread ID.
-
-	* dll.c (PthreadsEntryPoint): Implement. This is called
-	whenever a process loads the DLL. Used to initialise thread
-	local storage.
-
-	* implement.h: Add _pthread_threadID_TlsIndex.
-	Add ()s around _PTHREAD_VALID expression.
-
-	* misc.c (pthread_self): Re-implement using Win32 TLS to store
-	the threads own ID.
-
-Wed Jul 29 11:39:03 1998  Ross Johnson  <rpj@ixobrychus.canberra.edu.au>
-
-	* private.c: Corrections in comments.
-	(_pthread_new_thread): Alter "if" flow to be more natural.
-
-	* cleanup.c (_pthread_handler_push): Same as below.
-
-	* create.c (pthread_create): Same as below.
-
-	* private.c (_pthread_new_thread): Rename "new" to "new_thread".
-	Since when has a C programmer been required to know C++?
-
-Tue Jul 28 14:04:29 1998  Ross Johnson  <rpj@swan.canberra.edu.au>
-
-	* implement.h: Add _PTHREAD_VALID macro.
-
-	* sync.c (pthread_join): Modify to use the new thread
-	type and _pthread_delete_thread(). Rename "target" to "thread".
-	Remove extra local variable "target".
-	(pthread_detach): Ditto.
-
-	* signal.c (pthread_sigmask): Move init of "us" out of inner block.
-	Fix instance of "this" should have been "us". Rename "us" to "thread".
-
-	* sched.c (pthread_setschedparam): Modify to use the new thread
-	type.
-	(pthread_getschedparam): Ditto.
-
-	* private.c (_pthread_find_thread): Fix return type and arg.
-
-	* implement.h: Remove _PTHREAD_YES and _PTHREAD_NO.
-	(_pthread_new_thread): Add prototype.
-	(_pthread_find_thread): Ditto.
-	(_pthread_delete_thread): Ditto.
-	(_pthread_new_thread_entry): Remove prototype.
-	(_pthread_find_thread_entry): Ditto.
-	(_pthread_delete_thread_entry): Ditto.
-	(  _PTHREAD_NEW, _PTHREAD_INUSE, _PTHREAD_EXITED, _PTHREAD_REUSE):
-	Add.
-
-
-	* create.c (pthread_create): Minor rename "us" to "new" (I need
-	these cues but it doesn't stop me coming out with some major bugs
-	at times).
-	Load start_routine and arg into the thread so the wrapper can
-	call it.
-
-	* exit.c (pthread_exit): Fix pthread_this should be pthread_self.
-
-	* cancel.c (pthread_setcancelstate): Change
- 	_pthread_threads_thread_t * to pthread_t and init with
- 	pthread_this().
-	(pthread_setcanceltype): Ditto.
-
-	* exit.c (_pthread_exit): Add new pthread_t arg.
-	Rename _pthread_delete_thread_entry to _pthread_delete_thread.
-	Rename "us" to "thread".
-	(pthread_exit): Call _pthread_exit with added thread arg.
-
-	* create.c (_pthread_start_call): Insert missing ")".
-	Add "us" arg to _pthread_exit() call.
-	(pthread_create): Modify to use new thread allocation scheme.
-
-	* private.c: Added detailed explanation of the new thread
-	allocation scheme.
-	(_pthread_new_thread): Totally rewritten to use
-	new thread allocation scheme.
-	(_pthread_delete_thread): Ditto.
-	(_pthread_find_thread): Obsolete.
-
-Mon Jul 27 17:46:37 1998  Ross Johnson  <rpj@swan.canberra.edu.au>
-
-	* create.c (pthread_create): Start of rewrite. Not completed yet.
-
-	* private.c (_pthread_new_thread_entry): Start of rewrite. Not
-	complete.
-
-	* implement.h (_pthread_threads_thread): Rename, remove thread
-	member, add win32handle and ptstatus members.
-	(_pthread_t): Add.
-
-	* pthread.h: pthread_t is no longer mapped directly to a Win32
-	HANDLE type. This is so we can let the Win32 thread terminate and
-	reuse the HANDLE while pthreads holds it's own thread ID until
-	the last waiting join exits.
-
-Mon Jul 27 00:20:37 1998  Ross Johnson  <rpj@ixobrychus.canberra.edu.au>
-
-	* private.c (_pthread_delete_thread_entry): Destroy the thread
- 	entry attribute object before deleting the thread entry itself.
-
-	* attr.c (pthread_attr_init): Initialise cancel_pending = FALSE.
-	(pthread_attr_setdetachstate): Rename "detached" to "detachedstate".
-	(pthread_attr_getdetachstate): Ditto.
-
-	* exit.c (_pthread_exit): Fix incorrect check for detachedstate.
-
-	* implement.h (_pthread_call_t): Remove env member. 
-
-Sun Jul 26 13:06:12 1998  Ross Johnson  <rpj@ixobrychus.canberra.edu.au>
-
-	* implement.h (_pthread_new_thread_entry): Fix prototype.
-	(_pthread_find_thread_entry): Ditto.
-	(_pthread_delete_thread_entry): Ditto.
-	(_pthread_exit): Add prototype.
-
-	* exit.c (_pthread_exit): New function. Called from pthread_exit()
-	and _pthread_start_call() to exit the thread. It allows an extra
-	argument which is the return code passed to _endthreadex().
-	(_pthread_exit): Move thread entry delete call from _pthread_vacuum()
-	into here. Add more explanation of thread entry deletion.
-	(_pthread_exit): Clarify comment.
-
-	* create.c (_pthread_start_call): Change pthread_exit() call to
-	_pthread_exit() call.
-
-	* exit.c (_pthread_vacuum): Add thread entry deletion code
-	moved from _pthread_start_call(). See next item.
-	(pthread_exit): Remove longjmp(). Add mutex lock around thread table
-	manipulation code. This routine now calls _enthreadex().
-
-	* create.c (_pthread_start_call): Remove setjmp() call and move
-	cleanup code out. Call pthread_exit(NULL) to terminate the thread.
-
-1998-07-26  Ben Elliston  <bje@cygnus.com>
-
-	* tsd.c (pthread_getspecific): Update comments.
-
-	* mutex.c (pthread_mutexattr_setpshared): Not supported; remove.
-	(pthread_mutexattr_getpshared): Likewise.
-
-	* pthread.h (pthread_mutexattr_setpshared): Remove prototype.
-	(pthread_mutexattr_getpshared): Likewise.
-
-Sun Jul 26 00:09:59 1998  Ross Johnson  <rpj@ixobrychus.canberra.edu.au>
-
-	* sync.c: Rename all instances of _pthread_count_mutex to
-	_pthread_table_mutex.
-
-	* implement.h: Rename _pthread_count_mutex to
-	_pthread_table_mutex.
-
-	* global.c: Rename _pthread_count_mutex to
-	_pthread_table_mutex.
-
-	* create.c (pthread_create): Add critical sections.
-	(_pthread_start_call): Rename _pthread_count_mutex to
-	_pthread_table_mutex.
-
-	* cancel.c (pthread_setcancelstate): Fix indirection bug and rename
-	"this" to "us".
-
-	* signal.c (pthread_sigmask): Rename "this" to "us" and fix some
-	minor syntax errors. Declare "us" and initialise it.
-
-	* sync.c (pthread_detach): Rename "this" to "target".
-
-	* pthread.h: Converting PTHREAD_* defines to alias the (const int)
-	values in global.c.
-
-	* global.c: Started converting PTHREAD_* defines to (const int) as
- 	a part of making the eventual pthreads DLL binary compatible
- 	through version changes.
-
-	* condvar.c (cond_wait): Add cancelation point. This applies the
-	point to both pthread_cond_wait() and pthread_cond_timedwait().
-
-	* exit.c (pthread_exit): Rename "this" to "us".
-
-	* implement.h: Add comment.
-
-	* sync.c (pthread_join): I've satisfied myself that pthread_detach()
-	does set the detached attribute in the thread entry attributes
-	to PTHREAD_CREATE_DETACHED. "if" conditions were changed to test
-	that attribute instead of a separate flag.
-
-	* create.c (pthread_create): Rename "this" to "us".
-	(pthread_create): cancelstate and canceltype are not attributes
-	so the copy to thread entry attribute storage was removed.
-	Only the thread itself can change it's cancelstate or canceltype,
-	ie. the thread must exist already.
-
-	* private.c (_pthread_delete_thread_entry): Mutex locks removed.
-	Mutexes must be applied at the caller level.
-	(_pthread_new_thread_entry): Ditto.
-	(_pthread_new_thread_entry): Init cancelstate, canceltype, and
-	cancel_pending to default values.
-	(_pthread_new_thread_entry): Rename "this" to "new".
-	(_pthread_find_thread_entry): Rename "this" to "entry".
-	(_pthread_delete_thread_entry): Rename "thread_entry" to "entry".
-
-	* create.c (_pthread_start_call): Mutexes changed to
-	_pthread_count_mutex. All access to the threads table entries is
-	under the one mutex. Otherwise chaos reigns.
-
-Sat Jul 25 23:16:51 1998  Ross Johnson  <rpj@ixobrychus.canberra.edu.au>
-
-	* implement.h (_pthread_threads_thread): Move cancelstate and
- 	canceltype members out of pthread_attr_t into here.
-
-	* fork.c (fork): Add comment.
-
-1998-07-25  Ben Elliston  <bje@cygnus.com>
-
-	* fork.c (fork): Autoconfiscate.
-
-Sat Jul 25 00:00:13 1998  Ross Johnson  <rpj@ixobrychus.canberra.edu.au>
-
-	* create.c (_pthread_start_call): Set thread priority.  Ensure our
- 	thread entry is removed from the thread table but only if
- 	pthread_detach() was called and there are no waiting joins.
-	(pthread_create): Set detach flag in thread entry if the 
-	thread is created PTHREAD_CREATE_DETACHED.
-
-	* pthread.h (pthread_attr_t): Rename member "detachedstate".
-
-	* attr.c (pthread_attr_init): Rename attr members.
-
-	* exit.c (pthread_exit): Fix indirection mistake.
-
-	* implement.h (_PTHREAD_THREADS_TABLE_INDEX): Add.
-
-	* exit.c (_pthread_vacuum): Fix incorrect args to
-	_pthread_handler_pop_all() calls.
-	Make thread entry removal conditional.
-
-	* sync.c (pthread_join): Add multiple join and async detach handling.
-
-	* implement.h (_PTHREAD_THREADS_TABLE_INDEX): Add.
-
-	* global.c (_pthread_threads_mutex_table): Add.
-
-	* implement.h (_pthread_once_flag): Remove.
-	(_pthread_once_lock): Ditto.
-	(_pthread_threads_mutex_table): Add.
-
-	* global.c (_pthread_once_flag): Remove.
-	(_pthread_once_lock): Ditto.
-
-	* sync.c (pthread_join): Fix tests involving new return value
-	from _pthread_find_thread_entry().
-	(pthread_detach): Ditto.
-
-	* private.c (_pthread_find_thread_entry): Failure return code
-	changed from -1 to NULL.
-
-Fri Jul 24 23:09:33 1998  Ross Johnson  <rpj@ixobrychus.canberra.edu.au>
-
-	* create.c (pthread_create): Change . to -> in sigmask memcpy() args.
-
-	* pthread.h: (pthread_cancel): Add function prototype.
-	(pthread_testcancel): Ditto.
-
-1998-07-24  Ben Elliston  <bje@cygnus.com>
-
-	* pthread.h (pthread_condattr_t): Rename dummy structure member.
-	(pthread_mutexattr_t): Likewise.
-
-Fri Jul 24 21:13:55 1998  Ross Johnson  <rpj@ixobrychus.canberra.edu.au>
-
-	* cancel.c (pthread_cancel): Implement.
-	(pthread_testcancel): Implement.
-
-	* exit.c (pthread_exit): Add comment explaining the longjmp().
-
-	* implement.h (_pthread_threads_thread_t): New member cancelthread.
-	(_PTHREAD_YES): Define.
-	(_PTHREAD_NO): Define.
-	(RND_SIZEOF): Remove.
-
-	* create.c (pthread_create): Rename cancelability to cancelstate.
-
-	* pthread.h (pthread_attr_t): Rename cancelability to cancelstate.
-	(PTHREAD_CANCELED): Define.
-
-1998-07-24  Ben Elliston  <bje@cygnus.com>
-
-	* pthread.h (SIG_BLOCK): Define if not already defined.
-	(SIG_UNBLOCK): Likewise.
-	(SIG_SETMASK): Likewise.
-	(pthread_attr_t): Add signal mask member.
-	(pthread_sigmask): Add function prototype.
-
-	* signal.c (pthread_sigmask): Implement.
-
-	* create.c: #include <string.h> to get a prototype for memcpy().
-	(pthread_create): New threads inherit their creator's signal
-	mask.  Copy the signal mask to the new thread structure if we know
-	about signals.
-	
-Fri Jul 24 16:33:17 1998  Ross Johnson  <rpj@swan.canberra.edu.au>
-
-	* fork.c (pthread_atfork): Add all the necessary push calls.
-	Local implementation semantics:
-	If we get an ENOMEM at any time then ALL handlers
-	(including those from previous pthread_atfork() calls) will be
-	popped off each of the three atfork stacks before we return.
-	(fork): Add all the necessary pop calls. Add the thread cancellation
-	and join calls to the child fork.
-	Add #includes.
-
-	* implement.h: (_pthread_handler_push): Fix return type and stack arg
-	type in prototype.
-	(_pthread_handler_pop): Fix stack arg type in prototype.
-	(_pthread_handler_pop_all): Fix stack arg type in prototype.
-
-	* cleanup.c (_pthread_handler_push): Change return type to int and
-	return ENOMEM if malloc() fails.
-
-	* sync.c (pthread_detach): Use equality test, not assignment.
-
-	* create.c (_pthread_start_call): Add call to Win32 CloseHandle()
-	if thread is detached.
-
-1998-07-24  Ben Elliston  <bje@cygnus.com>
-
-	* sync.c (pthread_detach): Close the Win32 thread handle to
-	emulate detached (or daemon) threads.
-
-Fri Jul 24 03:00:25 1998  Ross Johnson  <rpj@ixobrychus.canberra.edu.au>
-
-	* sync.c (pthread_join): Save valueptr arg in joinvalueptr for
-	pthread_exit() to use.
-
-	* private.c (_pthread_new_thread_entry): Initialise joinvalueptr to
-	NULL.
-
-	* create.c (_pthread_start_call): Rewrite to facilitate joins.
-	pthread_exit() will do a longjmp() back to here. Does appropriate
-	cleanup and exit/return from the thread.
-	(pthread_create): _beginthreadex() now passes a pointer to our
-	thread table entry instead of just the call member of that entry.
-
-	* implement.h (_pthread_threads_thread): New member 
-	void ** joinvalueptr.
-	(_pthread_call_t): New member jmpbuf env.
-
-	* exit.c (pthread_exit): Major rewrite to handle joins and handing
-	value pointer to joining thread. Uses longjmp() back to 
-	_pthread_start_call().
-
-	* create.c (pthread_create): Ensure values of new attribute members
-	are copied to the thread attribute object.
-
-	* attr.c (pthread_attr_destroy):  Fix merge conflicts.
-	(pthread_attr_getdetachstate):  Fix merge conflicts.
-	(pthread_attr_setdetachstate):  Fix merge conflicts.
-
-	* pthread.h:  Fix merge conflicts.
-
-	* sync.c (pthread_join): Fix merge conflicts.
-
-Fri Jul 24 00:21:21 1998  Ross Johnson  <rpj@ixobrychus.canberra.edu.au>
-
-	* sync.c (pthread_join): Add check for valid and joinable
-	thread.
-	(pthread_detach): Implement. After checking for a valid and joinable
-	thread, it's still a no-op.
-
-	* private.c (_pthread_find_thread_entry): Bug prevented returning
-	an error value in some cases.
-
-	* attr.c (pthread_attr_setdetachedstate): Implement.
-	(pthread_attr_getdetachedstate): Implement.
-
-	* implement.h: Move more hidden definitions into here from
-	pthread.h.
-
-1998-07-24  Ben Elliston  <bje@cygnus.com>
-
-	* pthread.h (PTHREAD_CREATE_JOINABLE): Define.
-	(PTHREAD_CREATE_DETACHED): Likewise.
-	(pthread_attr_t): Add new structure member `detached'.
-	(pthread_attr_getdetachstate): Add function prototype.
-	(pthread_attr_setdetachstate): Likewise.
-
-	* sync.c (pthread_join): Return if the target thread is detached.
-
-	* attr.c (pthread_attr_init): Initialise cancelability and
-	canceltype structure members.
-	(pthread_attr_getdetachstate): Implement.
-	(pthread_attr_setdetachstate): Likewise.
-
-	* implement.h (_PTHREAD_CANCEL_DEFAULTS): Remove.  Bit fields
-	proved to be too cumbersome.  Set the defaults in attr.c using the
-	public PTHREAD_CANCEL_* constants.
-
-	* cancel.c: New file.
-
-	* pthread.h (sched_param): Define this type.
-	(pthread_attr_getschedparam): Add function prototype.
-	(pthread_attr_setschedparam): Likewise.
-	(pthread_setcancelstate): Likewise.
-	(pthread_setcanceltype): Likewise.
-	(sched_get_priority_min): Likewise.
-	(sched_get_priority_max): Likewise.
-	(pthread_mutexattr_setprotocol): Remove; not supported.
-	(pthread_mutexattr_getprotocol): Likewise.
-	(pthread_mutexattr_setprioceiling): Likewise.
-	(pthread_mutexattr_getprioceiling): Likewise.
-	(pthread_attr_t): Add canceltype member.  Update comments.
-	(SCHED_OTHER): Define this scheduling policy constant.
-	(SCHED_FIFO): Likewise.
-	(SCHED_RR): Likewise.
-	(SCHED_MIN): Define the lowest possible value for this constant.
-	(SCHED_MAX): Likewise, the maximum possible value.
-	(PTHREAD_CANCEL_ASYNCHRONOUS): Redefine.
-	(PTHREAD_CANCEL_DEFERRED): Likewise.
-	
-	* sched.c: New file.
-	(pthread_setschedparam): Implement.
-	(pthread_getschedparam): Implement.
-	(sched_get_priority_max): Validate policy argument.
-	(sched_get_priority_min): Likewise.
-
-	* mutex.c (pthread_mutexattr_setprotocol): Remove; not supported.
-	(pthread_mutexattr_getprotocol): Likewise.
-	(pthread_mutexattr_setprioceiling): Likewise.
-	(pthread_mutexattr_getprioceiling): Likewise.
-
-Fri Jul 24 00:21:21 1998  Ross Johnson  <rpj@ixobrychus.canberra.edu.au>
-
-	* create.c (pthread_create): Arg to _pthread_new_thread_entry()
-	changed. See next entry. Move mutex locks out. Changes made yesterday
-	and today allow us to start the new thread running rather than
-	temporarily suspended.
-
-	* private.c (_pthread_new_thread_entry): _pthread_thread_table
-	was changed back to a table of thread structures rather than pointers.
-	As such we're trading storage for increaded speed. This routine
-	was modified to work with the new table. Mutex lock put in around
-	global data accesses.
-	(_pthread_find_thread_entry): Ditto
-	(_pthread_delete_thread_entry): Ditto
-
-Thu Jul 23 23:25:30 1998  Ross Johnson  <rpj@ixobrychus.canberra.edu.au>
-
-	* global.c: New. Global data objects declared here. These moved from
-	pthread.h.
-
-	* pthread.h: Move implementation hidden definitions into
-	implement.h.
-
-	* implement.h: Move implementation hidden definitions from
-	pthread.h. Add constants to index into the different handler stacks.
-
-	* cleanup.c (_pthread_handler_push): Simplify args. Restructure.
-	(_pthread_handler_pop): Simplify args. Restructure.
-	(_pthread_handler_pop_all): Simplify args. Restructure.
-
-Wed Jul 22 00:16:22 1998  Ross Johnson  <rpj@ixobrychus.canberra.edu.au>
-
-	* attr.c, implement.h, pthread.h, ChangeLog: Resolve CVS merge
-	conflicts.
-
-	* private.c (_pthread_find_thread_entry): Changes to return type
-	to support leaner _pthread_threads_table[] which now only stores
-	_pthread_thread_thread_t *.
-	(_pthread_new_thread_entry): Internal changes.
-	(_pthread_delete_thread_entry): Internal changes to avoid contention.
- 	Calling routines changed accordingly.
-
-	* pthread.h: Modified cleanup macros to use new generic push and pop.
-	Added destructor and atfork stacks to _pthread_threads_thread_t.
-
-	* cleanup.c (_pthread_handler_push, _pthread_handler_pop,
-	_pthread_handler_pop_all): Renamed cleanup push and pop routines
-	and made generic to handle destructors and atfork handlers as
-	well.
-
-	* create.c (_pthread_start_call): New function is a wrapper for
-	all new threads. It allows us to do some cleanup when the thread
-	returns, ie. that is otherwise only done if the thread is cancelled.
-
-	* exit.c (_pthread_vacuum): New function contains code from 
-	pthread_exit() that we need in the new _pthread_start_call()
-	as well.
-
-	* implement.h: Various additions and minor changes.
-
-	* pthread.h: Various additions and minor changes.
-	Change cleanup handler macros to use generic handler push and pop
-	functions.
-
-	* attr.c: Minor mods to all functions.
-	(is_attr): Implemented missing function.
-
-	* create.c (pthread_create): More clean up.
-
-	* private.c (_pthread_find_thread_entry): Implement.
-	(_pthread_delete_thread_entry): Implement.
-	(_pthread_new_thread_entry): Implement.
-	These functions manipulate the implementations internal thread
-	table and are part of general code cleanup and modularisation.
-	They replace _pthread_getthreadindex() which was removed.
-
-	* exit.c (pthread_exit): Changed to use the new code above.
-
-	* pthread.h: Add cancelability constants. Update comments.
-
-1998-07-22  Ben Elliston  <bje@cygnus.com>
-
-	* attr.c (pthread_setstacksize): Update test of attr argument.
-	(pthread_getstacksize): Likewise.
-	(pthread_setstackaddr): Likewise.
-	(pthread_getstackaddr): Likewise.
-	(pthread_attr_init): No need to allocate any storage.
-	(pthread_attr_destroy): No need to free any storage.
-
-	* mutex.c (is_attr): Not likely to be needed; remove.
-	(remove_attr): Likewise.
-	(insert_attr): Likewise.
-
-	* implement.h (_pthread_mutexattr_t): Moved to a public definition
-	in pthread.h.  There was little gain in hiding these details.
-	(_pthread_condattr_t): Likewise.
-	(_pthread_attr_t): Likewise.
-
-	* pthread.h (pthread_atfork): Add function prototype.
-	(pthread_attr_t): Moved here from implement.h.
-
-	* fork.c (pthread_atfork): Preliminary implementation.
-	(_pthread_fork): Likewise.
-
-Wed Jul 22 00:16:22 1998  Ross Johnson  <rpj@ixobrychus.canberra.edu.au>
-
-	* cleanup.c (_pthread_cleanup_push): Implement.
-	(_pthread_cleanup_pop): Implement.
-	(_pthread_do_cancellation): Implement.
-	These are private to the implementation. The real cleanup functions
-	are macros. See below.
-
-	* pthread.h (pthread_cleanup_push): Implement as a macro.
-	(pthread_cleanup_pop): Implement as a macro.
-	Because these are macros which start and end a block, the POSIX scoping
-	requirement is observed. See the comment in the file.
-
-	* exit.c (pthread_exit): Refine the code.
-
-	* create.c (pthread_create): Code cleanup.
-
-	* implement.h (RND_SIZEOF): Add RND_SIZEOF(T) to round sizeof(T)
-	up to multiple of DWORD.
-	Add function prototypes.
-
-	* private.c (_pthread_getthreadindex): "*thread" should have been 
-	"thread". Detect empty slot fail condition.
-
-1998-07-20  Ben Elliston  <bje@cygnus.com>
-
-	* misc.c (pthread_once): Implement.  Don't use a per-application
-	flag and mutex--make `pthread_once_t' contain these elements in
-	their structure.  The earlier version had incorrect semantics.
-	
-	* pthread.h (_pthread_once_flag): Add new variable.  Remove.
-	(_pthread_once_lock): Add new mutex lock to ensure integrity of
-	access to _pthread_once_flag.  Remove.
-	(pthread_once): Add function prototype.
-	(pthread_once_t): Define this type.
-	
-Mon Jul 20 02:31:05 1998  Ross Johnson  <rpj@ixobrychus.canberra.edu.au>
-
-	* private.c (_pthread_getthreadindex): Implement.
-
-	* pthread.h: Add application static data dependent on
-	_PTHREADS_BUILD_DLL define. This is needed to avoid allocating
-	non-sharable static data within the pthread DLL.
-
-	* implement.h: Add _pthread_cleanup_stack_t, _pthread_cleanup_node_t
-	and _PTHREAD_HASH_INDEX.
-
-	* exit.c (pthread_exit): Begin work on cleanup and de-allocate
-	thread-private storage.
-
-	* create.c (pthread_create): Add thread to thread table.
-	Keep a thread-private copy of the attributes with default values
-	filled in when necessary. Same for the cleanup stack. Make 
-	pthread_create C run-time library friendly by using _beginthreadex()
-	instead of CreateThread(). Fix error returns.
-
-Sun Jul 19 16:26:23 1998  Ross Johnson  <rpj@ixobrychus.canberra.edu.au>
-
-	* implement.h: Rename pthreads_thread_count to _pthread_threads_count.
-	Create _pthread_threads_thread_t struct to keep thread specific data.
-
-	* create.c: Rename pthreads_thread_count to _pthread_threads_count.
-	(pthread_create): Handle errors from CreateThread().
-
-1998-07-19  Ben Elliston  <bje@cygnus.com>
-
-	* condvar.c (pthread_cond_wait): Generalise.  Moved from here ..
-	(cond_wait): To here.
-	(pthread_cond_timedwait): Implement; use generalised cond_wait().
-
-	* pthread.h (pthread_key_t): Define this type.
-	(pthread_key_create): Add function prototype.
-	(pthread_setspecific): Likewise.
-	(pthread_getspecific): Likwise.
-	(pthread_key_delete): Likewise.
-
-	* tsd.c (pthread_key_create): Implement.
-	(pthread_setspecific): Likewise.
-	(pthread_getspecific): Likewise.
-	(pthread_key_delete): Likewise.
-
-	* mutex.c (pthread_mutex_trylock): Return ENOSYS if this function
-	is called on a Win32 platform which is not Windows NT.
-
-1998-07-18  Ben Elliston  <bje@cygnus.com>
-
-	* condvar.c (pthread_condattr_init): Do not attempt to malloc any
-	storage; none is needed now that condattr_t is an empty struct.
-	(pthread_condattr_destory): Likewise; do not free storage.
-	(pthread_condattr_setpshared): No longer supported; return ENOSYS.
-	(pthread_condattr_getpshared): Likewise.
-	(pthread_cond_init): Implement with help from Douglas Schmidt.
-	Remember to initialise the cv's internal mutex.
-	(pthread_cond_wait): Likewise.
-	(pthread_cond_signal): Likewise.
-	(pthread_cond_broadcast): Likewise.
-	(pthread_cond_timedwait): Preliminary implementation, but I need
-	to see some API documentation for `WaitForMultipleObject'.
-	(pthread_destory): Implement.
-
-	* pthread.h (pthread_cond_init): Add function protoype.
-	(pthread_cond_broadcast): Likewise.
-	(pthread_cond_signal): Likewise.
-	(pthread_cond_timedwait): Likewise.
-	(pthread_cond_wait): Likewise.
-	(pthread_cond_destroy): Likewise.
-	(pthread_cond_t): Define this type.  Fix for u_int.  Do not assume
-	that the mutex contained withing the pthread_cond_t structure will
-	be a critical section.  Use our new POSIX type!
-
-	* implement.h (_pthread_condattr_t): Remove shared attribute.
-
-1998-07-17  Ben Elliston  <bje@cygnus.com>
-
-	* pthread.h (PTHREADS_PROCESS_PRIVATE): Remove.
-	(PTHREAD_PROCESS_SHARED): Likewise.  No support for mutexes shared
-	across processes for now.
-	(pthread_mutex_t): Use a Win32 CRITICAL_SECTION type for better
-	performance.
-	
-	* implement.h (_pthread_mutexattr_t): Remove shared attribute.
-	
-	* mutex.c (pthread_mutexattr_setpshared): This optional function
-	is no longer supported, since we want to implement POSIX mutex
-	variables using the much more efficient Win32 critical section
-	primitives.  Critical section objects in Win32 cannot be shared
-	between processes.
-	(pthread_mutexattr_getpshared): Likewise.
-	(pthread_mutexattr_init): No need to malloc any storage; the
-	attributes structure is now empty.
-	(pthread_mutexattr_destroy): This is now a nop.
-	(pthread_mutex_init): Use InitializeCriticalSection().
-	(pthread_mutex_destroy): Use DeleteCriticalSection().
-	(pthread_mutex_lock): Use EnterCriticalSection().
-	(pthread_mutex_trylock): Use TryEnterCriticalSection().  This is
-	not supported by Windows 9x, but trylock is a hack anyway, IMHO.
-	(pthread_mutex_unlock): Use LeaveCriticalSection().
-
-1998-07-14  Ben Elliston  <bje@cygnus.com>
-
-	* attr.c (pthread_attr_setstacksize): Implement.
-	(pthread_attr_getstacksize): Likewise.
-	(pthread_attr_setstackaddr): Likewise.
-	(pthread_attr_getstackaddr): Likewise.
-	(pthread_attr_init): Likewise.
-	(pthread_attr_destroy): Likewise.
-	
-	* condvar.c (pthread_condattr_init): Add `_cond' to function name.
-
-	* mutex.c (pthread_mutex_lock): Add `_mutex' to function name.
-	(pthread_mutex_trylock): Likewise.
-	(pthread_mutex_unlock): Likewise.
-
-	* pthread.h (pthread_condattr_setpshared): Fix typo.
-	(pthread_attr_init): Add function prototype.
-	(pthread_attr_destroy): Likewise.
-	(pthread_attr_setstacksize): Likewise.
-	(pthread_attr_getstacksize): Likewise.
-	(pthread_attr_setstackaddr): Likewise.
-	(pthread_attr_getstackaddr): Likewise.
-	
-Mon Jul 13 01:09:55 1998  Ross Johnson  <rpj@ixobrychus.canberra.edu.au>
-
-	* implement.h: Wrap in #ifndef _IMPLEMENT_H
-
-	* create.c (pthread_create): Map stacksize attr to Win32.
-
-	* mutex.c: Include implement.h
-
-1998-07-13  Ben Elliston  <bje@cygnus.com>
-
-	* condvar.c (pthread_condattr_init): Implement.
-	(pthread_condattr_destroy): Likewise.
-	(pthread_condattr_setpshared): Likewise.
-	(pthread_condattr_getpshared): Likewise.
-	
-	* implement.h (PTHREAD_THREADS_MAX): Remove trailing semicolon.
-	(PTHREAD_STACK_MIN): Specify; needs confirming.
-	(_pthread_attr_t): Define this type.
-	(_pthread_condattr_t): Likewise.
-
-	* pthread.h (pthread_mutex_t): Define this type.
-	(pthread_condattr_t): Likewise.
-	(pthread_mutex_destroy): Add function prototype.
-	(pthread_lock): Likewise.
-	(pthread_trylock): Likewise.
-	(pthread_unlock): Likewise.
-	(pthread_condattr_init): Likewise.
-	(pthread_condattr_destroy): Likewise.
-	(pthread_condattr_setpshared): Likewise.
-	(pthread_condattr_getpshared): Likewise.
-
-	* mutex.c (pthread_mutex_init): Implement.
-	(pthread_mutex_destroy): Likewise.
-	(pthread_lock): Likewise.
-	(pthread_trylock): Likewise.
-	(pthread_unlock): Likewise.
-
-1998-07-12  Ben Elliston  <bje@cygnus.com>
-
-	* implement.h (_pthread_mutexattr_t): Define this implementation
-	internal type.  Application programmers only see a mutex attribute
-	object as a void pointer.
-
-	* pthread.h (pthread_mutexattr_t): Define this type.
-	(pthread_mutexattr_init): Add function prototype.
-	(pthread_mutexattr_destroy): Likewise.
-	(pthread_mutexattr_setpshared): Likewise.
-	(pthread_mutexattr_getpshared): Likewise.
-	(pthread_mutexattr_setprotocol): Likewise.
-	(pthread_mutexattr_getprotocol): Likewise.
-	(pthread_mutexattr_setprioceiling): Likewise.
-	(pthread_mutexattr_getprioceiling): Likewise.
-	(PTHREAD_PROCESS_PRIVATE): Define.
-	(PTHREAD_PROCESS_SHARED): Define.
-
-	* mutex.c (pthread_mutexattr_init): Implement.
-	(pthread_mutexattr_destroy): Implement.
-	(pthread_mutexattr_setprotocol): Implement.
-	(pthread_mutexattr_getprotocol): Likewise.
-	(pthread_mutexattr_setprioceiling): Likewise.
-	(pthread_mutexattr_getprioceiling): Likewise.
-	(pthread_mutexattr_setpshared): Likewise.
-	(pthread_mutexattr_getpshared): Likewise.
-	(insert_attr): New function; very preliminary implementation!
-	(is_attr): Likewise.
-	(remove_attr): Likewise.
-	
-Sat Jul 11 14:48:54 1998  Ross Johnson  <rpj@ixobrychus.canberra.edu.au>
-
-	* implement.h: Preliminary implementation specific defines.
-
-	* create.c (pthread_create): Preliminary implementation.
-
-1998-07-11  Ben Elliston  <bje@cygnus.com>
-
-	* sync.c (pthread_join): Implement.
-
-	* misc.c (pthread_equal): Likewise.
-	
-	* pthread.h (pthread_join): Add function prototype.
-	(pthread_equal): Likewise.
-	
-1998-07-10  Ben Elliston  <bje@cygnus.com>
-
-	* misc.c (pthread_self): Implement.
-
-	* exit.c (pthread_exit): Implement.
-
-	* pthread.h (pthread_exit): Add function prototype.
-	(pthread_self): Likewise.
-	(pthread_t): Define this type.
-
-1998-07-09  Ben Elliston  <bje@cygnus.com>
-
-	* create.c (pthread_create): A dummy stub right now.
-
-	* pthread.h (pthread_create): Add function prototype.
-
+1999-10-30  Ross Johnson  <rpj@ixobrychus.canberra.edu.au>
+
+	* create.c (pthread_create): Explicitly initialise thread state to
+	default values.
+
+	* cancel.c (pthread_setcancelstate): Check for NULL 'oldstate'
+	for compatibility with Solaris pthreads;
+	(pthread_setcanceltype): ditto:
+	- Erik Hensema <erik.hensema@group2000.nl>
+
+1999-10-23  Ross Johnson  <rpj@ixobrychus.canberra.edu.au>
+
+	* pthread.h (ctime_r): Fix incorrect argument "_tm"
+	- Erik Hensema <erik.hensema@group2000.nl>
+
+1999-10-21  Ross Johnson  <rpj@ixobrychus.canberra.edu.au>
+
+	* pthread.h (_POSIX_THREADS): Only define it if it isn't
+	already defined. Projects may need to define this on
+	the CC command line under Win32 as it doesn't have unistd.h
+	- Aurelio Medina <aureliom@crt.com>
+
+1999-10-17  Ross Johnson  <rpj@ixobrychus.canberra.edu.au>
+
+	* rwlock.c (pthread_rwlock_destroy): Add cast to remove compile
+	warning.
+
+	* condvar.c (pthread_cond_broadcast): Only release semaphores
+	if there are waiting threads.
+
+1999-10-15  Ross Johnson  <rpj@ixobrychus.canberra.edu.au>
+
+	* condvar.c (cond_wait_cleanup): New static cleanup handler for
+	cond_timedwait;
+	(cond_timedwait): pthread_cleanup_push args changed;
+	canceling a thread while it's in pthread_cond_wait
+	will now decrement the waiters count and cleanup if it's the
+	last waiter.
+	- Lorin Hochstein <lmh@xiphos.ca> and 
+	  Peter Slacik <Peter.Slacik@tatramed.sk>;
+	the last waiter will now reset the CV's wasBroadcast flag
+	- Graham Dumpleton <Graham.Dumpleton@ra.pad.otc.telstra.com.au>.
+
+Thu Sep 16 1999  Ross Johnson  <rpj@swan.canberra.edu.au>
+
+	* rwlock.c (pthread_rwlock_destroy): Add serialisation.
+	(_rwlock_check_need_init): Check for detroyed rwlock.
+	* rwlock.c: Check return codes from _rwlock_check_need_init();
+	modify comments; serialise access to rwlock objects during
+	operations; rename rw_mutex to rw_lock.
+	* implement.h: Rename rw_mutex to rw_lock.
+	* mutex.c (pthread_mutex_destroy): Add serialisation.
+	(_mutex_check_need_init): Check for detroyed mutex.
+	* condvar.c (pthread_cond_destroy): Add serialisation.
+	(_cond_check_need_init): Check for detroyed condvar.
+	* mutex.c: Modify comments.
+	* condvar.c: Modify comments.
+
+Sat Sep 10 12:56:13 1999  Ross Johnson  <rpj@swan.canberra.edu.au>
+
+	The following code for POSIX read/write locks was contributed
+	by Aurelio Medina.
+
+	* implement.h (pthread_rwlock_t_): Add.
+	* pthread.h (pthread_rwlock_t): Add.
+	(PTHREAD_RWLOCK_INITIALIZER): Add.
+	Add rwlock function prototypes.
+	* rwlock.c: New module.
+	* pthread.def: Add new rwlock functions.
+	* private.c (_pthread_processInitialize): initialise
+	_pthread_rwlock_test_init_lock critical section.
+	* global.c (_pthread_rwlock_test_init_lock): Add.
+
+	* mutex.c (pthread_mutex_destroy): Don't free mutex memory
+	if mutex is PTHREAD_MUTEX_INITIALIZER and has not been
+	initialised yet.
+
+Wed Sep  8 12:56:13 1999  Ross Johnson  <rpj@swan.canberra.edu.au>
+
+	* mutex.c (pthread_mutex_destroy): Free mutex memory.
+	- Milan Gardian <mg@tatramed.sk>
+
+1999-08-22  Ross Johnson  <rpj@ixobrychus.canberra.edu.au>
+
+	* exit.c (pthread_exit): Fix reference to potentially
+	uninitialised pointer.
+
+1999-08-21  Ross Johnson  <rpj@ixobrychus.canberra.edu.au>
+
+	* private.c (_pthread_threadStart): Apply fix of 1999-08-19
+	this time to C++ and non-trapped C versions. Ommitted to
+	do this the first time through.
+
+1999-08-19  Ross Johnson  <rpj@ixobrychus.canberra.edu.au>
+
+	* private.c (_pthread_threadStart): Return exit status from
+	the application thread startup routine.
+	- Milan Gardian <mg@tatramed.sk>
+
+1999-08-18  Ross Johnson  <rpj@ixobrychus.canberra.edu.au>
+
+	* exit.c (pthread_exit): Put status into pthread_t->exitStatus
+	- John Bossom <john.Bossom@cognos.com>
+	* private.c (_pthread_threadStart): Set pthread->exitStatus
+	on exit of try{} block.
+	- John Bossom <john.Bossom@cognos.com>
+	* sync.c (pthread_join): use pthread_exitStatus value if the
+	thread exit doesn't return a value (for Mingw32 CRTDLL
+	which uses endthread instead of _endthreadex).
+	- John Bossom <john.Bossom@cognos.com>
+
+Tue Aug 17 20:17:58 CDT 1999  Mumit Khan  <khan@xraylith.wisc.edu>
+
+        * create.c (pthread_create): Add CRTDLL suppport.
+        * exit.c (pthread_exit): Likewise.
+        * private.c (_pthread_threadStart): Likewise.
+        (_pthread_threadDestroy): Likewise.
+        * sync.c (pthread_join): Likewise.
+        * tests/join1.c (main): Warn about partial support for CRTDLL.
+
+Tue Aug 17 20:00:08 1999  Mumit Khan  <khan@xraylith.wisc.edu>
+
+        * Makefile.in (LD): Delete entry point.
+        * acconfig.h (STDCALL): Delete unused macro.
+        * configure.in: Remove test for STDCALL.
+        * config.h.in: Regenerate.
+        * errno.c (_errno): Fix self type.
+        * pthread.h (PT_STDCALL): Move from here to
+        * implement.h (PT_STDCALL): here.
+        (_pthread_threadStart): Fix prototype.
+        * private.c (_pthread_threadStart): Likewise.
+
+1999-08-14  Ross Johnson  <rpj@ixobrychus.canberra.edu.au>
+
+	* exit.c (pthread_exit): Don't call pthread_self() but
+	get thread handle directly from TSD for efficiency.
+	
+1999-08-12  Ross Johnson  <rpj@ixobrychus.canberra.edu.au>
+
+	* private.c (_pthread_threadStart): ei[] only declared if _MSC_VER.
+
+	* exit.c (pthread_exit): Check for implicitly created threads
+	to avoid raising an unhandled exception.
+	
+1999-07-12  Ross Johnson  <rpj@ixobrychus.canberra.edu.au>
+
+	* condvar.c (pthread_cond_destroy): Add critical section.
+	(cond_timedwait): Add critical section; check for timeout
+	waiting on semaphore.
+	(pthread_cond_broadcast): Add critical section.
+	- Peter Slacik <Peter.Slacik@tatramed.sk>
+
+1999-07-09  Ross Johnson  <rpj@ixobrychus.canberra.edu.au>
+
+	The following changes fix a bug identified by
+	Lorin Hochstein <lmh@xiphos.ca> and solved by
+	John Bossom <John.Bossom@Cognos.COM>.
+
+	The problem was that cleanup handlers were not executed when
+	pthread_exit() was called.
+
+	* implement.h (pthread_t_): Add exceptionInformation element for
+	C++ per-thread exception information.
+	(general): Define and rename exceptions.
+
+
+	* misc.c (CancelableWait):  _PTHREAD_EPS_CANCEL (SEH) and
+	Pthread_exception_cancel (C++) used to identify the exception.
+
+	* cancel.c (pthread_testcancel): _PTHREAD_EPS_CANCEL (SEH) and
+	Pthread_exception_cancel (C++) used to identify the exception.
+
+	* exit.c (pthread_exit): throw/raise an exception to return to
+	_pthread_threadStart() to exit the thread. _PTHREAD_EPS_EXIT (SEH)
+	and Pthread_exception_exit (C++) used to identify the exception.
+
+	* private.c (_pthread_threadStart): Add pthread_exit exception trap;
+	clean up and exit the thread directly rather than via pthread_exit().
+
+Sun May 30 00:25:02 1999  Ross Johnson  <rpj@ixobrychus.canberra.edu.au>
+
+	* semaphore.h (mode_t): Conditionally typedef it.
+
+Fri May 28 13:33:05 1999  Ross Johnson  <rpj@swan.canberra.edu.au>
+
+	* condvar.c (pthread_cond_broadcast): Fix possible memory fault
+	- Mark E. Armstrong <avail@pacbell.net>
+	
+Thu May 27 13:08:46 1999  Ross Johnson  <rpj@swan.canberra.edu.au>
+
+	* condvar.c (pthread_cond_broadcast): Fix logic bug
+	- Peter Slacik <Peter.Slacik@tatramed.sk>;
+	optimise sem_post loop
+	- Bossom, John <John.Bossom@Cognos.COM>.
+
+Fri May 14 12:13:18 1999  Ross Johnson  <rpj@swan.canberra.edu.au>
+
+	* attr.c (pthread_attr_setdetachstate): Fix logic bug
+	- Mike Russo <miker@eai.com>.
+
+Sat May  8 09:42:30 1999  Ross Johnson  <rpj@ixobrychus.canberra.edu.au>
+
+	* pthread.def (sem_open): Add.
+	(sem_close): Add.
+	(sem_unlink): Add.
+	(sem_getvalue): Add.
+
+	* FAQ (Question 3): Add.
+
+Thu Apr  8 01:16:23 1999  Ross Johnson  <rpj@ixobrychus.canberra.edu.au>
+
+	* semaphore.c (sem_open): New function; returns an error (ENOSYS).
+	(sem_close): ditto.
+	(sem_unlink): ditto.
+	(sem_getvalue): ditto.
+
+	* semaphore.h (_POSIX_SEMAPHORES): define.
+	
+Wed Apr  7 14:09:52 1999  Ross Johnson  <rpj@swan.canberra.edu.au>
+
+	* errno.c (_REENTRANT || _MT): Invert condition.
+
+	* pthread.h (_errno): Conditionally include prototype.
+
+Wed Apr  7 09:37:00 1999  Ross Johnson  <rpj@ixobrychus.canberra.edu.au>
+
+	* *.c (comments): Remove individual attributions - these are
+	documented sufficiently elsewhere.
+
+	* implement.h (pthread.h): Remove extraneous include.
+
+Sun Apr  4 11:05:57 1999  Ross Johnson  <rpj@ixobrychus.canberra.edu.au>
+
+	* sched.c (sched.h): Include.
+
+	* sched.h: New file for POSIX 1b scheduling.
+
+	* pthread.h: Move opaque structures to implement.h; move sched_*
+	prototypes out and into sched.h.
+
+	* implement.h: Add opaque structures from pthread.h.
+
+	* sched.c (sched_yield): New function.
+
+	* condvar.c (_pthread_sem_*): Rename to sem_*; except for
+	_pthread_sem_timedwait which is an private function.
+
+Sat Apr  3 23:28:00 1999  Ross Johnson  <rpj@ixobrychus.canberra.edu.au>
+
+	* Makefile.in (OBJS): Add errno.o.
+
+Fri Apr  2 11:08:50 1999  Ross Johnson  <rpj@ixobrychus.canberra.edu.au>
+
+	* implement.h (_pthread_sem_*): Remove prototypes now defined in
+	semaphore.h.
+
+	* pthread.h (sempahore.h): Include.
+
+	* semaphore.h: New file for POSIX 1b semaphores.
+
+	* pthread.h (_pthread_sem_t): Change to sem_t. 
+
+	* semaphore.c (_pthread_sem_*): Change to sem_*; these functions
+	will be exported from the library; set errno on error.
+	- John Bossom <jebossom@cognos.com>
+	(_pthread_sem_timedwait): Moved to private.c.
+
+	* private.c (_pthread_sem_timedwait): Moved from semaphore.c;
+	set errno on error.
+
+	* errno.c (_errno): New file. New function.
+	- John Bossom
+
+	* pthread.h (pthread_t_): Add per-thread errno element.
+
+Fri Mar 26 14:11:45 1999  Ross Johnson  <rpj@swan.canberra.edu.au>
+
+	* semaphore.c (_pthread_sem_timedwait): Check for negative
+	milliseconds.
+	- Tor Lillqvist <tml@iki.fi>
+
+Wed Mar 24 11:32:07 1999  Ross Johnson  <rpj@swan.canberra.edu.au>
+
+	* misc.c (CancelableWait): Initialise exceptionInformation[2].
+	(pthread_self): Get a real Win32 thread handle for implicit threads.
+	- John Bossom <jebossom@cognos.com>
+
+	* cancel.c (pthread_testcancel): Initialise exceptionInformation[2].
+	- John Bossom <jebossom@cognos.com>
+
+	* implement.h (SE_INFORMATION): Fix values.
+	- John Bossom <jebossom@cognos.com>
+
+	* private.c (_pthread_threadDestroy): Close the thread handle.
+	- John Bossom <jebossom@cognos.com>
+
+Fri Mar 19 12:57:27 1999  Ross Johnson  <rpj@swan.canberra.edu.au>
+
+	* cancel.c (comments): Update and cleanup.
+
+Fri Mar 19 09:12:59 1999  Ross Johnson  <rpj@ixobrychus.canberra.edu.au>
+
+	* private.c (_pthread_threadStart): status returns PTHREAD_CANCELED.
+
+	* pthread.h (PTHREAD_CANCELED): defined.
+
+Tue Mar 16  1999  Ross Johnson  <rpj@ixobrychus.canberra.edu.au>
+
+	* all: Add GNU LGPL and Copyright and Warranty.
+	
+Mon Mar 15 00:20:13 1999  Ross Johnson  <rpj@ixobrychus.canberra.edu.au>
+
+	* condvar.c (pthread_cond_init): fix possible uninitialised use
+	of cv.
+
+Sun Mar 14 21:01:59 1999  Ross Johnson  <rpj@ixobrychus.canberra.edu.au>
+
+	* condvar.c (pthread_cond_destroy): don't do full cleanup if
+	static initialised cv has never been used.
+	(cond_timedwait): check result of auto-initialisation.
+
+Thu Mar 11 09:01:48 1999  Ross Johnson  <rpj@ixobrychus.canberra.edu.au>
+
+	* pthread.h (pthread_mutex_t): revert to (pthread_mutex_t *);
+	define a value to serve as PTHREAD_MUTEX_INITIALIZER.
+	(pthread_mutex_t_): remove staticinit and valid elements.
+	(pthread_cond_t): revert to (pthread_cond_t_ *);
+	define a value to serve as PTHREAD_COND_INITIALIZER.
+	(pthread_cond_t_): remove staticinit and valid elements.
+
+	* mutex.c (pthread_mutex_t args): adjust indirection of references.
+	(all functions): check for PTHREAD_MUTEX_INITIALIZER value;
+	check for NULL (invalid).
+
+	* condvar.c (pthread_cond_t args): adjust indirection of references.
+	(all functions): check for PTHREAD_COND_INITIALIZER value;
+	check for NULL (invalid).
+
+Wed Mar 10 17:18:12 1999  Ross Johnson  <rpj@ixobrychus.canberra.edu.au>
+
+	* misc.c (CancelableWait): Undo changes from Mar 8 and 7.
+
+Mon Mar  8 11:18:59 1999  Ross Johnson  <rpj@ixobrychus.canberra.edu.au>
+
+	* misc.c (CancelableWait): Ensure cancelEvent handle is the lowest
+	indexed element in the handles array. Enhance test for abandoned
+	objects.
+
+	* pthread.h (PTHREAD_MUTEX_INITIALIZER): Trailing elements not
+	initialised are set to zero by the compiler. This avoids the
+	problem of initialising the opaque critical section element in it.
+	(PTHREAD_COND_INITIALIZER): Ditto.
+
+	* semaphore.c (_pthread_sem_timedwait): Check sem == NULL earlier.
+
+Sun Mar  7 12:31:14 1999  Ross Johnson  <rpj@ixobrychus.canberra.edu.au>
+
+	* condvar.c (pthread_cond_init): set semaphore initial value
+	to 0, not 1. cond_timedwait was returning signaled immediately.
+
+	* misc.c (CancelableWait): Place the cancel event handle first
+	in the handle table for WaitForMultipleObjects. This ensures that
+	the cancel event is recognised and acted apon if both objects
+	happen to be signaled together.
+
+	* private.c (_pthread_cond_test_init_lock): Initialise and destroy.
+
+	* implement.h (_pthread_cond_test_init_lock): Add extern.
+
+	* global.c (_pthread_cond_test_init_lock): Add declaration. 
+
+	* condvar.c (pthread_cond_destroy): check for valid initialised CV;
+	flag destroyed CVs as invalid.
+	(pthread_cond_init): pthread_cond_t is no longer just a pointer.
+	This is because PTHREAD_COND_INITIALIZER needs state info to reside
+	in pthread_cond_t so that it can initialise on first use. Will work on
+	making pthread_cond_t (and other objects like it) opaque again, if
+	possible, later.
+	(cond_timedwait): add check for statically initialisation of
+	CV; initialise on first use.
+	(pthread_cond_signal): check for valid CV.
+	(pthread_cond_broadcast): check for valid CV.
+	(_cond_check_need_init): Add.
+
+	* pthread.h (PTHREAD_COND_INITIALIZER): Fix.
+	(pthread_cond_t): no longer a pointer to pthread_cond_t_.
+	(pthread_cond_t_): add 'staticinit' and 'valid' elements.
+
+Sat Mar 6 1999  Ross Johnson  <rpj@ixobrychus.canberra.edu.au>
+
+	* implement.h: Undate comments.
+
+Sun Feb 21 1999  Ross Johnson  <rpj@ixobrychus.canberra.edu.au>
+
+	* pthread.h (PTHREAD_MUTEX_INITIALIZER): missing braces around
+	cs element initialiser.
+
+1999-02-21  Ben Elliston  <bje@cygnus.com>
+
+	* pthread.h (pthread_exit): The return type of this function is
+	void, not int.
+
+	* exit.c (pthread_exit): Do not return 0.
+
+Sat Feb 20 16:03:30 1999  Ross Johnson  <rpj@ixobrychus.canberra.edu.au>
+
+	* dll.c (DLLMain): Expand TryEnterCriticalSection support test.
+
+	* mutex.c (pthread_mutex_trylock): The check for
+	_pthread_try_enter_critical_section == NULL should have been
+	removed long ago.
+
+Fri Feb 19 16:03:30 1999  Ross Johnson  <rpj@ixobrychus.canberra.edu.au>
+
+	* sync.c (pthread_join): Fix pthread_equal() test.
+
+	* mutex.c (pthread_mutex_trylock): Check mutex != NULL before
+	using it.
+
+Thu Feb 18 16:17:30 1999  Ross Johnson  <rpj@ixobrychus.canberra.edu.au>
+
+	* misc.c (pthread_equal): Fix inverted result.
+
+	* Makefile.in: Use libpthread32.a as the name of the DLL export
+	library instead of pthread.lib.
+
+	* condvar.c (pthread_cond_init): cv could have been used unitialised;
+	initialise.
+
+	* create.c (pthread_create): parms could have been used unitialised;
+	initialise.
+
+	* pthread.h (struct pthread_once_t_): Remove redefinition.
+
+Sat Feb 13 03:03:30 1999  Ross Johnson  <rpj@ixobrychus.canberra.edu.au>
+
+	* pthread.h (struct pthread_once_t_): Replaced.
+
+	* misc.c (pthread_once): Replace with John Bossom's version;
+	has lighter weight serialisation; fixes problem of not holding
+	competing threads until after the init_routine completes.
+
+Thu Feb 11 13:34:14 1999  Ross Johnson  <rpj@ixobrychus.canberra.edu.au>
+
+	* misc.c (CancelableWait): Change C++ exception throw.
+
+	* sync.c (pthread_join): Change FIXME comment - issue resolved.
+
+Wed Feb 10 12:49:11 1999  Ross Johnson  <rpj@ixobrychus.canberra.edu.au>
+
+	* configure: Various temporary changes.
+	- Kevin Ruland <Kevin.Ruland@anheuser-busch.com>
+
+	* README: Update.
+
+	* pthread.def (pthread_attr_getstackaddr): uncomment
+	(pthread_attr_setstackaddr): uncomment
+
+Fri Feb  5 13:42:30 1999  Ross Johnson  <rpj@swan.canberra.edu.au>
+
+	* semaphore.c: Comment format changes.
+
+Thu Feb  4 10:07:28 1999  Ross Johnson  <rpj@ixobrychus.canberra.edu.au>
+
+	* global.c: Remove Pthread_exception instantiation.
+
+	* cancel.c (pthread_testcancel): Change C++ exception throw.
+
+	* implement.h: Remove extern declaration.
+
+Wed Feb  3 13:04:44 1999  Ross Johnson  <rpj@swan.canberra.edu.au>
+
+	* cleanup.c: Rename _pthread_*_cleanup() to pthread_*_cleanup().
+
+	* pthread.def: Ditto.
+	
+	* pthread.h: Ditto.
+
+	* pthread.def (pthread_cleanup_push): Remove from export list;
+	the function is defined as a macro under all compilers.
+	(pthread_cleanup_pop): Ditto.
+
+	* pthread.h: Remove #if defined().
+
+Wed Feb  3 10:13:48 1999  Ross Johnson  <rpj@ixobrychus.canberra.edu.au>
+
+	* sync.c (pthread_join): Check for NULL value_ptr arg;
+	check for detached threads.
+
+Tue Feb  2 18:07:43 1999  Ross Johnson  <rpj@swan.canberra.edu.au>
+
+	* implement.h: Add #include <pthread.h>.
+	Change sem_t to _pthread_sem_t.
+
+	Various patches by Kevin Ruland <Kevin.Ruland@anheuser-busch.com>
+
+	* signal.c (pthread_sigmask): Add and modify casts.
+	Reverse LHS/RHS bitwise assignments.
+
+	* pthread.h: Remove #include <semaphore.h>.
+	(_PTHREAD_ATTR_VALID): Add cast.
+	(struct pthread_t_): Add sigmask element.
+
+	* dll.c: Add "extern C" for DLLMain.
+	(DllMain): Add cast.
+
+	* create.c (pthread_create): Set sigmask in thread.
+
+	* condvar.c: Remove #include. Change sem_* to _pthread_sem_*.
+
+	* attr.c: Changed #include.
+
+	* Makefile.in: Additional targets and changes to build the library
+	as a DLL.
+
+Fri Jan 29 11:56:28 1999  Ross Johnson  <rpj@swan.canberra.edu.au>
+
+	* Makefile.in (OBJS): Add semaphore.o to list.
+
+	* semaphore.c (_pthread_sem_timedwait): Move from private.c.
+	Rename sem_* to _pthread_sem_*.
+
+	* pthread.h (pthread_cond_t): Change type of sem_t.
+	_POSIX_SEMAPHORES no longer defined.
+
+	* semaphore.h: Contents moved to implement.h.
+	Removed from source tree.
+
+	* implement.h: Add semaphore function prototypes and ename all
+	functions to prepend '_pthread_'. They are
+	now private to the pthreads-win32 implementation.
+
+	* private.c: Change #warning.
+	Move _pthread_sem_timedwait() to semaphore.c.
+
+	* cleanup.c: Change #warning.
+
+	* misc.c: Remove #include <errno.h>
+
+	* pthread.def: Cleanup CVS merge conflicts.
+
+	* global.c: Ditto.
+
+	* ChangeLog: Ditto.
+
+	* cleanup.c: Ditto.
+
+Sun Jan 24 01:34:52 1999  Ross Johnson  <rpj@ixobrychus.canberra.edu.au>
+
+	* semaphore.c (sem_wait): Remove second arg to 
+	pthreadCancelableWait() call.
+
+Sat Jan 23 17:36:40 1999  Ross Johnson  <rpj@ixobrychus.canberra.edu.au>
+
+	* pthread.def: Add new functions to export list.
+
+	* pthread.h (PTHREAD_MUTEX_AUTO_CS_NP): New.
+	(PTHREAD_MUTEX_FORCE_CS_NP): New.
+
+	* README: Updated.
+
+Fri Jan 22 14:31:59 1999  Ross Johnson  <rpj@swan.canberra.edu.au>
+
+	* Makefile.in (CFLAGS): Remove -fhandle-exceptions. Not needed
+	with egcs. Add -g for debugging.
+
+	* create.c (pthread_create): Replace __stdcall with PT_STDCALL
+	macro. This is a hack and must be fixed.
+
+	* misc.c (CancelableWait): Remove redundant statement.
+
+	* mutex.c (pthread_mutexattr_init): Cast calloc return value.
+
+	* misc.c (CancelableWait): Add cast.
+	(pthread_self): Add cast.
+
+	* exit.c (pthread_exit): Add cast.
+
+	* condvar.c (pthread_condattr_init): Cast calloc return value.
+
+	* cleanup.c: Reorganise conditional compilation.
+
+	* attr.c (pthread_attr_init): Remove unused 'result'.
+	Cast malloc return value.
+
+	* private.c (_pthread_callUserDestroyRoutines): Redo conditional
+	compilation.
+
+	* misc.c (CancelableWait): C++ version uses 'throw'.
+
+	* cancel.c (pthread_testcancel): Ditto.
+
+	* implement.h (class pthread_exception): Define for C++.
+
+	* pthread.h: Fix C, C++, and Win32 SEH condition compilation
+	mayhem around pthread_cleanup_* defines. C++ version now uses John
+	Bossom's cleanup handlers.
+	(pthread_attr_t): Make 'valid' unsigned.
+	Define '_timeb' as 'timeb' for Ming32.
+	Define PT_STDCALL as nothing for Mingw32. May be temporary.
+
+	* cancel.c (pthread_testcancel): Cast return value.
+
+Wed Jan 20 09:31:28 1999  Ross Johnson  <rpj@ixobrychus.canberra.edu.au>
+
+	* pthread.h (pthread_mutexattr_t): Changed to a pointer.
+
+	* mutex.c (pthread_mutex_init): Conditionally create Win32 mutex
+	- from John Bossom's implementation.
+	(pthread_mutex_destroy): Conditionally close Win32 mutex
+	- from John Bossom's implementation.
+	(pthread_mutexattr_init): Replaced by John Bossom's version.
+	(pthread_mutexattr_destroy): Ditto.
+	(pthread_mutexattr_getpshared): New function from John Bossom's
+	implementation.
+	(pthread_mutexattr_setpshared): New function from John Bossom's
+	implementation.
+
+Tue Jan 19 18:27:42 1999  Ross Johnson  <rpj@swan.canberra.edu.au>
+
+	* pthread.h (pthreadCancelableTimedWait): New prototype.
+	(pthreadCancelableWait): Remove second argument.
+
+	* misc.c (CancelableWait): New static function is 
+	pthreadCancelableWait() renamed.
+	(pthreadCancelableWait): Now just calls CancelableWait() with
+	INFINITE timeout.
+	(pthreadCancelableTimedWait): Just calls CancelableWait()
+	with passed in timeout.
+
+	* private.c (_pthread_sem_timedwait): 'abstime' arg really is
+	absolute time. Calculate relative time to wait from current
+	time before passing timeout to new routine 
+	pthreadCancelableTimedWait().
+	- Scott Lightner <scott@curriculum.com>
+
+Tue Jan 19 10:27:39 1999  Ross Johnson  <rpj@ixobrychus.canberra.edu.au>
+
+	* pthread.h (pthread_mutexattr_setforcecs_np): New prototype.
+	
+	* mutex.c (pthread_mutexattr_init): Init 'pshared' and 'forcecs'
+	attributes to 0.
+	(pthread_mutexattr_setforcecs_np): New function (not portable).
+
+	* pthread.h (pthread_mutex_t): 
+	Add 'mutex' element. Set to NULL in PTHREAD_MUTEX_INITIALIZER.
+	The pthread_mutex_*() routines will try to optimise performance
+	by choosing either mutexes or critical sections as the basis
+	for pthread mutexes for each indevidual mutex.
+	(pthread_mutexattr_t_): Add 'forcecs' element.
+	Some applications may choose to force use of critical sections
+	if they know that:-
+	     the mutex is PROCESS_PRIVATE and, 
+	         either the OS supports TryEnterCriticalSection() or
+	         pthread_mutex_trylock() will never be called on the mutex.
+	This attribute will be setable via a non-portable routine.
+
+	Note: We don't yet support PROCESS_SHARED mutexes, so the
+	implementation as it stands will default to Win32 mutexes only if
+	the OS doesn't support TryEnterCriticalSection. On Win9x, and early
+	versions of NT 'forcecs' will need to be set in order to get
+	critical section based mutexes.
+
+Sun Jan 17 12:01:26 1999  Ross Johnson  <rpj@ixobrychus.canberra.edu.au>
+
+	* pthread.h (PTHREAD_MUTEX_INITIALIZER): Init new 'staticinit'
+	value to '1' and existing 'valid' value to '1'.
+
+	* global.c (_pthread_mutex_test_init_lock): Add.
+
+	* implement.h (_pthread_mutex_test_init_lock.): Add extern.
+
+	* private.c (_pthread_processInitialize): Init critical section for
+	global lock used by _mutex_check_need_init().
+	(_pthread_processTerminate): Ditto (:s/Init/Destroy/).
+
+	* dll.c (dllMain): Move call to FreeLibrary() so that it is only
+	called once when the process detaches.
+
+	* mutex.c (_mutex_check_need_init): New static function to test
+	and init PTHREAD_MUTEX_INITIALIZER mutexes. Provides serialised
+	access to the internal state of the uninitialised static mutex. 
+	Called from pthread_mutex_trylock() and pthread_mutex_lock() which
+	do a quick unguarded test to check if _mutex_check_need_init()
+	needs to be called. This is safe as the test is conservative
+ 	and is repeated inside the guarded section of 
+	_mutex_check_need_init(). Thus in all calls except the first
+	calls to lock static mutexes, the additional overhead to lock any
+	mutex is a single memory fetch and test for zero.
+
+	* pthread.h (pthread_mutex_t_): Add 'staticinit' member. Mutexes
+	initialised by PTHREAD_MUTEX_INITIALIZER aren't really initialised
+	until the first attempt to lock it. Using the 'valid'
+	flag (which flags the mutex as destroyed or not) to record this
+	information would be messy. It is possible for a statically
+	initialised mutex such as this to be destroyed before ever being
+	used.
+
+	* mutex.c (pthread_mutex_trylock): Call _mutex_check_need_init()
+	to test/init PTHREAD_MUTEX_INITIALIZER mutexes.
+	(pthread_mutex_lock): Ditto.
+	(pthread_mutex_unlock): Add check to ensure we don't try to unlock
+	an unitialised static mutex.
+	(pthread_mutex_destroy): Add check to ensure we don't try to delete
+	a critical section that we never created. Allows us to destroy
+	a static mutex that has never been locked (and hence initialised).
+	(pthread_mutex_init): Set 'staticinit' flag to 0 for the new mutex.
+
+Sun Jan 17 12:01:26 1999  Ross Johnson  <rpj@ixobrychus.canberra.edu.au>
+
+	* private.c (_pthread_sem_timedwait): Move from semaphore.c.
+
+	* semaphore.c : Remove redundant #includes.
+	(_pthread_sem_timedwait): Move to private.c.
+	(sem_wait): Add missing abstime arg to pthreadCancelableWait() call.
+
+Fri Jan 15 23:38:05 1999  Ross Johnson  <rpj@ixobrychus.canberra.edu.au>
+
+	* condvar.c (cond_timedwait): Remove comment.
+
+Fri Jan 15 15:41:28 1999  Ross Johnson  <rpj@swan.canberra.edu.au>
+
+	* pthread.h: Add new 'abstime' arg to pthreadCancelableWait()
+	prototype.
+
+	* condvar.c (cond_timedwait): New generalised function called by
+	both pthread_cond_wait() and pthread_cond_timedwait(). This is
+	essentially pthread_cond_wait() renamed and modified to add the
+	'abstime' arg and call the new _pthread_sem_timedwait() instead of
+	sem_wait().
+	(pthread_cond_wait): Now just calls the internal static
+	function cond_timedwait() with an INFINITE wait.
+	(pthread_cond_timedwait): Now implemented. Calls the internal
+	static function cond_timedwait().
+
+	* implement.h (_pthread_sem_timedwait): New internal function
+	prototype.
+
+	* misc.c (pthreadCancelableWait): Added new 'abstime' argument
+	to allow shorter than INFINITE wait.
+
+	* semaphore.c (_pthread_sem_timedwait): New function for internal
+	use.  This is essentially sem_wait() modified to add the
+        'abstime' arg and call the modified (see above)
+        pthreadCancelableWait().
+
+Thu Jan 14 14:27:13 1999  Ross Johnson  <rpj@swan.canberra.edu.au>
+
+	* cleanup.c: Correct _cplusplus to __cplusplus wherever used.
+
+	* Makefile.in: Add CC=g++ and add -fhandle-exceptions to CFLAGS.
+	The derived Makefile will compile all units of the package as C++
+	so that those which include try/catch exception handling should work
+	properly. The package should compile ok if CC=gcc, however, exception
+	handling will not be included and thus thread cancellation, for
+ 	example, will not work.
+
+	* cleanup.c (_pthread_pop_cleanup): Add #warning to compile this
+ 	file as C++ if using a cygwin32 environment. Perhaps the whole package
+	should be compiled using g++ under cygwin.
+
+	* private.c (_pthread_threadStart): Change #error directive
+	into #warning and bracket for __CYGWIN__ and derivative compilers.
+
+Wed Jan 13 09:34:52 1999  Ross Johnson  <rpj@ixobrychus.canberra.edu.au>
+
+	* build.bat: Delete old binaries before compiling/linking.
+
+Tue Jan 12 09:58:38 1999  Ross Johnson  <rpj@ixobrychus.canberra.edu.au>
+
+	* dll.c: The Microsoft compiler pragmas probably are more
+	appropriately protected by _MSC_VER than by _WIN32.
+	- Tor Lillqvist <tml@iki.fi>.
+
+	* condvar.c (pthread_cond_timedwait): Fix function description
+	comments.
+
+	* pthread.h: Define ETIMEDOUT. This should be returned by
+	pthread_cond_timedwait which is not implemented yet as of
+	snapshot-1999-01-04-1305. It was implemented in the older version.
+	The Microsoft compiler pragmas probably are more appropriately
+	protected by _MSC_VER than by _WIN32.
+	- Tor Lillqvist <tml@iki.fi>.
+
+	* pthread.def: pthread_mutex_destroy was missing from the def file
+	- Tor Lillqvist <tml@iki.fi>.
+
+	* condvar.c (pthread_cond_broadcast): Ensure we only wait on threads
+	if there were any waiting on the condition.
+	I think pthread_cond_broadcast should do the WaitForSingleObject
+	only if cv->waiters > 0? Otherwise it seems to hang, at least in the
+	testg thread program from glib.
+	- Tor Lillqvist <tml@iki.fi>. 
+
+	* semaphore.c (sem_post): Correct typo in comment.
+
+Mon Jan 11 20:33:19 1999  Ross Johnson  <rpj@ixobrychus.canberra.edu.au>
+
+	* pthread.h: Re-arrange conditional compile of pthread_cleanup-*
+	macros.
+
+	* cleanup.c (_pthread_push_cleanup): Provide conditional 
+	compile of cleanup->prev.
+
+1999-01-11  Ben Elliston  <bje@cygnus.com>
+
+	* condvar.c (pthread_cond_init): Invert logic when testing the
+	return value from calloc().
+	- Tor Lillqvist <tml@iki.fi>.
+
+Sat Jan  9 14:32:08 1999  Ross Johnson  <rpj@ixobrychus.canberra.edu.au>
+
+	* implement.h: Compile-time switch for CYGWIN derived environments
+	to use CreateThread instead of _beginthreadex. Ditto for ExitThread.
+	Patch provided by Anders Norlander  <anorland@hem2.passagen.se>.
+
+Tue Jan  5 16:33:04 1999  Ross Johnson  <rpj@swan.canberra.edu.au>
+
+	* cleanup.c (_pthread_pop_cleanup): Add C++ version of __try/__except
+	block. Move trailing "}" out of #ifdef _WIN32 block left there by
+	(rpj's) mistake.
+
+	* private.c: Remove #include <errno.h> which is included by pthread.h.
+
+1998-12-11  Ben Elliston  <bje@toilet.to.cygnus.com>
+
+	* README: Update info about subscribing to the mailing list.
+
+Mon Jan  4 11:23:40 1999  Ross Johnson  <rpj@ixobrychus.canberra.edu.au>
+
+	* all: No code changes, just cleanup.
+	- remove #if 0 /* Pre Bossom */ enclosed code.
+	- Remove some redundant #includes.
+	* pthread.h: Update implemented/unimplemented routines list.
+	* Tag the bossom merge branch getting ready to merge back to main
+	trunk.
+
+Tue Dec 29 13:11:16 1998  Ross Johnson  <rpj@ixobrychus.canberra.edu.au>
+
+	* implement.h: Move the following struct definitions to pthread.h:
+	pthread_t_, pthread_attr_t_, pthread_mutex_t_, pthread_mutex_t_,
+	pthread_mutexattr_t_, pthread_key_t_, pthread_cond_t_,
+	pthread_condattr_t_, pthread_once_t_.
+
+	* pthread.h: Add "_" prefix to pthread_push_cleanup and 
+	pthread_pop_cleanup internal routines, and associated struct and
+	typedefs.
+
+	* buildlib.bat: Add compile command for semaphore.c
+
+	* pthread.def: Comment out pthread_atfork routine name. 
+	Now unimplemented.
+
+	* tsd.c (pthread_setspecific): Rename tkAssocCreate to
+	_pthread_tkAssocCreate.
+	(pthread_key_delete): Rename tkAssocDestroy to
+	_pthread_tkAssocDestroy.
+
+	* sync.c (pthread_join): Rename threadDestroy to _pthread_threadDestroy
+
+	* sched.c (is_attr): attr is now **attr (was *attr), so add extra
+	NULL pointer test.
+	(pthread_attr_setschedparam): Increase redirection for attr which is
+	now a **.
+	(pthread_attr_getschedparam): Ditto.
+	(pthread_setschedparam): Change thread validation and rename "thread"
+ 	Win32 thread Handle element name to match John Bossom's version.
+	(pthread_getschedparam): Ditto.
+
+	* private.c (_pthread_threadDestroy): Rename call to
+	callUserDestroyRoutines() as _pthread_callUserDestroyRoutines()
+
+	* misc.c: Add #include "implement.h".
+
+	* dll.c: Remove defined(KLUDGE) wrapped code.
+
+	* fork.c: Remove redefinition of ENOMEM.
+	Remove pthread_atfork() and fork() with #if 0/#endif.
+
+	* create.c (pthread_create): Rename threadStart and threadDestroy calls
+	to _pthread_threadStart and _pthread_threadDestroy.
+
+	* implement.h: Rename "detachedstate" to "detachstate".
+
+	* attr.c: Rename "detachedstate" to "detachstate".
+
+Mon Dec 28 09:54:39 1998  Ross Johnson  <rpj@ixobrychus.canberra.edu.au>
+
+	* semaphore.c: Initial version. From John Bossom's implementation.
+	* semaphore.h: Initial version. From John Bossom's implementation.
+
+Mon Dec 28 09:54:39 1998  Ross Johnson  <rpj@ixobrychus.canberra.edu.au>
+
+	* pthread.h (pthread_attr_t_): Change to *pthread_attr_t.
+
+	* attr.c (pthread_attr_setstacksize): Merge with John Bossom's version.
+	(pthread_attr_getstacksize): Merge with John Bossom's version.
+	(pthread_attr_setstackaddr): Merge with John Bossom's version.
+	(pthread_attr_getstackaddr): Merge with John Bossom's version.
+	(pthread_attr_init): Merge with John Bossom's version.
+	(pthread_attr_destroy): Merge with John Bossom's version.
+	(pthread_attr_getdetachstate): Merge with John Bossom's version.
+	(pthread_attr_setdetachstate): Merge with John Bossom's version.
+	(is_attr): attr is now **attr (was *attr), so add extra NULL pointer
+	test.
+
+	* implement.h (pthread_attr_t_): Add and rename elements in JEB's
+	version to correspond to original, so that it can be used with
+	original attr routines.
+
+	* pthread.h: Add #endif at end which was truncated in merging.
+
+Sun Dec 20 14:51:58 1998  Ross Johnson  <rpj@ixobrychus.canberra.edu.au>
+
+	* misc.c (pthreadCancelableWait): New function by John Bossom. Non-standard
+	but provides a hook that can be used to implement cancellation points in
+	applications that use this library.
+
+	* pthread.h (pthread_cleanup_pop): C++ (non-WIN32) version uses
+	try/catch to emulate John Bossom's WIN32 __try/__finally behaviour.
+	In the WIN32 version __finally block, add a test for AbnormalTermination otherwise
+	cleanup is only run if the cleanup_pop execute arg is non-zero. Cancellation
+	should cause the cleanup to run irrespective of the execute arg.
+
+	* condvar.c (pthread_condattr_init): Replaced by John Bossom's version.
+	(pthread_condattr_destroy): Replaced by John Bossom's version.
+	(pthread_condattr_getpshared): Replaced by John Bossom's version.
+	(pthread_condattr_setpshared): Replaced by John Bossom's version.
+	(pthread_cond_init): Replaced by John Bossom's version.
+	Fix comment (refered to mutex rather than condition variable).
+	(pthread_cond_destroy): Replaced by John Bossom's version.
+	(pthread_cond_wait): Replaced by John Bossom's version.
+	(pthread_cond_timedwait): Replaced by John Bossom's version.
+	(pthread_cond_signal): Replaced by John Bossom's version.
+	(pthread_cond_broadcast): Replaced by John Bossom's version.
+
+Thu Dec 17 19:10:46 1998  Ross Johnson  <rpj@ixobrychus.canberra.edu.au>
+
+	* tsd.c (pthread_key_create): Replaced by John Bossom's version.
+	(pthread_key_delete): Replaced by John Bossom's version.
+	(pthread_setspecific): Replaced by John Bossom's version.
+	(pthread_getspecific): Replaced by John Bossom's version.
+
+Mon Dec  7 09:44:40 1998  Ross Johnson  <rpj@ixobrychus.canberra.edu.au>
+
+	* cancel.c (pthread_setcancelstate): Replaced by John Bossom's version.
+	(pthread_setcanceltype): Replaced by John Bossom's version.
+	(pthread_testcancel): Replaced by John Bossom's version.
+	(pthread_cancel): Replaced by John Bossom's version.
+	
+	* exit.c (pthread_exit): Replaced by John Bossom's version.
+
+	* misc.c (pthread_self): Replaced by John Bossom's version.
+	(pthread_equal): Replaced by John Bossom's version.
+
+	* sync.c (pthread_detach): Replaced by John Bossom's version.
+	(pthread_join): Replaced by John Bossom's version.
+
+	* create.c (pthread_create): Replaced by John Bossom's version.
+
+	* private.c (_pthread_processInitialize): New by John Bossom.
+	(_pthread_processTerminate): Non-public function by John Bossom.
+	(_pthread_threadStart): Non-public function by John Bossom.
+ 	(_pthread_threadDestroy): Non-public function by John Bossom.
+	(_pthread_cleanupStack): Non-public function by John Bossom.
+	(_pthread_tkAssocCreate): Non-public function by John Bossom.
+	(_pthread_tkAssocDestroy): Non-public function by John Bossom.
+	(_pthread_callUserDestroyRoutines): Non-public function by John Bossom.
+
+	* implement.h: Added John Bossom's non-API structures and
+	declarations.
+
+	* dll.c (PthreadsEntryPoint): Cast return value of GetProcAddress
+	to resolve compile warning from MSVC.
+
+	* dll.c (DLLmain): Replaced by John Bossom's version.
+	* dll.c (PthreadsEntryPoint):
+	Re-applied Anders Norlander's patch:-
+	Initialize _pthread_try_enter_critical_section at startup
+	and release kernel32 handle when DLL is being unloaded.
+
+Sun Dec  6 21:54:35 1998  Ross Johnson  <rpj@ixobrychus.canberra.edu.au>
+
+	* buildlib.bat: Fix args to CL when building the .DLL
+
+	* cleanup.c (_pthread_destructor_run_all): Fix TSD key management.
+	This is a tidy-up before TSD and Thread management is completely
+	replaced by John Bossom's code.
+
+	* tsd.c (pthread_key_create): Fix TSD key management.
+
+	* global.c (_pthread_key_virgin_next): Initialise.
+
+	* build.bat: New DOS script to compile and link a pthreads app
+	using Microsoft's CL compiler linker.
+	* buildlib.bat: New DOS script to compile all the object files
+	and create pthread.lib and pthread.dll using Microsoft's CL
+	compiler linker.
+
+1998-12-05  Anders Norlander  <anorland@hem2.passagen.se>
+
+	* implement.h (_pthread_try_enter_critical_section): New extern
+	* dll.c (_pthread_try_enter_critical_section): New pointer to
+	TryEnterCriticalSection if it exists; otherwise NULL.
+	* dll.c (PthreadsEntryPoint):
+	Initialize _pthread_try_enter_critical_section at startup
+	and release kernel32 handle when DLL is being unloaded.
+	* mutex.c (pthread_mutex_trylock): Replaced check for NT with
+	a check if _pthread_try_enter_critical_section is valid
+	pointer to a function. Call _pthread_try_enter_critical_section
+	instead of TryEnterCriticalSection to avoid errors on Win95.
+
+Thu Dec 3 13:32:00 1998  Ross Johnson  <rpj@ise.canberra.edu.au>
+
+	* README: Correct cygwin32 compatibility statement.
+
+Sun Nov 15 21:24:06 1998  Ross Johnson  <rpj@ixobrychus.canberra.edu.au>
+
+	* cleanup.c (_pthread_destructor_run_all): Declare missing void * arg.
+	Fixup CVS merge conflicts.
+
+1998-10-30  Ben Elliston  <bje@cygnus.com>
+
+	* condvar.c (cond_wait): Fix semantic error. Test for equality
+	instead of making an assignment.
+
+Fri Oct 30 15:15:50 1998  Ross Johnson  <rpj@swan.canberra.edu.au>
+
+	* cleanup.c (_pthread_handler_push): Fixed bug appending new
+	handler to list reported by Peter Slacik
+	<Peter.Slacik@leibinger.freinet.de>.
+	(new_thread): Rename poorly named local variable to
+	"new_handler".
+
+Sat Oct 24 18:34:59 1998  Ross Johnson  <rpj@ixobrychus.canberra.edu.au>
+
+	* global.c: Add TSD key management array and index declarations.
+
+	* implement.h: Ditto for externs.
+
+Fri Oct 23 00:08:09 1998  Ross Johnson  <rpj@ixobrychus.canberra.edu.au>
+
+	* implement.h (_PTHREAD_TSD_KEY_REUSE): Add enum.
+
+	* private.c (_pthread_delete_thread): Add call to
+	_pthread_destructor_run_all() to clean up the threads keys.
+
+	* cleanup.c (_pthread_destructor_run_all): Check for no more dirty
+	keys to run destructors on. Assume that the destructor call always
+	succeeds and set the key value to NULL.
+
+Thu Oct 22 21:44:44 1998  Ross Johnson  <rpj@ixobrychus.canberra.edu.au>
+
+	* tsd.c (pthread_setspecific): Add key management code.
+	(pthread_key_create): Ditto.
+	(pthread_key_delete): Ditto.
+
+	* implement.h (struct _pthread_tsd_key): Add status member.
+
+	* tsd.c: Add description of pthread_key_delete() from the
+	standard as a comment.
+
+Fri Oct 16 17:38:47 1998  Ross Johnson  <rpj@swan.canberra.edu.au>
+
+	* cleanup.c (_pthread_destructor_run_all): Fix and improve
+	stepping through the key table.
+
+Thu Oct 15 14:05:01 1998  Ross Johnson  <rpj@swan.canberra.edu.au>
+
+	* private.c (_pthread_new_thread): Remove init of destructorstack.
+	No longer an element of pthread_t.
+
+	* tsd.c (pthread_setspecific): Fix type declaration and cast.
+	(pthread_getspecific): Ditto.
+	(pthread_getspecific): Change error return value to NULL if key
+	is not in use.
+
+Thu Oct 15 11:53:21 1998  Ross Johnson  <rpj@ixobrychus.canberra.edu.au>
+
+	* global.c (_pthread_tsd_key_table): Fix declaration.
+
+	* implement.h(_pthread_TSD_keys_TlsIndex): Add missing extern.
+	(_pthread_tsd_mutex): Ditto.
+
+	* create.c (_pthread_start_call): Fix "keys" array declaration.
+	Add comment.
+
+	* tsd.c (pthread_setspecific): Fix type declaration and cast.
+	(pthread_getspecific): Ditto.
+
+	* cleanup.c (_pthread_destructor_run_all): Declare missing loop
+	counter.
+
+Wed Oct 14 21:09:24 1998  Ross Johnson  <rpj@ixobrychus.canberra.edu.au>
+
+	* private.c (_pthread_new_thread): Increment _pthread_threads_count.
+	(_pthread_delete_thread): Decrement _pthread_threads_count.
+	Remove some comments.
+
+	* exit.c (_pthread_exit): : Fix two pthread_mutex_lock() calls that
+ 	should have been pthread_mutex_unlock() calls.
+	(_pthread_vacuum): Remove call to _pthread_destructor_pop_all().
+
+	* create.c (pthread_create): Fix two pthread_mutex_lock() calls that
+ 	should have been pthread_mutex_unlock() calls.
+
+	* global.c (_pthread_tsd_mutex): Add mutex for TSD operations.
+
+	* tsd.c (pthread_key_create): Add critical section.
+	(pthread_setspecific): Ditto.
+	(pthread_getspecific): Ditto.
+	(pthread_key_delete): Ditto.
+
+	* sync.c (pthread_join): Fix two pthread_mutex_lock() calls that
+ 	should have been pthread_mutex_unlock() calls.
+
+Mon Oct 12 00:00:44 1998  Ross Johnson  <rpj@ixobrychus.canberra.edu.au>
+
+	* implement.h (_pthread_tsd_key_table): New.
+
+	* create.c (_pthread_start_call): Initialise per-thread TSD keys
+	to NULL.
+
+	* misc.c (pthread_once): Correct typo in comment.
+
+	* implement.h (_pthread_destructor_push): Remove.
+	(_pthread_destructor_pop): Remove.
+	(_pthread_destructor_run_all): Rename from _pthread_destructor_pop_all.
+	(_PTHREAD_TSD_KEY_DELETED): Add enum.
+	(_PTHREAD_TSD_KEY_INUSE): Add enum.
+
+	* cleanup.c (_pthread_destructor_push): Remove.
+	(_pthread_destructor_pop): Remove.
+	(_pthread_destructor_run_all): Totally revamped TSD.
+
+	* dll.c (_pthread_TSD_keys_TlsIndex): Initialise.
+
+	* tsd.c (pthread_setspecific): Totally revamped TSD.
+	(pthread_getspecific): Ditto.
+	(pthread_create): Ditto.
+	(pthread_delete): Ditto.
+
+Sun Oct 11 22:44:55 1998  Ross Johnson  <rpj@ixobrychus.canberra.edu.au>
+
+	* global.c (_pthread_tsd_key_table): Add new global.
+
+	* implement.h (_pthread_tsd_key_t and struct _pthread_tsd_key):
+	Add.
+	(struct _pthread): Remove destructorstack.
+
+	* cleanup.c (_pthread_destructor_run_all): Rename from
+ 	_pthread_destructor_pop_all. The key destructor stack was made
+ 	global rather than per-thread. No longer removes destructor nodes
+	from the stack. Comments updated.
+
+1998-10-06  Ben Elliston  <bje@cygnus.com>
+
+	* condvar.c (cond_wait): Use POSIX, not Win32 mutex calls.
+	(pthread_cond_broadcast): Likewise.
+	(pthread_cond_signal): Likewise.
+
+1998-10-05  Ben Elliston  <bje@cygnus.com>
+
+	* pthread.def: Update. Some functions aren't available yet, others
+	are macros in <pthread.h>.
+
+	* tests/join.c: Remove; useless.
+
+Mon Oct  5 14:25:08 1998  Ross Johnson  <rpj@ixobrychus.canberra.edu.au>
+
+	* pthread.def: New file for building the DLL.
+
+1998-10-05  Ben Elliston  <bje@cygnus.com>
+
+	* misc.c (pthread_equal): Correct inverted logic bug.
+	(pthread_once): Use the POSIX mutex primitives, not Win32. Remove
+	irrelevant FIXME comment.
+
+	* global.c (PTHREAD_MUTEX_INITIALIZER): Move to pthread.h.
+
+	* pthread.h (PTHREAD_MUTEX_INITIALIZER): Define.
+	(pthread_mutex_t): Reimplement as a struct containing a valid
+	flag. If the flag is ever down upon entry to a mutex operation,
+	we call pthread_mutex_create() to initialise the object. This
+	fixes the problem of how to handle statically initialised objects
+	that can't call InitializeCriticalSection() due to their context.
+	(PTHREAD_ONCE_INIT): Define.
+
+	* mutex.c (pthread_mutex_init): Set valid flag.
+	(pthread_mutex_destroy): Clear valid flag.
+	(pthread_mutex_lock): Check and handle the valid flag.
+	(pthread_mutex_unlock): Likewise.
+	(pthread_mutex_trylock): Likewise.
+
+	* tests/mutex3.c: New file; test for the static initialisation
+	macro. Passes.
+
+	* tests/create1.c: New file; test pthread_create(). Passes.
+	
+	* tests/equal.c: Poor test; remove.
+	
+	* tests/equal1.c New file; test pthread_equal(). Passes.
+
+	* tests/once1.c: New file; test for pthread_once(). Passes.
+
+	* tests/self.c: Remove; rename to self1.c.
+
+	* tests/self1.c: This is the old self.c.
+
+	* tests/self2.c: New file. Test pthread_self() with a single
+	thread. Passes.
+
+	* tests/self3.c: New file. Test pthread_self() with a couple of
+	threads to ensure their thread IDs differ. Passes.
+	
+1998-10-04  Ben Elliston  <bje@cygnus.com>
+
+	* tests/mutex2.c: Test pthread_mutex_trylock(). Passes.
+
+	* tests/mutex1.c: New basic test for mutex functions (it passes).
+	(main): Eliminate warning.
+
+	* configure.in: Test for __stdcall, not _stdcall. Typo.
+
+	* configure: Regenerate.
+
+	* attr.c (pthread_attr_setstackaddr): Remove FIXME comment. Win32
+	does know about ENOSYS after all.
+	(pthread_attr_setstackaddr): Likewise.
+
+1998-10-03  Ben Elliston  <bje@cygnus.com>
+
+	* configure.in: Test for the `_stdcall' keyword.  Define `STDCALL'
+	to `_stdcall' if we have it, null otherwise.
+
+	* configure: Regenerate.
+
+	* acconfig.h (STDCALL): New define.
+
+	* config.h.in: Regenerate.
+
+	* create.c (_pthread_start_call): Add STDCALL prefix.
+	
+	* mutex.c (pthread_mutex_init): Correct function signature.
+
+	* attr.c (pthread_attr_init): Only zero out the `sigmask' member
+	if we have the sigset_t type.
+
+	* pthread.h: No need to include <unistd.h>.  It doesn't even exist
+	on Win32! Again, an artifact of cross-compilation.	
+	(pthread_sigmask): Only provide if we have the sigset_t type.
+
+	* process.h: Remove. This was a stand-in before we started doing
+	native compilation under Win32.
+
+	* pthread.h (pthread_mutex_init): Make `attr' argument const.
+
+1998-10-02  Ben Elliston  <bje@cygnus.com>
+
+	* COPYING: Remove.
+
+	* COPYING.LIB: Add. This library is under the LGPL.
+
+1998-09-13  Ben Elliston  <bje@cygnus.com>
+
+	* configure.in: Test for required system features.
+
+	* configure: Generate. 
+
+	* acconfig.h: New file.
+
+	* config.h.in: Generate.
+
+	* Makefile.in: Renamed from Makefile.
+
+	* COPYING: Import from a recent GNU package.
+
+	* config.guess: Likewise.
+
+	* config.sub: Likewise.
+
+	* install-sh: Likewise.
+
+	* config.h: Remove.  
+
+	* Makefile: Likewise.
+
+1998-09-12  Ben Elliston  <bje@cygnus.com>
+
+	* windows.h: No longer needed; remove.
+
+	* windows.c: Likewise.
+
+Sat Sep 12 20:09:24 1998  Ross Johnson  <rpj@ixobrychus.canberra.edu.au>
+
+	* windows.h: Remove error number definitions. These are in <errno.h>
+	
+	* tsd.c: Add comment explaining rationale for not building
+	POSIX TSD on top of Win32 TLS.
+
+1998-09-12  Ben Elliston  <bje@cygnus.com>
+
+	* {most}.c: Include <errno.h> to get POSIX error values.
+
+	* signal.c (pthread_sigmask): Only provide if HAVE_SIGSET_T is
+	defined.
+ 
+	* config.h: #undef features, don't #define them.  This will be
+	generated by autoconf very soon.
+	
+1998-08-11  Ben Elliston  <bje@cygnus.com>
+
+	* Makefile (LIB): Define.
+	(clean): Define target.
+	(all): Build a library not just the object files.
+
+	* pthread.h: Provide a definition for struct timespec if we don't
+	already have one.
+
+	* windows.c (TlsGetValue): Bug fix.
+	
+Thu Aug  6 15:19:22 1998  Ross Johnson  <rpj@swan.canberra.edu.au>
+
+	* misc.c (pthread_once): Fix arg 1 of EnterCriticalSection()
+ 	and LeaveCriticalSection() calls to pass address-of lock.
+
+	* fork.c (pthread_atfork): Typecast (void (*)(void *)) funcptr
+	in each _pthread_handler_push() call.
+
+	* exit.c (_pthread_exit): Fix attr arg in 
+	pthread_attr_getdetachstate() call.
+
+	* private.c (_pthread_new_thread): Typecast (HANDLE) NULL.
+	(_pthread_delete_thread): Ditto.
+
+	* implement.h: (_PTHREAD_MAX_THREADS): Add define. This keeps
+	changing in an attempt to make thread administration data types
+	opaque and cleanup DLL startup.
+
+	* dll.c (PthreadsEntryPoint): 
+	(_pthread_virgins): Remove malloc() and free() calls.
+	(_pthread_reuse): Ditto.
+	(_pthread_win32handle_map): Ditto.
+	(_pthread_threads_mutex_table): Ditto.
+
+	* global.c (_POSIX_THREAD_THREADS_MAX): Initialise with 
+	_PTHREAD_MAX_THREADS.
+	(_pthread_virgins): Ditto.
+	(_pthread_reuse): Ditto.
+	(_pthread_win32handle_map): Ditto.
+	(_pthread_threads_mutex_table): Ditto.
+
+	* create.c (pthread_create): Typecast (HANDLE) NULL.
+	Typecast (unsigned (*)(void *)) start_routine.
+
+	* condvar.c (pthread_cond_init): Add address-of operator & to
+	arg 1 of pthread_mutex_init() call.
+	(pthread_cond_destroy): Add address-of operator & to
+	arg 1 of pthread_mutex_destroy() call. 
+
+	* cleanup.c (_pthread_destructor_pop_all): Add (int) cast to 
+	pthread_getspecific() arg.
+	(_pthread_destructor_pop): Add (void *) cast to "if" conditional.
+	(_pthread_destructor_push): Add (void *) cast to
+	_pthread_handler_push() "key" arg.
+	(malloc.h): Add include.
+
+	* implement.h (_pthread_destructor_pop): Add prototype.
+
+	* tsd.c (implement.h): Add include.
+
+	* sync.c (pthread_join): Remove target_thread_mutex and it's
+	initialisation. Rename getdetachedstate to getdetachstate.
+	Remove unused variable "exitcode".
+	(pthread_detach): Remove target_thread_mutex and it's
+	initialisation. Rename getdetachedstate to getdetachstate.
+	Rename setdetachedstate to setdetachstate.
+
+	* signal.c (pthread_sigmask): Rename SIG_SET to SIG_SETMASK.
+	Cast "set" to (long *) in assignment to passify compiler warning.
+	Add address-of operator & to thread->attr.sigmask in memcpy() call
+	and assignment.
+	(pthread_sigmask): Add address-of operator & to thread->attr.sigmask
+	in memcpy() call and assignment.
+
+	* windows.h (THREAD_PRIORITY_ERROR_RETURN): Add.
+	(THREAD_PRIORITY_LOWEST): Add.
+	(THREAD_PRIORITY_HIGHEST): Add.
+
+	* sched.c (is_attr): Add function.
+	(implement.h): Add include.
+	(pthread_setschedparam): Rename all instances of "sched_policy"
+	to "sched_priority".
+	(pthread_getschedparam): Ditto.
+
+Tue Aug  4 16:57:58 1998  Ross Johnson  <rpj@swan.canberra.edu.au>
+
+	* private.c (_pthread_delete_thread): Fix typo. Add missing ';'.
+
+	* global.c (_pthread_virgins): Change types from pointer to 
+	array pointer.
+	(_pthread_reuse): Ditto.
+	(_pthread_win32handle_map): Ditto.
+	(_pthread_threads_mutex_table): Ditto.
+
+	* implement.h(_pthread_virgins): Change types from pointer to 
+	array pointer.
+	(_pthread_reuse): Ditto.
+	(_pthread_win32handle_map): Ditto.
+	(_pthread_threads_mutex_table): Ditto.
+
+	* private.c (_pthread_delete_thread): Fix "entry" should be "thread".
+
+	* misc.c (pthread_self): Add extern for _pthread_threadID_TlsIndex.
+
+	* global.c: Add comment.
+
+	* misc.c (pthread_once): Fix member -> dereferences.
+	Change _pthread_once_flag to once_control->flag in "if" test.
+
+Tue Aug  4 00:09:30 1998  Ross Johnson  <rpj@ixobrychus.canberra.edu.au>
+
+	* implement.h(_pthread_virgins): Add extern.
+	(_pthread_virgin_next): Ditto.
+	(_pthread_reuse): Ditto.
+	(_pthread_reuse_top): Ditto.
+	(_pthread_win32handle_map): Ditto.
+	(_pthread_threads_mutex_table): Ditto.
+
+	* global.c (_pthread_virgins): Changed from array to pointer.
+	Storage allocation for the array moved into dll.c.
+	(_pthread_reuse): Ditto.
+	(_pthread_win32handle_map): Ditto.
+	(_pthread_threads_mutex_table): Ditto.
+
+	* dll.c (PthreadsEntryPoint): Set up thread admin storage when
+	DLL is loaded.
+
+	* fork.c (pthread_atfork): Fix function pointer arg to all
+	_pthread_handler_push() calls. Change "arg" arg to NULL in child push.
+
+	* exit.c: Add windows.h and process.h includes.
+	(_pthread_exit): Add local detachstate declaration.
+	(_pthread_exit): Fix incorrect name for pthread_attr_getdetachstate().
+
+	* pthread.h (_POSIX_THREAD_ATTR_STACKSIZE): Move from global.c
+	(_POSIX_THREAD_ATTR_STACKADDR): Ditto.
+
+	* create.c (pthread_create): Fix #if should be #ifdef.
+	(_pthread_start_call): Remove usused variables.
+
+	* process.h: Create.
+
+	* windows.h: Move _beginthreadex and _endthreadex into
+	process.h
+
+Mon Aug  3 21:19:57 1998  Ross Johnson  <rpj@ixobrychus.canberra.edu.au>
+
+	* condvar.c (pthread_cond_init): Add NULL attr to
+	pthread_mutex_init() call - default attributes will be used.
+	(cond_wait): Fix typo.
+	(cond_wait): Fix typo - cv was ev.
+	(pthread_cond_broadcast): Fix two identical typos.
+
+	* cleanup.c (_pthread_destructor_pop_all): Remove _ prefix from
+	PTHREAD_DESTRUCTOR_ITERATIONS.
+
+	* pthread.h: Move _POSIX_* values into posix.h
+
+	* pthread.h: Fix typo in pthread_mutex_init() prototype.
+
+	* attr.c (pthread_attr_init): Fix error in priority member init.
+
+	* windows.h (THREAD_PRIORITY_NORMAL): Add.
+
+	* pthread.h (sched_param): Add missing ';' to struct definition. 
+
+	* attr.c (pthread_attr_init): Remove obsolete pthread_attr_t
+	member initialisation - cancelstate, canceltype, cancel_pending.
+	(is_attr): Make arg "attr" a const.
+
+	* implement.h (_PTHREAD_HANDLER_POP_LIFO): Remove definition.
+	(_PTHREAD_HANDLER_POP_FIFO): Ditto.
+	(_PTHREAD_VALID): Add missing newline escape (\).
+	(_pthread_handler_node): Make element "next" a pointer.
+
+1998-08-02  Ben Elliston  <bje@cygnus.com>
+
+	* windows.h: Remove duplicate TlsSetValue() prototype.  Add 
+	TlsGetValue() prototype.
+	(FALSE): Define.
+	(TRUE): Likewise.
+	Add forgotten errno values.  Guard against multiple #includes.
+
+	* windows.c: New file.  Implement stubs for Win32 functions.
+
+	* Makefile (SRCS): Remove.  Not explicitly needed.
+	(CFLAGS): Add -Wall for all warnings with GCC.
+
+Sun Aug  2 19:03:42 1998  Ross Johnson  <rpj@ixobrychus.canberra.edu.au>
+
+	* config.h: Create. This is a temporary stand-in for autoconf yet
+	to be done.
+ 	(HAVE_SIGNAL_H): Add.
+
+	* pthread.h: Minor rearrangement for temporary config.h.
+
+Fri Jul 31 14:00:29 1998  Ross Johnson  <rpj@swan.canberra.edu.au>
+
+	* cleanup.c (_pthread_destructor_pop): Implement. Removes
+	destructors associated with a key without executing them.
+	(_pthread_destructor_pop_all): Add FIXME comment.
+
+	* tsd.c (pthread_key_delete): Add call to _pthread_destructor_pop().
+
+Fri Jul 31 00:05:45 1998  Ross Johnson  <rpj@ixobrychus.canberra.edu.au>
+
+	* tsd.c (pthread_key_create): Update to properly associate
+	the destructor routine with the key.
+	(pthread_key_delete): Add FIXME comment.
+
+	* exit.c (_pthread_vacuum): Add call to
+	_pthread_destructor_pop_all().
+
+	* implement.h (_pthread_handler_pop_all): Add prototype.
+	(_pthread_destructor_pop_all): Ditto.
+
+	* cleanup.c (_pthread_destructor_push): Implement. This is just a
+	call to _pthread_handler_push().
+	(_pthread_destructor_pop_all): Implement. This is significantly
+	different to _pthread_handler_pop_all().
+
+	* Makefile (SRCS): Create. Preliminary.
+
+	* windows.h: Create. Contains Win32 definitions for compile
+	testing. This is just a standin for the real one.
+
+	* pthread.h (SIG_UNBLOCK): Fix typo. Was SIG_BLOCK.
+	(windows.h): Add include. Required for CRITICAL_SECTION.
+	(pthread_cond_t): Move enum declaration outside of struct
+	definition.
+	(unistd.h): Add include - may be temporary.
+
+	* condvar.c (windows.h): Add include.
+
+	* implement.h (_PTHREAD_THIS): Remove - no longer required.
+	(_PTHREAD_STACK): Use pthread_self() instead of _PTHREAD_THIS.
+
+Thu Jul 30 23:12:45 1998  Ross Johnson  <rpj@ixobrychus.canberra.edu.au>
+
+	* implement.h: Remove _pthread_find_entry() prototype.
+
+	* private.c: Extend comments.
+	Remove _pthread_find_entry() - no longer needed.
+
+	* create.c (_pthread_start_call): Add call to TlsSetValue() to
+	store the thread ID.
+
+	* dll.c (PthreadsEntryPoint): Implement. This is called
+	whenever a process loads the DLL. Used to initialise thread
+	local storage.
+
+	* implement.h: Add _pthread_threadID_TlsIndex.
+	Add ()s around _PTHREAD_VALID expression.
+
+	* misc.c (pthread_self): Re-implement using Win32 TLS to store
+	the threads own ID.
+
+Wed Jul 29 11:39:03 1998  Ross Johnson  <rpj@ixobrychus.canberra.edu.au>
+
+	* private.c: Corrections in comments.
+	(_pthread_new_thread): Alter "if" flow to be more natural.
+
+	* cleanup.c (_pthread_handler_push): Same as below.
+
+	* create.c (pthread_create): Same as below.
+
+	* private.c (_pthread_new_thread): Rename "new" to "new_thread".
+	Since when has a C programmer been required to know C++?
+
+Tue Jul 28 14:04:29 1998  Ross Johnson  <rpj@swan.canberra.edu.au>
+
+	* implement.h: Add _PTHREAD_VALID macro.
+
+	* sync.c (pthread_join): Modify to use the new thread
+	type and _pthread_delete_thread(). Rename "target" to "thread".
+	Remove extra local variable "target".
+	(pthread_detach): Ditto.
+
+	* signal.c (pthread_sigmask): Move init of "us" out of inner block.
+	Fix instance of "this" should have been "us". Rename "us" to "thread".
+
+	* sched.c (pthread_setschedparam): Modify to use the new thread
+	type.
+	(pthread_getschedparam): Ditto.
+
+	* private.c (_pthread_find_thread): Fix return type and arg.
+
+	* implement.h: Remove _PTHREAD_YES and _PTHREAD_NO.
+	(_pthread_new_thread): Add prototype.
+	(_pthread_find_thread): Ditto.
+	(_pthread_delete_thread): Ditto.
+	(_pthread_new_thread_entry): Remove prototype.
+	(_pthread_find_thread_entry): Ditto.
+	(_pthread_delete_thread_entry): Ditto.
+	(  _PTHREAD_NEW, _PTHREAD_INUSE, _PTHREAD_EXITED, _PTHREAD_REUSE):
+	Add.
+
+
+	* create.c (pthread_create): Minor rename "us" to "new" (I need
+	these cues but it doesn't stop me coming out with some major bugs
+	at times).
+	Load start_routine and arg into the thread so the wrapper can
+	call it.
+
+	* exit.c (pthread_exit): Fix pthread_this should be pthread_self.
+
+	* cancel.c (pthread_setcancelstate): Change
+ 	_pthread_threads_thread_t * to pthread_t and init with
+ 	pthread_this().
+	(pthread_setcanceltype): Ditto.
+
+	* exit.c (_pthread_exit): Add new pthread_t arg.
+	Rename _pthread_delete_thread_entry to _pthread_delete_thread.
+	Rename "us" to "thread".
+	(pthread_exit): Call _pthread_exit with added thread arg.
+
+	* create.c (_pthread_start_call): Insert missing ")".
+	Add "us" arg to _pthread_exit() call.
+	(pthread_create): Modify to use new thread allocation scheme.
+
+	* private.c: Added detailed explanation of the new thread
+	allocation scheme.
+	(_pthread_new_thread): Totally rewritten to use
+	new thread allocation scheme.
+	(_pthread_delete_thread): Ditto.
+	(_pthread_find_thread): Obsolete.
+
+Mon Jul 27 17:46:37 1998  Ross Johnson  <rpj@swan.canberra.edu.au>
+
+	* create.c (pthread_create): Start of rewrite. Not completed yet.
+
+	* private.c (_pthread_new_thread_entry): Start of rewrite. Not
+	complete.
+
+	* implement.h (_pthread_threads_thread): Rename, remove thread
+	member, add win32handle and ptstatus members.
+	(_pthread_t): Add.
+
+	* pthread.h: pthread_t is no longer mapped directly to a Win32
+	HANDLE type. This is so we can let the Win32 thread terminate and
+	reuse the HANDLE while pthreads holds it's own thread ID until
+	the last waiting join exits.
+
+Mon Jul 27 00:20:37 1998  Ross Johnson  <rpj@ixobrychus.canberra.edu.au>
+
+	* private.c (_pthread_delete_thread_entry): Destroy the thread
+ 	entry attribute object before deleting the thread entry itself.
+
+	* attr.c (pthread_attr_init): Initialise cancel_pending = FALSE.
+	(pthread_attr_setdetachstate): Rename "detached" to "detachedstate".
+	(pthread_attr_getdetachstate): Ditto.
+
+	* exit.c (_pthread_exit): Fix incorrect check for detachedstate.
+
+	* implement.h (_pthread_call_t): Remove env member. 
+
+Sun Jul 26 13:06:12 1998  Ross Johnson  <rpj@ixobrychus.canberra.edu.au>
+
+	* implement.h (_pthread_new_thread_entry): Fix prototype.
+	(_pthread_find_thread_entry): Ditto.
+	(_pthread_delete_thread_entry): Ditto.
+	(_pthread_exit): Add prototype.
+
+	* exit.c (_pthread_exit): New function. Called from pthread_exit()
+	and _pthread_start_call() to exit the thread. It allows an extra
+	argument which is the return code passed to _endthreadex().
+	(_pthread_exit): Move thread entry delete call from _pthread_vacuum()
+	into here. Add more explanation of thread entry deletion.
+	(_pthread_exit): Clarify comment.
+
+	* create.c (_pthread_start_call): Change pthread_exit() call to
+	_pthread_exit() call.
+
+	* exit.c (_pthread_vacuum): Add thread entry deletion code
+	moved from _pthread_start_call(). See next item.
+	(pthread_exit): Remove longjmp(). Add mutex lock around thread table
+	manipulation code. This routine now calls _enthreadex().
+
+	* create.c (_pthread_start_call): Remove setjmp() call and move
+	cleanup code out. Call pthread_exit(NULL) to terminate the thread.
+
+1998-07-26  Ben Elliston  <bje@cygnus.com>
+
+	* tsd.c (pthread_getspecific): Update comments.
+
+	* mutex.c (pthread_mutexattr_setpshared): Not supported; remove.
+	(pthread_mutexattr_getpshared): Likewise.
+
+	* pthread.h (pthread_mutexattr_setpshared): Remove prototype.
+	(pthread_mutexattr_getpshared): Likewise.
+
+Sun Jul 26 00:09:59 1998  Ross Johnson  <rpj@ixobrychus.canberra.edu.au>
+
+	* sync.c: Rename all instances of _pthread_count_mutex to
+	_pthread_table_mutex.
+
+	* implement.h: Rename _pthread_count_mutex to
+	_pthread_table_mutex.
+
+	* global.c: Rename _pthread_count_mutex to
+	_pthread_table_mutex.
+
+	* create.c (pthread_create): Add critical sections.
+	(_pthread_start_call): Rename _pthread_count_mutex to
+	_pthread_table_mutex.
+
+	* cancel.c (pthread_setcancelstate): Fix indirection bug and rename
+	"this" to "us".
+
+	* signal.c (pthread_sigmask): Rename "this" to "us" and fix some
+	minor syntax errors. Declare "us" and initialise it.
+
+	* sync.c (pthread_detach): Rename "this" to "target".
+
+	* pthread.h: Converting PTHREAD_* defines to alias the (const int)
+	values in global.c.
+
+	* global.c: Started converting PTHREAD_* defines to (const int) as
+ 	a part of making the eventual pthreads DLL binary compatible
+ 	through version changes.
+
+	* condvar.c (cond_wait): Add cancelation point. This applies the
+	point to both pthread_cond_wait() and pthread_cond_timedwait().
+
+	* exit.c (pthread_exit): Rename "this" to "us".
+
+	* implement.h: Add comment.
+
+	* sync.c (pthread_join): I've satisfied myself that pthread_detach()
+	does set the detached attribute in the thread entry attributes
+	to PTHREAD_CREATE_DETACHED. "if" conditions were changed to test
+	that attribute instead of a separate flag.
+
+	* create.c (pthread_create): Rename "this" to "us".
+	(pthread_create): cancelstate and canceltype are not attributes
+	so the copy to thread entry attribute storage was removed.
+	Only the thread itself can change it's cancelstate or canceltype,
+	ie. the thread must exist already.
+
+	* private.c (_pthread_delete_thread_entry): Mutex locks removed.
+	Mutexes must be applied at the caller level.
+	(_pthread_new_thread_entry): Ditto.
+	(_pthread_new_thread_entry): Init cancelstate, canceltype, and
+	cancel_pending to default values.
+	(_pthread_new_thread_entry): Rename "this" to "new".
+	(_pthread_find_thread_entry): Rename "this" to "entry".
+	(_pthread_delete_thread_entry): Rename "thread_entry" to "entry".
+
+	* create.c (_pthread_start_call): Mutexes changed to
+	_pthread_count_mutex. All access to the threads table entries is
+	under the one mutex. Otherwise chaos reigns.
+
+Sat Jul 25 23:16:51 1998  Ross Johnson  <rpj@ixobrychus.canberra.edu.au>
+
+	* implement.h (_pthread_threads_thread): Move cancelstate and
+ 	canceltype members out of pthread_attr_t into here.
+
+	* fork.c (fork): Add comment.
+
+1998-07-25  Ben Elliston  <bje@cygnus.com>
+
+	* fork.c (fork): Autoconfiscate.
+
+Sat Jul 25 00:00:13 1998  Ross Johnson  <rpj@ixobrychus.canberra.edu.au>
+
+	* create.c (_pthread_start_call): Set thread priority.  Ensure our
+ 	thread entry is removed from the thread table but only if
+ 	pthread_detach() was called and there are no waiting joins.
+	(pthread_create): Set detach flag in thread entry if the 
+	thread is created PTHREAD_CREATE_DETACHED.
+
+	* pthread.h (pthread_attr_t): Rename member "detachedstate".
+
+	* attr.c (pthread_attr_init): Rename attr members.
+
+	* exit.c (pthread_exit): Fix indirection mistake.
+
+	* implement.h (_PTHREAD_THREADS_TABLE_INDEX): Add.
+
+	* exit.c (_pthread_vacuum): Fix incorrect args to
+	_pthread_handler_pop_all() calls.
+	Make thread entry removal conditional.
+
+	* sync.c (pthread_join): Add multiple join and async detach handling.
+
+	* implement.h (_PTHREAD_THREADS_TABLE_INDEX): Add.
+
+	* global.c (_pthread_threads_mutex_table): Add.
+
+	* implement.h (_pthread_once_flag): Remove.
+	(_pthread_once_lock): Ditto.
+	(_pthread_threads_mutex_table): Add.
+
+	* global.c (_pthread_once_flag): Remove.
+	(_pthread_once_lock): Ditto.
+
+	* sync.c (pthread_join): Fix tests involving new return value
+	from _pthread_find_thread_entry().
+	(pthread_detach): Ditto.
+
+	* private.c (_pthread_find_thread_entry): Failure return code
+	changed from -1 to NULL.
+
+Fri Jul 24 23:09:33 1998  Ross Johnson  <rpj@ixobrychus.canberra.edu.au>
+
+	* create.c (pthread_create): Change . to -> in sigmask memcpy() args.
+
+	* pthread.h: (pthread_cancel): Add function prototype.
+	(pthread_testcancel): Ditto.
+
+1998-07-24  Ben Elliston  <bje@cygnus.com>
+
+	* pthread.h (pthread_condattr_t): Rename dummy structure member.
+	(pthread_mutexattr_t): Likewise.
+
+Fri Jul 24 21:13:55 1998  Ross Johnson  <rpj@ixobrychus.canberra.edu.au>
+
+	* cancel.c (pthread_cancel): Implement.
+	(pthread_testcancel): Implement.
+
+	* exit.c (pthread_exit): Add comment explaining the longjmp().
+
+	* implement.h (_pthread_threads_thread_t): New member cancelthread.
+	(_PTHREAD_YES): Define.
+	(_PTHREAD_NO): Define.
+	(RND_SIZEOF): Remove.
+
+	* create.c (pthread_create): Rename cancelability to cancelstate.
+
+	* pthread.h (pthread_attr_t): Rename cancelability to cancelstate.
+	(PTHREAD_CANCELED): Define.
+
+1998-07-24  Ben Elliston  <bje@cygnus.com>
+
+	* pthread.h (SIG_BLOCK): Define if not already defined.
+	(SIG_UNBLOCK): Likewise.
+	(SIG_SETMASK): Likewise.
+	(pthread_attr_t): Add signal mask member.
+	(pthread_sigmask): Add function prototype.
+
+	* signal.c (pthread_sigmask): Implement.
+
+	* create.c: #include <string.h> to get a prototype for memcpy().
+	(pthread_create): New threads inherit their creator's signal
+	mask.  Copy the signal mask to the new thread structure if we know
+	about signals.
+	
+Fri Jul 24 16:33:17 1998  Ross Johnson  <rpj@swan.canberra.edu.au>
+
+	* fork.c (pthread_atfork): Add all the necessary push calls.
+	Local implementation semantics:
+	If we get an ENOMEM at any time then ALL handlers
+	(including those from previous pthread_atfork() calls) will be
+	popped off each of the three atfork stacks before we return.
+	(fork): Add all the necessary pop calls. Add the thread cancellation
+	and join calls to the child fork.
+	Add #includes.
+
+	* implement.h: (_pthread_handler_push): Fix return type and stack arg
+	type in prototype.
+	(_pthread_handler_pop): Fix stack arg type in prototype.
+	(_pthread_handler_pop_all): Fix stack arg type in prototype.
+
+	* cleanup.c (_pthread_handler_push): Change return type to int and
+	return ENOMEM if malloc() fails.
+
+	* sync.c (pthread_detach): Use equality test, not assignment.
+
+	* create.c (_pthread_start_call): Add call to Win32 CloseHandle()
+	if thread is detached.
+
+1998-07-24  Ben Elliston  <bje@cygnus.com>
+
+	* sync.c (pthread_detach): Close the Win32 thread handle to
+	emulate detached (or daemon) threads.
+
+Fri Jul 24 03:00:25 1998  Ross Johnson  <rpj@ixobrychus.canberra.edu.au>
+
+	* sync.c (pthread_join): Save valueptr arg in joinvalueptr for
+	pthread_exit() to use.
+
+	* private.c (_pthread_new_thread_entry): Initialise joinvalueptr to
+	NULL.
+
+	* create.c (_pthread_start_call): Rewrite to facilitate joins.
+	pthread_exit() will do a longjmp() back to here. Does appropriate
+	cleanup and exit/return from the thread.
+	(pthread_create): _beginthreadex() now passes a pointer to our
+	thread table entry instead of just the call member of that entry.
+
+	* implement.h (_pthread_threads_thread): New member 
+	void ** joinvalueptr.
+	(_pthread_call_t): New member jmpbuf env.
+
+	* exit.c (pthread_exit): Major rewrite to handle joins and handing
+	value pointer to joining thread. Uses longjmp() back to 
+	_pthread_start_call().
+
+	* create.c (pthread_create): Ensure values of new attribute members
+	are copied to the thread attribute object.
+
+	* attr.c (pthread_attr_destroy):  Fix merge conflicts.
+	(pthread_attr_getdetachstate):  Fix merge conflicts.
+	(pthread_attr_setdetachstate):  Fix merge conflicts.
+
+	* pthread.h:  Fix merge conflicts.
+
+	* sync.c (pthread_join): Fix merge conflicts.
+
+Fri Jul 24 00:21:21 1998  Ross Johnson  <rpj@ixobrychus.canberra.edu.au>
+
+	* sync.c (pthread_join): Add check for valid and joinable
+	thread.
+	(pthread_detach): Implement. After checking for a valid and joinable
+	thread, it's still a no-op.
+
+	* private.c (_pthread_find_thread_entry): Bug prevented returning
+	an error value in some cases.
+
+	* attr.c (pthread_attr_setdetachedstate): Implement.
+	(pthread_attr_getdetachedstate): Implement.
+
+	* implement.h: Move more hidden definitions into here from
+	pthread.h.
+
+1998-07-24  Ben Elliston  <bje@cygnus.com>
+
+	* pthread.h (PTHREAD_CREATE_JOINABLE): Define.
+	(PTHREAD_CREATE_DETACHED): Likewise.
+	(pthread_attr_t): Add new structure member `detached'.
+	(pthread_attr_getdetachstate): Add function prototype.
+	(pthread_attr_setdetachstate): Likewise.
+
+	* sync.c (pthread_join): Return if the target thread is detached.
+
+	* attr.c (pthread_attr_init): Initialise cancelability and
+	canceltype structure members.
+	(pthread_attr_getdetachstate): Implement.
+	(pthread_attr_setdetachstate): Likewise.
+
+	* implement.h (_PTHREAD_CANCEL_DEFAULTS): Remove.  Bit fields
+	proved to be too cumbersome.  Set the defaults in attr.c using the
+	public PTHREAD_CANCEL_* constants.
+
+	* cancel.c: New file.
+
+	* pthread.h (sched_param): Define this type.
+	(pthread_attr_getschedparam): Add function prototype.
+	(pthread_attr_setschedparam): Likewise.
+	(pthread_setcancelstate): Likewise.
+	(pthread_setcanceltype): Likewise.
+	(sched_get_priority_min): Likewise.
+	(sched_get_priority_max): Likewise.
+	(pthread_mutexattr_setprotocol): Remove; not supported.
+	(pthread_mutexattr_getprotocol): Likewise.
+	(pthread_mutexattr_setprioceiling): Likewise.
+	(pthread_mutexattr_getprioceiling): Likewise.
+	(pthread_attr_t): Add canceltype member.  Update comments.
+	(SCHED_OTHER): Define this scheduling policy constant.
+	(SCHED_FIFO): Likewise.
+	(SCHED_RR): Likewise.
+	(SCHED_MIN): Define the lowest possible value for this constant.
+	(SCHED_MAX): Likewise, the maximum possible value.
+	(PTHREAD_CANCEL_ASYNCHRONOUS): Redefine.
+	(PTHREAD_CANCEL_DEFERRED): Likewise.
+	
+	* sched.c: New file.
+	(pthread_setschedparam): Implement.
+	(pthread_getschedparam): Implement.
+	(sched_get_priority_max): Validate policy argument.
+	(sched_get_priority_min): Likewise.
+
+	* mutex.c (pthread_mutexattr_setprotocol): Remove; not supported.
+	(pthread_mutexattr_getprotocol): Likewise.
+	(pthread_mutexattr_setprioceiling): Likewise.
+	(pthread_mutexattr_getprioceiling): Likewise.
+
+Fri Jul 24 00:21:21 1998  Ross Johnson  <rpj@ixobrychus.canberra.edu.au>
+
+	* create.c (pthread_create): Arg to _pthread_new_thread_entry()
+	changed. See next entry. Move mutex locks out. Changes made yesterday
+	and today allow us to start the new thread running rather than
+	temporarily suspended.
+
+	* private.c (_pthread_new_thread_entry): _pthread_thread_table
+	was changed back to a table of thread structures rather than pointers.
+	As such we're trading storage for increaded speed. This routine
+	was modified to work with the new table. Mutex lock put in around
+	global data accesses.
+	(_pthread_find_thread_entry): Ditto
+	(_pthread_delete_thread_entry): Ditto
+
+Thu Jul 23 23:25:30 1998  Ross Johnson  <rpj@ixobrychus.canberra.edu.au>
+
+	* global.c: New. Global data objects declared here. These moved from
+	pthread.h.
+
+	* pthread.h: Move implementation hidden definitions into
+	implement.h.
+
+	* implement.h: Move implementation hidden definitions from
+	pthread.h. Add constants to index into the different handler stacks.
+
+	* cleanup.c (_pthread_handler_push): Simplify args. Restructure.
+	(_pthread_handler_pop): Simplify args. Restructure.
+	(_pthread_handler_pop_all): Simplify args. Restructure.
+
+Wed Jul 22 00:16:22 1998  Ross Johnson  <rpj@ixobrychus.canberra.edu.au>
+
+	* attr.c, implement.h, pthread.h, ChangeLog: Resolve CVS merge
+	conflicts.
+
+	* private.c (_pthread_find_thread_entry): Changes to return type
+	to support leaner _pthread_threads_table[] which now only stores
+	_pthread_thread_thread_t *.
+	(_pthread_new_thread_entry): Internal changes.
+	(_pthread_delete_thread_entry): Internal changes to avoid contention.
+ 	Calling routines changed accordingly.
+
+	* pthread.h: Modified cleanup macros to use new generic push and pop.
+	Added destructor and atfork stacks to _pthread_threads_thread_t.
+
+	* cleanup.c (_pthread_handler_push, _pthread_handler_pop,
+	_pthread_handler_pop_all): Renamed cleanup push and pop routines
+	and made generic to handle destructors and atfork handlers as
+	well.
+
+	* create.c (_pthread_start_call): New function is a wrapper for
+	all new threads. It allows us to do some cleanup when the thread
+	returns, ie. that is otherwise only done if the thread is cancelled.
+
+	* exit.c (_pthread_vacuum): New function contains code from 
+	pthread_exit() that we need in the new _pthread_start_call()
+	as well.
+
+	* implement.h: Various additions and minor changes.
+
+	* pthread.h: Various additions and minor changes.
+	Change cleanup handler macros to use generic handler push and pop
+	functions.
+
+	* attr.c: Minor mods to all functions.
+	(is_attr): Implemented missing function.
+
+	* create.c (pthread_create): More clean up.
+
+	* private.c (_pthread_find_thread_entry): Implement.
+	(_pthread_delete_thread_entry): Implement.
+	(_pthread_new_thread_entry): Implement.
+	These functions manipulate the implementations internal thread
+	table and are part of general code cleanup and modularisation.
+	They replace _pthread_getthreadindex() which was removed.
+
+	* exit.c (pthread_exit): Changed to use the new code above.
+
+	* pthread.h: Add cancelability constants. Update comments.
+
+1998-07-22  Ben Elliston  <bje@cygnus.com>
+
+	* attr.c (pthread_setstacksize): Update test of attr argument.
+	(pthread_getstacksize): Likewise.
+	(pthread_setstackaddr): Likewise.
+	(pthread_getstackaddr): Likewise.
+	(pthread_attr_init): No need to allocate any storage.
+	(pthread_attr_destroy): No need to free any storage.
+
+	* mutex.c (is_attr): Not likely to be needed; remove.
+	(remove_attr): Likewise.
+	(insert_attr): Likewise.
+
+	* implement.h (_pthread_mutexattr_t): Moved to a public definition
+	in pthread.h.  There was little gain in hiding these details.
+	(_pthread_condattr_t): Likewise.
+	(_pthread_attr_t): Likewise.
+
+	* pthread.h (pthread_atfork): Add function prototype.
+	(pthread_attr_t): Moved here from implement.h.
+
+	* fork.c (pthread_atfork): Preliminary implementation.
+	(_pthread_fork): Likewise.
+
+Wed Jul 22 00:16:22 1998  Ross Johnson  <rpj@ixobrychus.canberra.edu.au>
+
+	* cleanup.c (_pthread_cleanup_push): Implement.
+	(_pthread_cleanup_pop): Implement.
+	(_pthread_do_cancellation): Implement.
+	These are private to the implementation. The real cleanup functions
+	are macros. See below.
+
+	* pthread.h (pthread_cleanup_push): Implement as a macro.
+	(pthread_cleanup_pop): Implement as a macro.
+	Because these are macros which start and end a block, the POSIX scoping
+	requirement is observed. See the comment in the file.
+
+	* exit.c (pthread_exit): Refine the code.
+
+	* create.c (pthread_create): Code cleanup.
+
+	* implement.h (RND_SIZEOF): Add RND_SIZEOF(T) to round sizeof(T)
+	up to multiple of DWORD.
+	Add function prototypes.
+
+	* private.c (_pthread_getthreadindex): "*thread" should have been 
+	"thread". Detect empty slot fail condition.
+
+1998-07-20  Ben Elliston  <bje@cygnus.com>
+
+	* misc.c (pthread_once): Implement.  Don't use a per-application
+	flag and mutex--make `pthread_once_t' contain these elements in
+	their structure.  The earlier version had incorrect semantics.
+	
+	* pthread.h (_pthread_once_flag): Add new variable.  Remove.
+	(_pthread_once_lock): Add new mutex lock to ensure integrity of
+	access to _pthread_once_flag.  Remove.
+	(pthread_once): Add function prototype.
+	(pthread_once_t): Define this type.
+	
+Mon Jul 20 02:31:05 1998  Ross Johnson  <rpj@ixobrychus.canberra.edu.au>
+
+	* private.c (_pthread_getthreadindex): Implement.
+
+	* pthread.h: Add application static data dependent on
+	_PTHREADS_BUILD_DLL define. This is needed to avoid allocating
+	non-sharable static data within the pthread DLL.
+
+	* implement.h: Add _pthread_cleanup_stack_t, _pthread_cleanup_node_t
+	and _PTHREAD_HASH_INDEX.
+
+	* exit.c (pthread_exit): Begin work on cleanup and de-allocate
+	thread-private storage.
+
+	* create.c (pthread_create): Add thread to thread table.
+	Keep a thread-private copy of the attributes with default values
+	filled in when necessary. Same for the cleanup stack. Make 
+	pthread_create C run-time library friendly by using _beginthreadex()
+	instead of CreateThread(). Fix error returns.
+
+Sun Jul 19 16:26:23 1998  Ross Johnson  <rpj@ixobrychus.canberra.edu.au>
+
+	* implement.h: Rename pthreads_thread_count to _pthread_threads_count.
+	Create _pthread_threads_thread_t struct to keep thread specific data.
+
+	* create.c: Rename pthreads_thread_count to _pthread_threads_count.
+	(pthread_create): Handle errors from CreateThread().
+
+1998-07-19  Ben Elliston  <bje@cygnus.com>
+
+	* condvar.c (pthread_cond_wait): Generalise.  Moved from here ..
+	(cond_wait): To here.
+	(pthread_cond_timedwait): Implement; use generalised cond_wait().
+
+	* pthread.h (pthread_key_t): Define this type.
+	(pthread_key_create): Add function prototype.
+	(pthread_setspecific): Likewise.
+	(pthread_getspecific): Likwise.
+	(pthread_key_delete): Likewise.
+
+	* tsd.c (pthread_key_create): Implement.
+	(pthread_setspecific): Likewise.
+	(pthread_getspecific): Likewise.
+	(pthread_key_delete): Likewise.
+
+	* mutex.c (pthread_mutex_trylock): Return ENOSYS if this function
+	is called on a Win32 platform which is not Windows NT.
+
+1998-07-18  Ben Elliston  <bje@cygnus.com>
+
+	* condvar.c (pthread_condattr_init): Do not attempt to malloc any
+	storage; none is needed now that condattr_t is an empty struct.
+	(pthread_condattr_destory): Likewise; do not free storage.
+	(pthread_condattr_setpshared): No longer supported; return ENOSYS.
+	(pthread_condattr_getpshared): Likewise.
+	(pthread_cond_init): Implement with help from Douglas Schmidt.
+	Remember to initialise the cv's internal mutex.
+	(pthread_cond_wait): Likewise.
+	(pthread_cond_signal): Likewise.
+	(pthread_cond_broadcast): Likewise.
+	(pthread_cond_timedwait): Preliminary implementation, but I need
+	to see some API documentation for `WaitForMultipleObject'.
+	(pthread_destory): Implement.
+
+	* pthread.h (pthread_cond_init): Add function protoype.
+	(pthread_cond_broadcast): Likewise.
+	(pthread_cond_signal): Likewise.
+	(pthread_cond_timedwait): Likewise.
+	(pthread_cond_wait): Likewise.
+	(pthread_cond_destroy): Likewise.
+	(pthread_cond_t): Define this type.  Fix for u_int.  Do not assume
+	that the mutex contained withing the pthread_cond_t structure will
+	be a critical section.  Use our new POSIX type!
+
+	* implement.h (_pthread_condattr_t): Remove shared attribute.
+
+1998-07-17  Ben Elliston  <bje@cygnus.com>
+
+	* pthread.h (PTHREADS_PROCESS_PRIVATE): Remove.
+	(PTHREAD_PROCESS_SHARED): Likewise.  No support for mutexes shared
+	across processes for now.
+	(pthread_mutex_t): Use a Win32 CRITICAL_SECTION type for better
+	performance.
+	
+	* implement.h (_pthread_mutexattr_t): Remove shared attribute.
+	
+	* mutex.c (pthread_mutexattr_setpshared): This optional function
+	is no longer supported, since we want to implement POSIX mutex
+	variables using the much more efficient Win32 critical section
+	primitives.  Critical section objects in Win32 cannot be shared
+	between processes.
+	(pthread_mutexattr_getpshared): Likewise.
+	(pthread_mutexattr_init): No need to malloc any storage; the
+	attributes structure is now empty.
+	(pthread_mutexattr_destroy): This is now a nop.
+	(pthread_mutex_init): Use InitializeCriticalSection().
+	(pthread_mutex_destroy): Use DeleteCriticalSection().
+	(pthread_mutex_lock): Use EnterCriticalSection().
+	(pthread_mutex_trylock): Use TryEnterCriticalSection().  This is
+	not supported by Windows 9x, but trylock is a hack anyway, IMHO.
+	(pthread_mutex_unlock): Use LeaveCriticalSection().
+
+1998-07-14  Ben Elliston  <bje@cygnus.com>
+
+	* attr.c (pthread_attr_setstacksize): Implement.
+	(pthread_attr_getstacksize): Likewise.
+	(pthread_attr_setstackaddr): Likewise.
+	(pthread_attr_getstackaddr): Likewise.
+	(pthread_attr_init): Likewise.
+	(pthread_attr_destroy): Likewise.
+	
+	* condvar.c (pthread_condattr_init): Add `_cond' to function name.
+
+	* mutex.c (pthread_mutex_lock): Add `_mutex' to function name.
+	(pthread_mutex_trylock): Likewise.
+	(pthread_mutex_unlock): Likewise.
+
+	* pthread.h (pthread_condattr_setpshared): Fix typo.
+	(pthread_attr_init): Add function prototype.
+	(pthread_attr_destroy): Likewise.
+	(pthread_attr_setstacksize): Likewise.
+	(pthread_attr_getstacksize): Likewise.
+	(pthread_attr_setstackaddr): Likewise.
+	(pthread_attr_getstackaddr): Likewise.
+	
+Mon Jul 13 01:09:55 1998  Ross Johnson  <rpj@ixobrychus.canberra.edu.au>
+
+	* implement.h: Wrap in #ifndef _IMPLEMENT_H
+
+	* create.c (pthread_create): Map stacksize attr to Win32.
+
+	* mutex.c: Include implement.h
+
+1998-07-13  Ben Elliston  <bje@cygnus.com>
+
+	* condvar.c (pthread_condattr_init): Implement.
+	(pthread_condattr_destroy): Likewise.
+	(pthread_condattr_setpshared): Likewise.
+	(pthread_condattr_getpshared): Likewise.
+	
+	* implement.h (PTHREAD_THREADS_MAX): Remove trailing semicolon.
+	(PTHREAD_STACK_MIN): Specify; needs confirming.
+	(_pthread_attr_t): Define this type.
+	(_pthread_condattr_t): Likewise.
+
+	* pthread.h (pthread_mutex_t): Define this type.
+	(pthread_condattr_t): Likewise.
+	(pthread_mutex_destroy): Add function prototype.
+	(pthread_lock): Likewise.
+	(pthread_trylock): Likewise.
+	(pthread_unlock): Likewise.
+	(pthread_condattr_init): Likewise.
+	(pthread_condattr_destroy): Likewise.
+	(pthread_condattr_setpshared): Likewise.
+	(pthread_condattr_getpshared): Likewise.
+
+	* mutex.c (pthread_mutex_init): Implement.
+	(pthread_mutex_destroy): Likewise.
+	(pthread_lock): Likewise.
+	(pthread_trylock): Likewise.
+	(pthread_unlock): Likewise.
+
+1998-07-12  Ben Elliston  <bje@cygnus.com>
+
+	* implement.h (_pthread_mutexattr_t): Define this implementation
+	internal type.  Application programmers only see a mutex attribute
+	object as a void pointer.
+
+	* pthread.h (pthread_mutexattr_t): Define this type.
+	(pthread_mutexattr_init): Add function prototype.
+	(pthread_mutexattr_destroy): Likewise.
+	(pthread_mutexattr_setpshared): Likewise.
+	(pthread_mutexattr_getpshared): Likewise.
+	(pthread_mutexattr_setprotocol): Likewise.
+	(pthread_mutexattr_getprotocol): Likewise.
+	(pthread_mutexattr_setprioceiling): Likewise.
+	(pthread_mutexattr_getprioceiling): Likewise.
+	(PTHREAD_PROCESS_PRIVATE): Define.
+	(PTHREAD_PROCESS_SHARED): Define.
+
+	* mutex.c (pthread_mutexattr_init): Implement.
+	(pthread_mutexattr_destroy): Implement.
+	(pthread_mutexattr_setprotocol): Implement.
+	(pthread_mutexattr_getprotocol): Likewise.
+	(pthread_mutexattr_setprioceiling): Likewise.
+	(pthread_mutexattr_getprioceiling): Likewise.
+	(pthread_mutexattr_setpshared): Likewise.
+	(pthread_mutexattr_getpshared): Likewise.
+	(insert_attr): New function; very preliminary implementation!
+	(is_attr): Likewise.
+	(remove_attr): Likewise.
+	
+Sat Jul 11 14:48:54 1998  Ross Johnson  <rpj@ixobrychus.canberra.edu.au>
+
+	* implement.h: Preliminary implementation specific defines.
+
+	* create.c (pthread_create): Preliminary implementation.
+
+1998-07-11  Ben Elliston  <bje@cygnus.com>
+
+	* sync.c (pthread_join): Implement.
+
+	* misc.c (pthread_equal): Likewise.
+	
+	* pthread.h (pthread_join): Add function prototype.
+	(pthread_equal): Likewise.
+	
+1998-07-10  Ben Elliston  <bje@cygnus.com>
+
+	* misc.c (pthread_self): Implement.
+
+	* exit.c (pthread_exit): Implement.
+
+	* pthread.h (pthread_exit): Add function prototype.
+	(pthread_self): Likewise.
+	(pthread_t): Define this type.
+
+1998-07-09  Ben Elliston  <bje@cygnus.com>
+
+	* create.c (pthread_create): A dummy stub right now.
+
+	* pthread.h (pthread_create): Add function prototype.
+
diff -ur a/win32/pthread/md5.sum.txt b/win32/pthread/md5.sum.txt
--- a/win32/pthread/md5.sum.txt	2011-03-11 16:49:19.000000000 +0200
+++ b/win32/pthread/md5.sum.txt	2017-12-07 23:26:02.668855264 +0200
@@ -1,7 +1,7 @@
-799d3a4e6142748584790a89e4b3f9b2  ChangeLog
-71bc1822a1a860a46f117e0f5147f77e  pthread.def
-f893a822b955fb50e9e10d7dfaa43b02  pthread.dll
-948fa230445c69f464560f5217c333ef  pthread.h
-571ddcac9c41539d70626ad43e6477f5  pthread.lib
-f12a296de03f5a59f8bb1c126b5d3c81  sched.h
-76a7a70f391f0d4823e5e67e574f6e36  semaphore.h
+799d3a4e6142748584790a89e4b3f9b2  ChangeLog
+71bc1822a1a860a46f117e0f5147f77e  pthread.def
+f893a822b955fb50e9e10d7dfaa43b02  pthread.dll
+948fa230445c69f464560f5217c333ef  pthread.h
+571ddcac9c41539d70626ad43e6477f5  pthread.lib
+f12a296de03f5a59f8bb1c126b5d3c81  sched.h
+76a7a70f391f0d4823e5e67e574f6e36  semaphore.h
diff -ur a/win32/pthread/pthread.h b/win32/pthread/pthread.h
--- a/win32/pthread/pthread.h	2011-03-11 16:49:19.000000000 +0200
+++ b/win32/pthread/pthread.h	2017-12-07 23:26:02.672855286 +0200
@@ -1,1368 +1,1368 @@
-/* This is an implementation of the threads API of POSIX 1003.1-2001.
- *
- * --------------------------------------------------------------------------
- *
- *      Pthreads-win32 - POSIX Threads Library for Win32
- *      Copyright(C) 1998 John E. Bossom
- *      Copyright(C) 1999,2005 Pthreads-win32 contributors
- * 
- *      Contact Email: rpj@callisto.canberra.edu.au
- * 
- *      The current list of contributors is contained
- *      in the file CONTRIBUTORS included with the source
- *      code distribution. The list can also be seen at the
- *      following World Wide Web location:
- *      http://sources.redhat.com/pthreads-win32/contributors.html
- * 
- *      This library is free software; you can redistribute it and/or
- *      modify it under the terms of the GNU Lesser General Public
- *      License as published by the Free Software Foundation; either
- *      version 2 of the License, or (at your option) any later version.
- * 
- *      This library is distributed in the hope that it will be useful,
- *      but WITHOUT ANY WARRANTY; without even the implied warranty of
- *      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- *      Lesser General Public License for more details.
- * 
- *      You should have received a copy of the GNU Lesser General Public
- *      License along with this library in the file COPYING.LIB;
- *      if not, write to the Free Software Foundation, Inc.,
- *      59 Temple Place - Suite 330, Boston, MA 02111-1307, USA
- */
-
-#if !defined( PTHREAD_H )
-#define PTHREAD_H
-
-/*
- * See the README file for an explanation of the pthreads-win32 version
- * numbering scheme and how the DLL is named etc.
- */
-#define PTW32_VERSION 2,7,0,0
-#define PTW32_VERSION_STRING "2, 7, 0, 0\0"
-
-/* There are three implementations of cancel cleanup.
- * Note that pthread.h is included in both application
- * compilation units and also internally for the library.
- * The code here and within the library aims to work
- * for all reasonable combinations of environments.
- *
- * The three implementations are:
- *
- *   WIN32 SEH
- *   C
- *   C++
- *
- * Please note that exiting a push/pop block via
- * "return", "exit", "break", or "continue" will
- * lead to different behaviour amongst applications
- * depending upon whether the library was built
- * using SEH, C++, or C. For example, a library built
- * with SEH will call the cleanup routine, while both
- * C++ and C built versions will not.
- */
-
-/*
- * Define defaults for cleanup code.
- * Note: Unless the build explicitly defines one of the following, then
- * we default to standard C style cleanup. This style uses setjmp/longjmp
- * in the cancelation and thread exit implementations and therefore won't
- * do stack unwinding if linked to applications that have it (e.g.
- * C++ apps). This is currently consistent with most/all commercial Unix
- * POSIX threads implementations.
- */
-#if !defined( __CLEANUP_SEH ) && !defined( __CLEANUP_CXX ) && !defined( __CLEANUP_C )
-# define __CLEANUP_C
-#endif
-
-#if defined( __CLEANUP_SEH ) && ( !defined( _MSC_VER ) && !defined(PTW32_RC_MSC))
-#error ERROR [__FILE__, line __LINE__]: SEH is not supported for this compiler.
-#endif
-
-/*
- * Stop here if we are being included by the resource compiler.
- */
-#ifndef RC_INVOKED
-
-#undef PTW32_LEVEL
-
-#if defined(_POSIX_SOURCE)
-#define PTW32_LEVEL 0
-/* Early POSIX */
-#endif
-
-#if defined(_POSIX_C_SOURCE) && _POSIX_C_SOURCE >= 199309
-#undef PTW32_LEVEL
-#define PTW32_LEVEL 1
-/* Include 1b, 1c and 1d */
-#endif
-
-#if defined(INCLUDE_NP)
-#undef PTW32_LEVEL
-#define PTW32_LEVEL 2
-/* Include Non-Portable extensions */
-#endif
-
-#define PTW32_LEVEL_MAX 3
-
-#if !defined(PTW32_LEVEL)
-#define PTW32_LEVEL PTW32_LEVEL_MAX
-/* Include everything */
-#endif
-
-#ifdef _UWIN
-#   define HAVE_STRUCT_TIMESPEC 1
-#   define HAVE_SIGNAL_H        1
-#   undef HAVE_CONFIG_H
-#   pragma comment(lib, "pthread")
-#endif
-
-/*
- * -------------------------------------------------------------
- *
- *
- * Module: pthread.h
- *
- * Purpose:
- *      Provides an implementation of PThreads based upon the
- *      standard:
- *
- *              POSIX 1003.1-2001
- *  and
- *    The Single Unix Specification version 3
- *
- *    (these two are equivalent)
- *
- *      in order to enhance code portability between Windows,
- *  various commercial Unix implementations, and Linux.
- *
- *      See the ANNOUNCE file for a full list of conforming
- *      routines and defined constants, and a list of missing
- *      routines and constants not defined in this implementation.
- *
- * Authors:
- *      There have been many contributors to this library.
- *      The initial implementation was contributed by
- *      John Bossom, and several others have provided major
- *      sections or revisions of parts of the implementation.
- *      Often significant effort has been contributed to
- *      find and fix important bugs and other problems to
- *      improve the reliability of the library, which sometimes
- *      is not reflected in the amount of code which changed as
- *      result.
- *      As much as possible, the contributors are acknowledged
- *      in the ChangeLog file in the source code distribution
- *      where their changes are noted in detail.
- *
- *      Contributors are listed in the CONTRIBUTORS file.
- *
- *      As usual, all bouquets go to the contributors, and all
- *      brickbats go to the project maintainer.
- *
- * Maintainer:
- *      The code base for this project is coordinated and
- *      eventually pre-tested, packaged, and made available by
- *
- *              Ross Johnson <rpj@callisto.canberra.edu.au>
- *
- * QA Testers:
- *      Ultimately, the library is tested in the real world by
- *      a host of competent and demanding scientists and
- *      engineers who report bugs and/or provide solutions
- *      which are then fixed or incorporated into subsequent
- *      versions of the library. Each time a bug is fixed, a
- *      test case is written to prove the fix and ensure
- *      that later changes to the code don't reintroduce the
- *      same error. The number of test cases is slowly growing
- *      and therefore so is the code reliability.
- *
- * Compliance:
- *      See the file ANNOUNCE for the list of implemented
- *      and not-implemented routines and defined options.
- *      Of course, these are all defined is this file as well.
- *
- * Web site:
- *      The source code and other information about this library
- *      are available from
- *
- *              http://sources.redhat.com/pthreads-win32/
- *
- * -------------------------------------------------------------
- */
-
-/* Try to avoid including windows.h */
-#if defined(__MINGW32__) && defined(__cplusplus)
-#define PTW32_INCLUDE_WINDOWS_H
-#endif
-
-#ifdef PTW32_INCLUDE_WINDOWS_H
-#include <windows.h>
-#endif
-
-#if defined(_MSC_VER) && _MSC_VER < 1300 || defined(__DMC__)
-/*
- * VC++6.0 or early compiler's header has no DWORD_PTR type.
- */
-typedef unsigned long DWORD_PTR;
-#endif
-/*
- * -----------------
- * autoconf switches
- * -----------------
- */
-
-#if HAVE_CONFIG_H
-#include "config.h"
-#endif /* HAVE_CONFIG_H */
-
-#ifndef NEED_FTIME
-#include <time.h>
-#else /* NEED_FTIME */
-/* use native WIN32 time API */
-#endif /* NEED_FTIME */
-
-#if HAVE_SIGNAL_H
-#include <signal.h>
-#endif /* HAVE_SIGNAL_H */
-
-#include <setjmp.h>
-#include <limits.h>
-
-/*
- * Boolean values to make us independent of system includes.
- */
-enum {
-  PTW32_FALSE = 0,
-  PTW32_TRUE = (! PTW32_FALSE)
-};
-
-/*
- * This is a duplicate of what is in the autoconf config.h,
- * which is only used when building the pthread-win32 libraries.
- */
-
-#ifndef PTW32_CONFIG_H
-#  if defined(WINCE)
-#    define NEED_ERRNO
-#    define NEED_SEM
-#  endif
-#  if defined(_UWIN) || defined(__MINGW32__)
-#    define HAVE_MODE_T
-#  endif
-#endif
-
-/*
- *
- */
-
-#if PTW32_LEVEL >= PTW32_LEVEL_MAX
-#ifdef NEED_ERRNO
-#include "need_errno.h"
-#else
-#include <errno.h>
-#endif
-#endif /* PTW32_LEVEL >= PTW32_LEVEL_MAX */
-
-/*
- * Several systems don't define some error numbers.
- */
-#ifndef ENOTSUP
-#  define ENOTSUP 48   /* This is the value in Solaris. */
-#endif
-
-#ifndef ETIMEDOUT
-#  define ETIMEDOUT 10060     /* This is the value in winsock.h. */
-#endif
-
-#ifndef ENOSYS
-#  define ENOSYS 140     /* Semi-arbitrary value */
-#endif
-
-#ifndef EDEADLK
-#  ifdef EDEADLOCK
-#    define EDEADLK EDEADLOCK
-#  else
-#    define EDEADLK 36     /* This is the value in MSVC. */
-#  endif
-#endif
-
-#include <sched.h>
-
-/*
- * To avoid including windows.h we define only those things that we
- * actually need from it.
- */
-#ifndef PTW32_INCLUDE_WINDOWS_H
-#ifndef HANDLE
-# define PTW32__HANDLE_DEF
-# define HANDLE void *
-#endif
-#ifndef DWORD
-# define PTW32__DWORD_DEF
-# define DWORD unsigned long
-#endif
-#endif
-
-#ifndef HAVE_STRUCT_TIMESPEC
-#define HAVE_STRUCT_TIMESPEC 1
-struct timespec {
-        long tv_sec;
-        long tv_nsec;
-};
-#endif /* HAVE_STRUCT_TIMESPEC */
-
-#ifndef SIG_BLOCK
-#define SIG_BLOCK 0
-#endif /* SIG_BLOCK */
-
-#ifndef SIG_UNBLOCK 
-#define SIG_UNBLOCK 1
-#endif /* SIG_UNBLOCK */
-
-#ifndef SIG_SETMASK
-#define SIG_SETMASK 2
-#endif /* SIG_SETMASK */
-
-#ifdef __cplusplus
-extern "C"
-{
-#endif                          /* __cplusplus */
-
-/*
- * -------------------------------------------------------------
- *
- * POSIX 1003.1-2001 Options
- * =========================
- *
- * Options are normally set in <unistd.h>, which is not provided
- * with pthreads-win32.
- *
- * For conformance with the Single Unix Specification (version 3), all of the
- * options below are defined, and have a value of either -1 (not supported)
- * or 200112L (supported).
- *
- * These options can neither be left undefined nor have a value of 0, because
- * either indicates that sysconf(), which is not implemented, may be used at
- * runtime to check the status of the option.
- *
- * _POSIX_THREADS (== 200112L)
- *                      If == 200112L, you can use threads
- *
- * _POSIX_THREAD_ATTR_STACKSIZE (== 200112L)
- *                      If == 200112L, you can control the size of a thread's
- *                      stack
- *                              pthread_attr_getstacksize
- *                              pthread_attr_setstacksize
- *
- * _POSIX_THREAD_ATTR_STACKADDR (== -1)
- *                      If == 200112L, you can allocate and control a thread's
- *                      stack. If not supported, the following functions
- *                      will return ENOSYS, indicating they are not
- *                      supported:
- *                              pthread_attr_getstackaddr
- *                              pthread_attr_setstackaddr
- *
- * _POSIX_THREAD_PRIORITY_SCHEDULING (== -1)
- *                      If == 200112L, you can use realtime scheduling.
- *                      This option indicates that the behaviour of some
- *                      implemented functions conforms to the additional TPS
- *                      requirements in the standard. E.g. rwlocks favour
- *                      writers over readers when threads have equal priority.
- *
- * _POSIX_THREAD_PRIO_INHERIT (== -1)
- *                      If == 200112L, you can create priority inheritance
- *                      mutexes.
- *                              pthread_mutexattr_getprotocol +
- *                              pthread_mutexattr_setprotocol +
- *
- * _POSIX_THREAD_PRIO_PROTECT (== -1)
- *                      If == 200112L, you can create priority ceiling mutexes
- *                      Indicates the availability of:
- *                              pthread_mutex_getprioceiling
- *                              pthread_mutex_setprioceiling
- *                              pthread_mutexattr_getprioceiling
- *                              pthread_mutexattr_getprotocol     +
- *                              pthread_mutexattr_setprioceiling
- *                              pthread_mutexattr_setprotocol     +
- *
- * _POSIX_THREAD_PROCESS_SHARED (== -1)
- *                      If set, you can create mutexes and condition
- *                      variables that can be shared with another
- *                      process.If set, indicates the availability
- *                      of:
- *                              pthread_mutexattr_getpshared
- *                              pthread_mutexattr_setpshared
- *                              pthread_condattr_getpshared
- *                              pthread_condattr_setpshared
- *
- * _POSIX_THREAD_SAFE_FUNCTIONS (== 200112L)
- *                      If == 200112L you can use the special *_r library
- *                      functions that provide thread-safe behaviour
- *
- * _POSIX_READER_WRITER_LOCKS (== 200112L)
- *                      If == 200112L, you can use read/write locks
- *
- * _POSIX_SPIN_LOCKS (== 200112L)
- *                      If == 200112L, you can use spin locks
- *
- * _POSIX_BARRIERS (== 200112L)
- *                      If == 200112L, you can use barriers
- *
- *      + These functions provide both 'inherit' and/or
- *        'protect' protocol, based upon these macro
- *        settings.
- *
- * -------------------------------------------------------------
- */
-
-/*
- * POSIX Options
- */
-#undef _POSIX_THREADS
-#define _POSIX_THREADS 200112L
-
-#undef _POSIX_READER_WRITER_LOCKS
-#define _POSIX_READER_WRITER_LOCKS 200112L
-
-#undef _POSIX_SPIN_LOCKS
-#define _POSIX_SPIN_LOCKS 200112L
-
-#undef _POSIX_BARRIERS
-#define _POSIX_BARRIERS 200112L
-
-#undef _POSIX_THREAD_SAFE_FUNCTIONS
-#define _POSIX_THREAD_SAFE_FUNCTIONS 200112L
-
-#undef _POSIX_THREAD_ATTR_STACKSIZE
-#define _POSIX_THREAD_ATTR_STACKSIZE 200112L
-
-/*
- * The following options are not supported
- */
-#undef _POSIX_THREAD_ATTR_STACKADDR
-#define _POSIX_THREAD_ATTR_STACKADDR -1
-
-#undef _POSIX_THREAD_PRIO_INHERIT
-#define _POSIX_THREAD_PRIO_INHERIT -1
-
-#undef _POSIX_THREAD_PRIO_PROTECT
-#define _POSIX_THREAD_PRIO_PROTECT -1
-
-/* TPS is not fully supported.  */
-#undef _POSIX_THREAD_PRIORITY_SCHEDULING
-#define _POSIX_THREAD_PRIORITY_SCHEDULING -1
-
-#undef _POSIX_THREAD_PROCESS_SHARED
-#define _POSIX_THREAD_PROCESS_SHARED -1
-
-
-/*
- * POSIX 1003.1-2001 Limits
- * ===========================
- *
- * These limits are normally set in <limits.h>, which is not provided with
- * pthreads-win32.
- *
- * PTHREAD_DESTRUCTOR_ITERATIONS
- *                      Maximum number of attempts to destroy
- *                      a thread's thread-specific data on
- *                      termination (must be at least 4)
- *
- * PTHREAD_KEYS_MAX
- *                      Maximum number of thread-specific data keys
- *                      available per process (must be at least 128)
- *
- * PTHREAD_STACK_MIN
- *                      Minimum supported stack size for a thread
- *
- * PTHREAD_THREADS_MAX
- *                      Maximum number of threads supported per
- *                      process (must be at least 64).
- *
- * SEM_NSEMS_MAX
- *                      The maximum number of semaphores a process can have.
- *                      (must be at least 256)
- *
- * SEM_VALUE_MAX
- *                      The maximum value a semaphore can have.
- *                      (must be at least 32767)
- *
- */
-#undef _POSIX_THREAD_DESTRUCTOR_ITERATIONS
-#define _POSIX_THREAD_DESTRUCTOR_ITERATIONS     4
-
-#undef PTHREAD_DESTRUCTOR_ITERATIONS
-#define PTHREAD_DESTRUCTOR_ITERATIONS           _POSIX_THREAD_DESTRUCTOR_ITERATIONS
-
-#undef _POSIX_THREAD_KEYS_MAX
-#define _POSIX_THREAD_KEYS_MAX                  128
-
-#undef PTHREAD_KEYS_MAX
-#define PTHREAD_KEYS_MAX                        _POSIX_THREAD_KEYS_MAX
-
-#undef PTHREAD_STACK_MIN
-#define PTHREAD_STACK_MIN                       0
-
-#undef _POSIX_THREAD_THREADS_MAX
-#define _POSIX_THREAD_THREADS_MAX               64
-
-  /* Arbitrary value */
-#undef PTHREAD_THREADS_MAX
-#define PTHREAD_THREADS_MAX                     2019
-
-#undef _POSIX_SEM_NSEMS_MAX
-#define _POSIX_SEM_NSEMS_MAX                    256
-
-  /* Arbitrary value */
-#undef SEM_NSEMS_MAX
-#define SEM_NSEMS_MAX                           1024
-
-#undef _POSIX_SEM_VALUE_MAX
-#define _POSIX_SEM_VALUE_MAX                    32767
-
-#undef SEM_VALUE_MAX
-#define SEM_VALUE_MAX                           INT_MAX
-
-
-#if __GNUC__ && ! defined (__declspec)
-# error Please upgrade your GNU compiler to one that supports __declspec.
-#endif
-
-/*
- * When building the DLL code, you should define PTW32_BUILD so that
- * the variables/functions are exported correctly. When using the DLL,
- * do NOT define PTW32_BUILD, and then the variables/functions will
- * be imported correctly.
- */
-#ifndef PTW32_STATIC_LIB
-#  ifdef PTW32_BUILD
-#    define PTW32_DLLPORT __declspec (dllexport)
-#  else
-#    define PTW32_DLLPORT __declspec (dllimport)
-#  endif
-#else
-#  define PTW32_DLLPORT
-#endif
-
-/*
- * The Open Watcom C/C++ compiler uses a non-standard calling convention
- * that passes function args in registers unless __cdecl is explicitly specified
- * in exposed function prototypes.
- *
- * We force all calls to cdecl even though this could slow Watcom code down
- * slightly. If you know that the Watcom compiler will be used to build both
- * the DLL and application, then you can probably define this as a null string.
- * Remember that pthread.h (this file) is used for both the DLL and application builds.
- */
-#define PTW32_CDECL __cdecl
-
-#if defined(_UWIN) && PTW32_LEVEL >= PTW32_LEVEL_MAX
-#   include     <sys/types.h>
-#else
-/*
- * Generic handle type - intended to extend uniqueness beyond
- * that available with a simple pointer. It should scale for either
- * IA-32 or IA-64.
- */
-typedef struct {
-    void * p;                   /* Pointer to actual object */
-    unsigned int x;             /* Extra information - reuse count etc */
-} ptw32_handle_t;
-
-typedef ptw32_handle_t pthread_t;
-typedef struct pthread_attr_t_ * pthread_attr_t;
-typedef struct pthread_once_t_ pthread_once_t;
-typedef struct pthread_key_t_ * pthread_key_t;
-typedef struct pthread_mutex_t_ * pthread_mutex_t;
-typedef struct pthread_mutexattr_t_ * pthread_mutexattr_t;
-typedef struct pthread_cond_t_ * pthread_cond_t;
-typedef struct pthread_condattr_t_ * pthread_condattr_t;
-#endif
-typedef struct pthread_rwlock_t_ * pthread_rwlock_t;
-typedef struct pthread_rwlockattr_t_ * pthread_rwlockattr_t;
-typedef struct pthread_spinlock_t_ * pthread_spinlock_t;
-typedef struct pthread_barrier_t_ * pthread_barrier_t;
-typedef struct pthread_barrierattr_t_ * pthread_barrierattr_t;
-
-/*
- * ====================
- * ====================
- * POSIX Threads
- * ====================
- * ====================
- */
-
-enum {
-/*
- * pthread_attr_{get,set}detachstate
- */
-  PTHREAD_CREATE_JOINABLE       = 0,  /* Default */
-  PTHREAD_CREATE_DETACHED       = 1,
-
-/*
- * pthread_attr_{get,set}inheritsched
- */
-  PTHREAD_INHERIT_SCHED         = 0,
-  PTHREAD_EXPLICIT_SCHED        = 1,  /* Default */
-
-/*
- * pthread_{get,set}scope
- */
-  PTHREAD_SCOPE_PROCESS         = 0,
-  PTHREAD_SCOPE_SYSTEM          = 1,  /* Default */
-
-/*
- * pthread_setcancelstate paramters
- */
-  PTHREAD_CANCEL_ENABLE         = 0,  /* Default */
-  PTHREAD_CANCEL_DISABLE        = 1,
-
-/*
- * pthread_setcanceltype parameters
- */
-  PTHREAD_CANCEL_ASYNCHRONOUS   = 0,
-  PTHREAD_CANCEL_DEFERRED       = 1,  /* Default */
-
-/*
- * pthread_mutexattr_{get,set}pshared
- * pthread_condattr_{get,set}pshared
- */
-  PTHREAD_PROCESS_PRIVATE       = 0,
-  PTHREAD_PROCESS_SHARED        = 1,
-
-/*
- * pthread_barrier_wait
- */
-  PTHREAD_BARRIER_SERIAL_THREAD = -1
-};
-
-/*
- * ====================
- * ====================
- * Cancelation
- * ====================
- * ====================
- */
-#define PTHREAD_CANCELED       ((void *) -1)
-
-
-/*
- * ====================
- * ====================
- * Once Key
- * ====================
- * ====================
- */
-#define PTHREAD_ONCE_INIT       { PTW32_FALSE, 0, 0, 0}
-
-struct pthread_once_t_
-{
-  int          done;        /* indicates if user function has been executed */
-  void *       lock;
-  int          reserved1;
-  int          reserved2;
-};
-
-
-/*
- * ====================
- * ====================
- * Object initialisers
- * ====================
- * ====================
- */
-#define PTHREAD_MUTEX_INITIALIZER ((pthread_mutex_t) -1)
-#define PTHREAD_RECURSIVE_MUTEX_INITIALIZER ((pthread_mutex_t) -2)
-#define PTHREAD_ERRORCHECK_MUTEX_INITIALIZER ((pthread_mutex_t) -3)
-
-/*
- * Compatibility with LinuxThreads
- */
-#define PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP PTHREAD_RECURSIVE_MUTEX_INITIALIZER
-#define PTHREAD_ERRORCHECK_MUTEX_INITIALIZER_NP PTHREAD_ERRORCHECK_MUTEX_INITIALIZER
-
-#define PTHREAD_COND_INITIALIZER ((pthread_cond_t) -1)
-
-#define PTHREAD_RWLOCK_INITIALIZER ((pthread_rwlock_t) -1)
-
-#define PTHREAD_SPINLOCK_INITIALIZER ((pthread_spinlock_t) -1)
-
-
-/*
- * Mutex types.
- */
-enum
-{
-  /* Compatibility with LinuxThreads */
-  PTHREAD_MUTEX_FAST_NP,
-  PTHREAD_MUTEX_RECURSIVE_NP,
-  PTHREAD_MUTEX_ERRORCHECK_NP,
-  PTHREAD_MUTEX_TIMED_NP = PTHREAD_MUTEX_FAST_NP,
-  PTHREAD_MUTEX_ADAPTIVE_NP = PTHREAD_MUTEX_FAST_NP,
-  /* For compatibility with POSIX */
-  PTHREAD_MUTEX_NORMAL = PTHREAD_MUTEX_FAST_NP,
-  PTHREAD_MUTEX_RECURSIVE = PTHREAD_MUTEX_RECURSIVE_NP,
-  PTHREAD_MUTEX_ERRORCHECK = PTHREAD_MUTEX_ERRORCHECK_NP,
-  PTHREAD_MUTEX_DEFAULT = PTHREAD_MUTEX_NORMAL
-};
-
-
-typedef struct ptw32_cleanup_t ptw32_cleanup_t;
-
-#if defined(_MSC_VER)
-/* Disable MSVC 'anachronism used' warning */
-#pragma warning( disable : 4229 )
-#endif
-
-typedef void (* PTW32_CDECL ptw32_cleanup_callback_t)(void *);
-
-#if defined(_MSC_VER)
-#pragma warning( default : 4229 )
-#endif
-
-struct ptw32_cleanup_t
-{
-  ptw32_cleanup_callback_t routine;
-  void *arg;
-  struct ptw32_cleanup_t *prev;
-};
-
-#ifdef __CLEANUP_SEH
-        /*
-         * WIN32 SEH version of cancel cleanup.
-         */
-
-#define pthread_cleanup_push( _rout, _arg ) \
-        { \
-            ptw32_cleanup_t     _cleanup; \
-            \
-        _cleanup.routine        = (ptw32_cleanup_callback_t)(_rout); \
-            _cleanup.arg        = (_arg); \
-            __try \
-              { \
-
-#define pthread_cleanup_pop( _execute ) \
-              } \
-            __finally \
-                { \
-                    if( _execute || AbnormalTermination()) \
-                      { \
-                          (*(_cleanup.routine))( _cleanup.arg ); \
-                      } \
-                } \
-        }
-
-#else /* __CLEANUP_SEH */
-
-#ifdef __CLEANUP_C
-
-        /*
-         * C implementation of PThreads cancel cleanup
-         */
-
-#define pthread_cleanup_push( _rout, _arg ) \
-        { \
-            ptw32_cleanup_t     _cleanup; \
-            \
-            ptw32_push_cleanup( &_cleanup, (ptw32_cleanup_callback_t) (_rout), (_arg) ); \
-
-#define pthread_cleanup_pop( _execute ) \
-            (void) ptw32_pop_cleanup( _execute ); \
-        }
-
-#else /* __CLEANUP_C */
-
-#ifdef __CLEANUP_CXX
-
-        /*
-         * C++ version of cancel cleanup.
-         * - John E. Bossom.
-         */
-
-        class PThreadCleanup {
-          /*
-           * PThreadCleanup
-           *
-           * Purpose
-           *      This class is a C++ helper class that is
-           *      used to implement pthread_cleanup_push/
-           *      pthread_cleanup_pop.
-           *      The destructor of this class automatically
-           *      pops the pushed cleanup routine regardless
-           *      of how the code exits the scope
-           *      (i.e. such as by an exception)
-           */
-      ptw32_cleanup_callback_t cleanUpRout;
-          void    *       obj;
-          int             executeIt;
-
-        public:
-          PThreadCleanup() :
-            cleanUpRout( 0 ),
-            obj( 0 ),
-            executeIt( 0 )
-            /*
-             * No cleanup performed
-             */
-            {
-            }
-
-          PThreadCleanup(
-             ptw32_cleanup_callback_t routine,
-                         void    *       arg ) :
-            cleanUpRout( routine ),
-            obj( arg ),
-            executeIt( 1 )
-            /*
-             * Registers a cleanup routine for 'arg'
-             */
-            {
-            }
-
-          ~PThreadCleanup()
-            {
-              if ( executeIt && ((void *) cleanUpRout != (void *) 0) )
-                {
-                  (void) (*cleanUpRout)( obj );
-                }
-            }
-
-          void execute( int exec )
-            {
-              executeIt = exec;
-            }
-        };
-
-        /*
-         * C++ implementation of PThreads cancel cleanup;
-         * This implementation takes advantage of a helper
-         * class who's destructor automatically calls the
-         * cleanup routine if we exit our scope weirdly
-         */
-#define pthread_cleanup_push( _rout, _arg ) \
-        { \
-            PThreadCleanup  cleanup((ptw32_cleanup_callback_t)(_rout), \
-                                    (void *) (_arg) );
-
-#define pthread_cleanup_pop( _execute ) \
-            cleanup.execute( _execute ); \
-        }
-
-#else
-
-#error ERROR [__FILE__, line __LINE__]: Cleanup type undefined.
-
-#endif /* __CLEANUP_CXX */
-
-#endif /* __CLEANUP_C */
-
-#endif /* __CLEANUP_SEH */
-
-/*
- * ===============
- * ===============
- * Methods
- * ===============
- * ===============
- */
-
-/*
- * PThread Attribute Functions
- */
-PTW32_DLLPORT int PTW32_CDECL pthread_attr_init (pthread_attr_t * attr);
-
-PTW32_DLLPORT int PTW32_CDECL pthread_attr_destroy (pthread_attr_t * attr);
-
-PTW32_DLLPORT int PTW32_CDECL pthread_attr_getdetachstate (const pthread_attr_t * attr,
-                                         int *detachstate);
-
-PTW32_DLLPORT int PTW32_CDECL pthread_attr_getstackaddr (const pthread_attr_t * attr,
-                                       void **stackaddr);
-
-PTW32_DLLPORT int PTW32_CDECL pthread_attr_getstacksize (const pthread_attr_t * attr,
-                                       size_t * stacksize);
-
-PTW32_DLLPORT int PTW32_CDECL pthread_attr_setdetachstate (pthread_attr_t * attr,
-                                         int detachstate);
-
-PTW32_DLLPORT int PTW32_CDECL pthread_attr_setstackaddr (pthread_attr_t * attr,
-                                       void *stackaddr);
-
-PTW32_DLLPORT int PTW32_CDECL pthread_attr_setstacksize (pthread_attr_t * attr,
-                                       size_t stacksize);
-
-PTW32_DLLPORT int PTW32_CDECL pthread_attr_getschedparam (const pthread_attr_t *attr,
-                                        struct sched_param *param);
-
-PTW32_DLLPORT int PTW32_CDECL pthread_attr_setschedparam (pthread_attr_t *attr,
-                                        const struct sched_param *param);
-
-PTW32_DLLPORT int PTW32_CDECL pthread_attr_setschedpolicy (pthread_attr_t *,
-                                         int);
-
-PTW32_DLLPORT int PTW32_CDECL pthread_attr_getschedpolicy (pthread_attr_t *,
-                                         int *);
-
-PTW32_DLLPORT int PTW32_CDECL pthread_attr_setinheritsched(pthread_attr_t * attr,
-                                         int inheritsched);
-
-PTW32_DLLPORT int PTW32_CDECL pthread_attr_getinheritsched(pthread_attr_t * attr,
-                                         int * inheritsched);
-
-PTW32_DLLPORT int PTW32_CDECL pthread_attr_setscope (pthread_attr_t *,
-                                   int);
-
-PTW32_DLLPORT int PTW32_CDECL pthread_attr_getscope (const pthread_attr_t *,
-                                   int *);
-
-/*
- * PThread Functions
- */
-PTW32_DLLPORT int PTW32_CDECL pthread_create (pthread_t * tid,
-                            const pthread_attr_t * attr,
-                            void *(*start) (void *),
-                            void *arg);
-
-PTW32_DLLPORT int PTW32_CDECL pthread_detach (pthread_t tid);
-
-PTW32_DLLPORT int PTW32_CDECL pthread_equal (pthread_t t1,
-                           pthread_t t2);
-
-PTW32_DLLPORT void PTW32_CDECL pthread_exit (void *value_ptr);
-
-PTW32_DLLPORT int PTW32_CDECL pthread_join (pthread_t thread,
-                          void **value_ptr);
-
-PTW32_DLLPORT pthread_t PTW32_CDECL pthread_self (void);
-
-PTW32_DLLPORT int PTW32_CDECL pthread_cancel (pthread_t thread);
-
-PTW32_DLLPORT int PTW32_CDECL pthread_setcancelstate (int state,
-                                    int *oldstate);
-
-PTW32_DLLPORT int PTW32_CDECL pthread_setcanceltype (int type,
-                                   int *oldtype);
-
-PTW32_DLLPORT void PTW32_CDECL pthread_testcancel (void);
-
-PTW32_DLLPORT int PTW32_CDECL pthread_once (pthread_once_t * once_control,
-                          void (*init_routine) (void));
-
-#if PTW32_LEVEL >= PTW32_LEVEL_MAX
-PTW32_DLLPORT ptw32_cleanup_t * PTW32_CDECL ptw32_pop_cleanup (int execute);
-
-PTW32_DLLPORT void PTW32_CDECL ptw32_push_cleanup (ptw32_cleanup_t * cleanup,
-                                 void (*routine) (void *),
-                                 void *arg);
-#endif /* PTW32_LEVEL >= PTW32_LEVEL_MAX */
-
-/*
- * Thread Specific Data Functions
- */
-PTW32_DLLPORT int PTW32_CDECL pthread_key_create (pthread_key_t * key,
-                                void (*destructor) (void *));
-
-PTW32_DLLPORT int PTW32_CDECL pthread_key_delete (pthread_key_t key);
-
-PTW32_DLLPORT int PTW32_CDECL pthread_setspecific (pthread_key_t key,
-                                 const void *value);
-
-PTW32_DLLPORT void * PTW32_CDECL pthread_getspecific (pthread_key_t key);
-
-
-/*
- * Mutex Attribute Functions
- */
-PTW32_DLLPORT int PTW32_CDECL pthread_mutexattr_init (pthread_mutexattr_t * attr);
-
-PTW32_DLLPORT int PTW32_CDECL pthread_mutexattr_destroy (pthread_mutexattr_t * attr);
-
-PTW32_DLLPORT int PTW32_CDECL pthread_mutexattr_getpshared (const pthread_mutexattr_t
-                                          * attr,
-                                          int *pshared);
-
-PTW32_DLLPORT int PTW32_CDECL pthread_mutexattr_setpshared (pthread_mutexattr_t * attr,
-                                          int pshared);
-
-PTW32_DLLPORT int PTW32_CDECL pthread_mutexattr_settype (pthread_mutexattr_t * attr, int kind);
-PTW32_DLLPORT int PTW32_CDECL pthread_mutexattr_gettype (pthread_mutexattr_t * attr, int *kind);
-
-/*
- * Barrier Attribute Functions
- */
-PTW32_DLLPORT int PTW32_CDECL pthread_barrierattr_init (pthread_barrierattr_t * attr);
-
-PTW32_DLLPORT int PTW32_CDECL pthread_barrierattr_destroy (pthread_barrierattr_t * attr);
-
-PTW32_DLLPORT int PTW32_CDECL pthread_barrierattr_getpshared (const pthread_barrierattr_t
-                                            * attr,
-                                            int *pshared);
-
-PTW32_DLLPORT int PTW32_CDECL pthread_barrierattr_setpshared (pthread_barrierattr_t * attr,
-                                            int pshared);
-
-/*
- * Mutex Functions
- */
-PTW32_DLLPORT int PTW32_CDECL pthread_mutex_init (pthread_mutex_t * mutex,
-                                const pthread_mutexattr_t * attr);
-
-PTW32_DLLPORT int PTW32_CDECL pthread_mutex_destroy (pthread_mutex_t * mutex);
-
-PTW32_DLLPORT int PTW32_CDECL pthread_mutex_lock (pthread_mutex_t * mutex);
-
-PTW32_DLLPORT int PTW32_CDECL pthread_mutex_timedlock(pthread_mutex_t *mutex,
-                                    const struct timespec *abstime);
-
-PTW32_DLLPORT int PTW32_CDECL pthread_mutex_trylock (pthread_mutex_t * mutex);
-
-PTW32_DLLPORT int PTW32_CDECL pthread_mutex_unlock (pthread_mutex_t * mutex);
-
-/*
- * Spinlock Functions
- */
-PTW32_DLLPORT int PTW32_CDECL pthread_spin_init (pthread_spinlock_t * lock, int pshared);
-
-PTW32_DLLPORT int PTW32_CDECL pthread_spin_destroy (pthread_spinlock_t * lock);
-
-PTW32_DLLPORT int PTW32_CDECL pthread_spin_lock (pthread_spinlock_t * lock);
-
-PTW32_DLLPORT int PTW32_CDECL pthread_spin_trylock (pthread_spinlock_t * lock);
-
-PTW32_DLLPORT int PTW32_CDECL pthread_spin_unlock (pthread_spinlock_t * lock);
-
-/*
- * Barrier Functions
- */
-PTW32_DLLPORT int PTW32_CDECL pthread_barrier_init (pthread_barrier_t * barrier,
-                                  const pthread_barrierattr_t * attr,
-                                  unsigned int count);
-
-PTW32_DLLPORT int PTW32_CDECL pthread_barrier_destroy (pthread_barrier_t * barrier);
-
-PTW32_DLLPORT int PTW32_CDECL pthread_barrier_wait (pthread_barrier_t * barrier);
-
-/*
- * Condition Variable Attribute Functions
- */
-PTW32_DLLPORT int PTW32_CDECL pthread_condattr_init (pthread_condattr_t * attr);
-
-PTW32_DLLPORT int PTW32_CDECL pthread_condattr_destroy (pthread_condattr_t * attr);
-
-PTW32_DLLPORT int PTW32_CDECL pthread_condattr_getpshared (const pthread_condattr_t * attr,
-                                         int *pshared);
-
-PTW32_DLLPORT int PTW32_CDECL pthread_condattr_setpshared (pthread_condattr_t * attr,
-                                         int pshared);
-
-/*
- * Condition Variable Functions
- */
-PTW32_DLLPORT int PTW32_CDECL pthread_cond_init (pthread_cond_t * cond,
-                               const pthread_condattr_t * attr);
-
-PTW32_DLLPORT int PTW32_CDECL pthread_cond_destroy (pthread_cond_t * cond);
-
-PTW32_DLLPORT int PTW32_CDECL pthread_cond_wait (pthread_cond_t * cond,
-                               pthread_mutex_t * mutex);
-
-PTW32_DLLPORT int PTW32_CDECL pthread_cond_timedwait (pthread_cond_t * cond,
-                                    pthread_mutex_t * mutex,
-                                    const struct timespec *abstime);
-
-PTW32_DLLPORT int PTW32_CDECL pthread_cond_signal (pthread_cond_t * cond);
-
-PTW32_DLLPORT int PTW32_CDECL pthread_cond_broadcast (pthread_cond_t * cond);
-
-/*
- * Scheduling
- */
-PTW32_DLLPORT int PTW32_CDECL pthread_setschedparam (pthread_t thread,
-                                   int policy,
-                                   const struct sched_param *param);
-
-PTW32_DLLPORT int PTW32_CDECL pthread_getschedparam (pthread_t thread,
-                                   int *policy,
-                                   struct sched_param *param);
-
-PTW32_DLLPORT int PTW32_CDECL pthread_setconcurrency (int);
- 
-PTW32_DLLPORT int PTW32_CDECL pthread_getconcurrency (void);
-
-/*
- * Read-Write Lock Functions
- */
-PTW32_DLLPORT int PTW32_CDECL pthread_rwlock_init(pthread_rwlock_t *lock,
-                                const pthread_rwlockattr_t *attr);
-
-PTW32_DLLPORT int PTW32_CDECL pthread_rwlock_destroy(pthread_rwlock_t *lock);
-
-PTW32_DLLPORT int PTW32_CDECL pthread_rwlock_tryrdlock(pthread_rwlock_t *);
-
-PTW32_DLLPORT int PTW32_CDECL pthread_rwlock_trywrlock(pthread_rwlock_t *);
-
-PTW32_DLLPORT int PTW32_CDECL pthread_rwlock_rdlock(pthread_rwlock_t *lock);
-
-PTW32_DLLPORT int PTW32_CDECL pthread_rwlock_timedrdlock(pthread_rwlock_t *lock,
-                                       const struct timespec *abstime);
-
-PTW32_DLLPORT int PTW32_CDECL pthread_rwlock_wrlock(pthread_rwlock_t *lock);
-
-PTW32_DLLPORT int PTW32_CDECL pthread_rwlock_timedwrlock(pthread_rwlock_t *lock,
-                                       const struct timespec *abstime);
-
-PTW32_DLLPORT int PTW32_CDECL pthread_rwlock_unlock(pthread_rwlock_t *lock);
-
-PTW32_DLLPORT int PTW32_CDECL pthread_rwlockattr_init (pthread_rwlockattr_t * attr);
-
-PTW32_DLLPORT int PTW32_CDECL pthread_rwlockattr_destroy (pthread_rwlockattr_t * attr);
-
-PTW32_DLLPORT int PTW32_CDECL pthread_rwlockattr_getpshared (const pthread_rwlockattr_t * attr,
-                                           int *pshared);
-
-PTW32_DLLPORT int PTW32_CDECL pthread_rwlockattr_setpshared (pthread_rwlockattr_t * attr,
-                                           int pshared);
-
-#if PTW32_LEVEL >= PTW32_LEVEL_MAX - 1
-
-/*
- * Signal Functions. Should be defined in <signal.h> but MSVC and MinGW32
- * already have signal.h that don't define these.
- */
-PTW32_DLLPORT int PTW32_CDECL pthread_kill(pthread_t thread, int sig);
-
-/*
- * Non-portable functions
- */
-
-/*
- * Compatibility with Linux.
- */
-PTW32_DLLPORT int PTW32_CDECL pthread_mutexattr_setkind_np(pthread_mutexattr_t * attr,
-                                         int kind);
-PTW32_DLLPORT int PTW32_CDECL pthread_mutexattr_getkind_np(pthread_mutexattr_t * attr,
-                                         int *kind);
-
-/*
- * Possibly supported by other POSIX threads implementations
- */
-PTW32_DLLPORT int PTW32_CDECL pthread_delay_np (struct timespec * interval);
-PTW32_DLLPORT int PTW32_CDECL pthread_num_processors_np(void);
-
-/*
- * Useful if an application wants to statically link
- * the lib rather than load the DLL at run-time.
- */
-PTW32_DLLPORT int PTW32_CDECL pthread_win32_process_attach_np(void);
-PTW32_DLLPORT int PTW32_CDECL pthread_win32_process_detach_np(void);
-PTW32_DLLPORT int PTW32_CDECL pthread_win32_thread_attach_np(void);
-PTW32_DLLPORT int PTW32_CDECL pthread_win32_thread_detach_np(void);
-
-/*
- * Features that are auto-detected at load/run time.
- */
-PTW32_DLLPORT int PTW32_CDECL pthread_win32_test_features_np(int);
-enum ptw32_features {
-  PTW32_SYSTEM_INTERLOCKED_COMPARE_EXCHANGE = 0x0001, /* System provides it. */
-  PTW32_ALERTABLE_ASYNC_CANCEL              = 0x0002  /* Can cancel blocked threads. */
-};
-
-/*
- * Register a system time change with the library.
- * Causes the library to perform various functions
- * in response to the change. Should be called whenever
- * the application's top level window receives a
- * WM_TIMECHANGE message. It can be passed directly to
- * pthread_create() as a new thread if desired.
- */
-PTW32_DLLPORT void * PTW32_CDECL pthread_timechange_handler_np(void *);
-
-#endif /*PTW32_LEVEL >= PTW32_LEVEL_MAX - 1 */
-
-#if PTW32_LEVEL >= PTW32_LEVEL_MAX
-
-/*
- * Returns the Win32 HANDLE for the POSIX thread.
- */
-PTW32_DLLPORT HANDLE PTW32_CDECL pthread_getw32threadhandle_np(pthread_t thread);
-
-
-/*
- * Protected Methods
- *
- * This function blocks until the given WIN32 handle
- * is signaled or pthread_cancel had been called.
- * This function allows the caller to hook into the
- * PThreads cancel mechanism. It is implemented using
- *
- *              WaitForMultipleObjects
- *
- * on 'waitHandle' and a manually reset WIN32 Event
- * used to implement pthread_cancel. The 'timeout'
- * argument to TimedWait is simply passed to
- * WaitForMultipleObjects.
- */
-PTW32_DLLPORT int PTW32_CDECL pthreadCancelableWait (HANDLE waitHandle);
-PTW32_DLLPORT int PTW32_CDECL pthreadCancelableTimedWait (HANDLE waitHandle,
-                                        DWORD timeout);
-
-#endif /* PTW32_LEVEL >= PTW32_LEVEL_MAX */
-
-/*
- * Thread-Safe C Runtime Library Mappings.
- */
-#ifndef _UWIN
-#  if defined(NEED_ERRNO)
-     PTW32_DLLPORT int * PTW32_CDECL _errno( void );
-#  else
-#    ifndef errno
-#      if (defined(_MT) || defined(_DLL))
-         __declspec(dllimport) extern int * __cdecl _errno(void);
-#        define errno   (*_errno())
-#      endif
-#    endif
-#  endif
-#endif
-
-/*
- * WIN32 C runtime library had been made thread-safe
- * without affecting the user interface. Provide
- * mappings from the UNIX thread-safe versions to
- * the standard C runtime library calls.
- * Only provide function mappings for functions that
- * actually exist on WIN32.
- */
-
-#if !defined(__MINGW32__)
-#define strtok_r( _s, _sep, _lasts ) \
-        ( *(_lasts) = strtok( (_s), (_sep) ) )
-#endif /* !__MINGW32__ */
-
-#define asctime_r( _tm, _buf ) \
-        ( strcpy( (_buf), asctime( (_tm) ) ), \
-          (_buf) )
-
-#define ctime_r( _clock, _buf ) \
-        ( strcpy( (_buf), ctime( (_clock) ) ),  \
-          (_buf) )
-
-#define gmtime_r( _clock, _result ) \
-        ( *(_result) = *gmtime( (_clock) ), \
-          (_result) )
-
-#define localtime_r( _clock, _result ) \
-        ( *(_result) = *localtime( (_clock) ), \
-          (_result) )
-
-#define rand_r( _seed ) \
-        ( _seed == _seed? rand() : rand() )
-
-
-/*
- * Some compiler environments don't define some things.
- */
-#if defined(__BORLANDC__)
-#  define _ftime ftime
-#  define _timeb timeb
-#endif
-
-#ifdef __cplusplus
-
-/*
- * Internal exceptions
- */
-class ptw32_exception {};
-class ptw32_exception_cancel : public ptw32_exception {};
-class ptw32_exception_exit   : public ptw32_exception {};
-
-#endif
-
-#if PTW32_LEVEL >= PTW32_LEVEL_MAX
-
-/* FIXME: This is only required if the library was built using SEH */
-/*
- * Get internal SEH tag
- */
-PTW32_DLLPORT DWORD PTW32_CDECL ptw32_get_exception_services_code(void);
-
-#endif /* PTW32_LEVEL >= PTW32_LEVEL_MAX */
-
-#ifndef PTW32_BUILD
-
-#ifdef __CLEANUP_SEH
-
-/*
- * Redefine the SEH __except keyword to ensure that applications
- * propagate our internal exceptions up to the library's internal handlers.
- */
-#define __except( E ) \
-        __except( ( GetExceptionCode() == ptw32_get_exception_services_code() ) \
-                 ? EXCEPTION_CONTINUE_SEARCH : ( E ) )
-
-#endif /* __CLEANUP_SEH */
-
-#ifdef __CLEANUP_CXX
-
-/*
- * Redefine the C++ catch keyword to ensure that applications
- * propagate our internal exceptions up to the library's internal handlers.
- */
-#ifdef _MSC_VER
-        /*
-         * WARNING: Replace any 'catch( ... )' with 'PtW32CatchAll'
-         * if you want Pthread-Win32 cancelation and pthread_exit to work.
-         */
-
-#ifndef PtW32NoCatchWarn
-
-#pragma message("Specify \"/DPtW32NoCatchWarn\" compiler flag to skip this message.")
-#pragma message("------------------------------------------------------------------")
-#pragma message("When compiling applications with MSVC++ and C++ exception handling:")
-#pragma message("  Replace any 'catch( ... )' in routines called from POSIX threads")
-#pragma message("  with 'PtW32CatchAll' or 'CATCHALL' if you want POSIX thread")
-#pragma message("  cancelation and pthread_exit to work. For example:")
-#pragma message("")
-#pragma message("    #ifdef PtW32CatchAll")
-#pragma message("      PtW32CatchAll")
-#pragma message("    #else")
-#pragma message("      catch(...)")
-#pragma message("    #endif")
-#pragma message("        {")
-#pragma message("          /* Catchall block processing */")
-#pragma message("        }")
-#pragma message("------------------------------------------------------------------")
-
-#endif
-
-#define PtW32CatchAll \
-        catch( ptw32_exception & ) { throw; } \
-        catch( ... )
-
-#else /* _MSC_VER */
-
-#define catch( E ) \
-        catch( ptw32_exception & ) { throw; } \
-        catch( E )
-
-#endif /* _MSC_VER */
-
-#endif /* __CLEANUP_CXX */
-
-#endif /* ! PTW32_BUILD */
-
-#ifdef __cplusplus
-}                               /* End of extern "C" */
-#endif                          /* __cplusplus */
-
-#ifdef PTW32__HANDLE_DEF
-# undef HANDLE
-#endif
-#ifdef PTW32__DWORD_DEF
-# undef DWORD
-#endif
-
-#undef PTW32_LEVEL
-#undef PTW32_LEVEL_MAX
-
-#endif /* ! RC_INVOKED */
-
-#endif /* PTHREAD_H */
+/* This is an implementation of the threads API of POSIX 1003.1-2001.
+ *
+ * --------------------------------------------------------------------------
+ *
+ *      Pthreads-win32 - POSIX Threads Library for Win32
+ *      Copyright(C) 1998 John E. Bossom
+ *      Copyright(C) 1999,2005 Pthreads-win32 contributors
+ * 
+ *      Contact Email: rpj@callisto.canberra.edu.au
+ * 
+ *      The current list of contributors is contained
+ *      in the file CONTRIBUTORS included with the source
+ *      code distribution. The list can also be seen at the
+ *      following World Wide Web location:
+ *      http://sources.redhat.com/pthreads-win32/contributors.html
+ * 
+ *      This library is free software; you can redistribute it and/or
+ *      modify it under the terms of the GNU Lesser General Public
+ *      License as published by the Free Software Foundation; either
+ *      version 2 of the License, or (at your option) any later version.
+ * 
+ *      This library is distributed in the hope that it will be useful,
+ *      but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *      Lesser General Public License for more details.
+ * 
+ *      You should have received a copy of the GNU Lesser General Public
+ *      License along with this library in the file COPYING.LIB;
+ *      if not, write to the Free Software Foundation, Inc.,
+ *      59 Temple Place - Suite 330, Boston, MA 02111-1307, USA
+ */
+
+#if !defined( PTHREAD_H )
+#define PTHREAD_H
+
+/*
+ * See the README file for an explanation of the pthreads-win32 version
+ * numbering scheme and how the DLL is named etc.
+ */
+#define PTW32_VERSION 2,7,0,0
+#define PTW32_VERSION_STRING "2, 7, 0, 0\0"
+
+/* There are three implementations of cancel cleanup.
+ * Note that pthread.h is included in both application
+ * compilation units and also internally for the library.
+ * The code here and within the library aims to work
+ * for all reasonable combinations of environments.
+ *
+ * The three implementations are:
+ *
+ *   WIN32 SEH
+ *   C
+ *   C++
+ *
+ * Please note that exiting a push/pop block via
+ * "return", "exit", "break", or "continue" will
+ * lead to different behaviour amongst applications
+ * depending upon whether the library was built
+ * using SEH, C++, or C. For example, a library built
+ * with SEH will call the cleanup routine, while both
+ * C++ and C built versions will not.
+ */
+
+/*
+ * Define defaults for cleanup code.
+ * Note: Unless the build explicitly defines one of the following, then
+ * we default to standard C style cleanup. This style uses setjmp/longjmp
+ * in the cancelation and thread exit implementations and therefore won't
+ * do stack unwinding if linked to applications that have it (e.g.
+ * C++ apps). This is currently consistent with most/all commercial Unix
+ * POSIX threads implementations.
+ */
+#if !defined( __CLEANUP_SEH ) && !defined( __CLEANUP_CXX ) && !defined( __CLEANUP_C )
+# define __CLEANUP_C
+#endif
+
+#if defined( __CLEANUP_SEH ) && ( !defined( _MSC_VER ) && !defined(PTW32_RC_MSC))
+#error ERROR [__FILE__, line __LINE__]: SEH is not supported for this compiler.
+#endif
+
+/*
+ * Stop here if we are being included by the resource compiler.
+ */
+#ifndef RC_INVOKED
+
+#undef PTW32_LEVEL
+
+#if defined(_POSIX_SOURCE)
+#define PTW32_LEVEL 0
+/* Early POSIX */
+#endif
+
+#if defined(_POSIX_C_SOURCE) && _POSIX_C_SOURCE >= 199309
+#undef PTW32_LEVEL
+#define PTW32_LEVEL 1
+/* Include 1b, 1c and 1d */
+#endif
+
+#if defined(INCLUDE_NP)
+#undef PTW32_LEVEL
+#define PTW32_LEVEL 2
+/* Include Non-Portable extensions */
+#endif
+
+#define PTW32_LEVEL_MAX 3
+
+#if !defined(PTW32_LEVEL)
+#define PTW32_LEVEL PTW32_LEVEL_MAX
+/* Include everything */
+#endif
+
+#ifdef _UWIN
+#   define HAVE_STRUCT_TIMESPEC 1
+#   define HAVE_SIGNAL_H        1
+#   undef HAVE_CONFIG_H
+#   pragma comment(lib, "pthread")
+#endif
+
+/*
+ * -------------------------------------------------------------
+ *
+ *
+ * Module: pthread.h
+ *
+ * Purpose:
+ *      Provides an implementation of PThreads based upon the
+ *      standard:
+ *
+ *              POSIX 1003.1-2001
+ *  and
+ *    The Single Unix Specification version 3
+ *
+ *    (these two are equivalent)
+ *
+ *      in order to enhance code portability between Windows,
+ *  various commercial Unix implementations, and Linux.
+ *
+ *      See the ANNOUNCE file for a full list of conforming
+ *      routines and defined constants, and a list of missing
+ *      routines and constants not defined in this implementation.
+ *
+ * Authors:
+ *      There have been many contributors to this library.
+ *      The initial implementation was contributed by
+ *      John Bossom, and several others have provided major
+ *      sections or revisions of parts of the implementation.
+ *      Often significant effort has been contributed to
+ *      find and fix important bugs and other problems to
+ *      improve the reliability of the library, which sometimes
+ *      is not reflected in the amount of code which changed as
+ *      result.
+ *      As much as possible, the contributors are acknowledged
+ *      in the ChangeLog file in the source code distribution
+ *      where their changes are noted in detail.
+ *
+ *      Contributors are listed in the CONTRIBUTORS file.
+ *
+ *      As usual, all bouquets go to the contributors, and all
+ *      brickbats go to the project maintainer.
+ *
+ * Maintainer:
+ *      The code base for this project is coordinated and
+ *      eventually pre-tested, packaged, and made available by
+ *
+ *              Ross Johnson <rpj@callisto.canberra.edu.au>
+ *
+ * QA Testers:
+ *      Ultimately, the library is tested in the real world by
+ *      a host of competent and demanding scientists and
+ *      engineers who report bugs and/or provide solutions
+ *      which are then fixed or incorporated into subsequent
+ *      versions of the library. Each time a bug is fixed, a
+ *      test case is written to prove the fix and ensure
+ *      that later changes to the code don't reintroduce the
+ *      same error. The number of test cases is slowly growing
+ *      and therefore so is the code reliability.
+ *
+ * Compliance:
+ *      See the file ANNOUNCE for the list of implemented
+ *      and not-implemented routines and defined options.
+ *      Of course, these are all defined is this file as well.
+ *
+ * Web site:
+ *      The source code and other information about this library
+ *      are available from
+ *
+ *              http://sources.redhat.com/pthreads-win32/
+ *
+ * -------------------------------------------------------------
+ */
+
+/* Try to avoid including windows.h */
+#if defined(__MINGW32__) && defined(__cplusplus)
+#define PTW32_INCLUDE_WINDOWS_H
+#endif
+
+#ifdef PTW32_INCLUDE_WINDOWS_H
+#include <windows.h>
+#endif
+
+#if defined(_MSC_VER) && _MSC_VER < 1300 || defined(__DMC__)
+/*
+ * VC++6.0 or early compiler's header has no DWORD_PTR type.
+ */
+typedef unsigned long DWORD_PTR;
+#endif
+/*
+ * -----------------
+ * autoconf switches
+ * -----------------
+ */
+
+#if HAVE_CONFIG_H
+#include "config.h"
+#endif /* HAVE_CONFIG_H */
+
+#ifndef NEED_FTIME
+#include <time.h>
+#else /* NEED_FTIME */
+/* use native WIN32 time API */
+#endif /* NEED_FTIME */
+
+#if HAVE_SIGNAL_H
+#include <signal.h>
+#endif /* HAVE_SIGNAL_H */
+
+#include <setjmp.h>
+#include <limits.h>
+
+/*
+ * Boolean values to make us independent of system includes.
+ */
+enum {
+  PTW32_FALSE = 0,
+  PTW32_TRUE = (! PTW32_FALSE)
+};
+
+/*
+ * This is a duplicate of what is in the autoconf config.h,
+ * which is only used when building the pthread-win32 libraries.
+ */
+
+#ifndef PTW32_CONFIG_H
+#  if defined(WINCE)
+#    define NEED_ERRNO
+#    define NEED_SEM
+#  endif
+#  if defined(_UWIN) || defined(__MINGW32__)
+#    define HAVE_MODE_T
+#  endif
+#endif
+
+/*
+ *
+ */
+
+#if PTW32_LEVEL >= PTW32_LEVEL_MAX
+#ifdef NEED_ERRNO
+#include "need_errno.h"
+#else
+#include <errno.h>
+#endif
+#endif /* PTW32_LEVEL >= PTW32_LEVEL_MAX */
+
+/*
+ * Several systems don't define some error numbers.
+ */
+#ifndef ENOTSUP
+#  define ENOTSUP 48   /* This is the value in Solaris. */
+#endif
+
+#ifndef ETIMEDOUT
+#  define ETIMEDOUT 10060     /* This is the value in winsock.h. */
+#endif
+
+#ifndef ENOSYS
+#  define ENOSYS 140     /* Semi-arbitrary value */
+#endif
+
+#ifndef EDEADLK
+#  ifdef EDEADLOCK
+#    define EDEADLK EDEADLOCK
+#  else
+#    define EDEADLK 36     /* This is the value in MSVC. */
+#  endif
+#endif
+
+#include <sched.h>
+
+/*
+ * To avoid including windows.h we define only those things that we
+ * actually need from it.
+ */
+#ifndef PTW32_INCLUDE_WINDOWS_H
+#ifndef HANDLE
+# define PTW32__HANDLE_DEF
+# define HANDLE void *
+#endif
+#ifndef DWORD
+# define PTW32__DWORD_DEF
+# define DWORD unsigned long
+#endif
+#endif
+
+#ifndef HAVE_STRUCT_TIMESPEC
+#define HAVE_STRUCT_TIMESPEC 1
+struct timespec {
+        long tv_sec;
+        long tv_nsec;
+};
+#endif /* HAVE_STRUCT_TIMESPEC */
+
+#ifndef SIG_BLOCK
+#define SIG_BLOCK 0
+#endif /* SIG_BLOCK */
+
+#ifndef SIG_UNBLOCK 
+#define SIG_UNBLOCK 1
+#endif /* SIG_UNBLOCK */
+
+#ifndef SIG_SETMASK
+#define SIG_SETMASK 2
+#endif /* SIG_SETMASK */
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif                          /* __cplusplus */
+
+/*
+ * -------------------------------------------------------------
+ *
+ * POSIX 1003.1-2001 Options
+ * =========================
+ *
+ * Options are normally set in <unistd.h>, which is not provided
+ * with pthreads-win32.
+ *
+ * For conformance with the Single Unix Specification (version 3), all of the
+ * options below are defined, and have a value of either -1 (not supported)
+ * or 200112L (supported).
+ *
+ * These options can neither be left undefined nor have a value of 0, because
+ * either indicates that sysconf(), which is not implemented, may be used at
+ * runtime to check the status of the option.
+ *
+ * _POSIX_THREADS (== 200112L)
+ *                      If == 200112L, you can use threads
+ *
+ * _POSIX_THREAD_ATTR_STACKSIZE (== 200112L)
+ *                      If == 200112L, you can control the size of a thread's
+ *                      stack
+ *                              pthread_attr_getstacksize
+ *                              pthread_attr_setstacksize
+ *
+ * _POSIX_THREAD_ATTR_STACKADDR (== -1)
+ *                      If == 200112L, you can allocate and control a thread's
+ *                      stack. If not supported, the following functions
+ *                      will return ENOSYS, indicating they are not
+ *                      supported:
+ *                              pthread_attr_getstackaddr
+ *                              pthread_attr_setstackaddr
+ *
+ * _POSIX_THREAD_PRIORITY_SCHEDULING (== -1)
+ *                      If == 200112L, you can use realtime scheduling.
+ *                      This option indicates that the behaviour of some
+ *                      implemented functions conforms to the additional TPS
+ *                      requirements in the standard. E.g. rwlocks favour
+ *                      writers over readers when threads have equal priority.
+ *
+ * _POSIX_THREAD_PRIO_INHERIT (== -1)
+ *                      If == 200112L, you can create priority inheritance
+ *                      mutexes.
+ *                              pthread_mutexattr_getprotocol +
+ *                              pthread_mutexattr_setprotocol +
+ *
+ * _POSIX_THREAD_PRIO_PROTECT (== -1)
+ *                      If == 200112L, you can create priority ceiling mutexes
+ *                      Indicates the availability of:
+ *                              pthread_mutex_getprioceiling
+ *                              pthread_mutex_setprioceiling
+ *                              pthread_mutexattr_getprioceiling
+ *                              pthread_mutexattr_getprotocol     +
+ *                              pthread_mutexattr_setprioceiling
+ *                              pthread_mutexattr_setprotocol     +
+ *
+ * _POSIX_THREAD_PROCESS_SHARED (== -1)
+ *                      If set, you can create mutexes and condition
+ *                      variables that can be shared with another
+ *                      process.If set, indicates the availability
+ *                      of:
+ *                              pthread_mutexattr_getpshared
+ *                              pthread_mutexattr_setpshared
+ *                              pthread_condattr_getpshared
+ *                              pthread_condattr_setpshared
+ *
+ * _POSIX_THREAD_SAFE_FUNCTIONS (== 200112L)
+ *                      If == 200112L you can use the special *_r library
+ *                      functions that provide thread-safe behaviour
+ *
+ * _POSIX_READER_WRITER_LOCKS (== 200112L)
+ *                      If == 200112L, you can use read/write locks
+ *
+ * _POSIX_SPIN_LOCKS (== 200112L)
+ *                      If == 200112L, you can use spin locks
+ *
+ * _POSIX_BARRIERS (== 200112L)
+ *                      If == 200112L, you can use barriers
+ *
+ *      + These functions provide both 'inherit' and/or
+ *        'protect' protocol, based upon these macro
+ *        settings.
+ *
+ * -------------------------------------------------------------
+ */
+
+/*
+ * POSIX Options
+ */
+#undef _POSIX_THREADS
+#define _POSIX_THREADS 200112L
+
+#undef _POSIX_READER_WRITER_LOCKS
+#define _POSIX_READER_WRITER_LOCKS 200112L
+
+#undef _POSIX_SPIN_LOCKS
+#define _POSIX_SPIN_LOCKS 200112L
+
+#undef _POSIX_BARRIERS
+#define _POSIX_BARRIERS 200112L
+
+#undef _POSIX_THREAD_SAFE_FUNCTIONS
+#define _POSIX_THREAD_SAFE_FUNCTIONS 200112L
+
+#undef _POSIX_THREAD_ATTR_STACKSIZE
+#define _POSIX_THREAD_ATTR_STACKSIZE 200112L
+
+/*
+ * The following options are not supported
+ */
+#undef _POSIX_THREAD_ATTR_STACKADDR
+#define _POSIX_THREAD_ATTR_STACKADDR -1
+
+#undef _POSIX_THREAD_PRIO_INHERIT
+#define _POSIX_THREAD_PRIO_INHERIT -1
+
+#undef _POSIX_THREAD_PRIO_PROTECT
+#define _POSIX_THREAD_PRIO_PROTECT -1
+
+/* TPS is not fully supported.  */
+#undef _POSIX_THREAD_PRIORITY_SCHEDULING
+#define _POSIX_THREAD_PRIORITY_SCHEDULING -1
+
+#undef _POSIX_THREAD_PROCESS_SHARED
+#define _POSIX_THREAD_PROCESS_SHARED -1
+
+
+/*
+ * POSIX 1003.1-2001 Limits
+ * ===========================
+ *
+ * These limits are normally set in <limits.h>, which is not provided with
+ * pthreads-win32.
+ *
+ * PTHREAD_DESTRUCTOR_ITERATIONS
+ *                      Maximum number of attempts to destroy
+ *                      a thread's thread-specific data on
+ *                      termination (must be at least 4)
+ *
+ * PTHREAD_KEYS_MAX
+ *                      Maximum number of thread-specific data keys
+ *                      available per process (must be at least 128)
+ *
+ * PTHREAD_STACK_MIN
+ *                      Minimum supported stack size for a thread
+ *
+ * PTHREAD_THREADS_MAX
+ *                      Maximum number of threads supported per
+ *                      process (must be at least 64).
+ *
+ * SEM_NSEMS_MAX
+ *                      The maximum number of semaphores a process can have.
+ *                      (must be at least 256)
+ *
+ * SEM_VALUE_MAX
+ *                      The maximum value a semaphore can have.
+ *                      (must be at least 32767)
+ *
+ */
+#undef _POSIX_THREAD_DESTRUCTOR_ITERATIONS
+#define _POSIX_THREAD_DESTRUCTOR_ITERATIONS     4
+
+#undef PTHREAD_DESTRUCTOR_ITERATIONS
+#define PTHREAD_DESTRUCTOR_ITERATIONS           _POSIX_THREAD_DESTRUCTOR_ITERATIONS
+
+#undef _POSIX_THREAD_KEYS_MAX
+#define _POSIX_THREAD_KEYS_MAX                  128
+
+#undef PTHREAD_KEYS_MAX
+#define PTHREAD_KEYS_MAX                        _POSIX_THREAD_KEYS_MAX
+
+#undef PTHREAD_STACK_MIN
+#define PTHREAD_STACK_MIN                       0
+
+#undef _POSIX_THREAD_THREADS_MAX
+#define _POSIX_THREAD_THREADS_MAX               64
+
+  /* Arbitrary value */
+#undef PTHREAD_THREADS_MAX
+#define PTHREAD_THREADS_MAX                     2019
+
+#undef _POSIX_SEM_NSEMS_MAX
+#define _POSIX_SEM_NSEMS_MAX                    256
+
+  /* Arbitrary value */
+#undef SEM_NSEMS_MAX
+#define SEM_NSEMS_MAX                           1024
+
+#undef _POSIX_SEM_VALUE_MAX
+#define _POSIX_SEM_VALUE_MAX                    32767
+
+#undef SEM_VALUE_MAX
+#define SEM_VALUE_MAX                           INT_MAX
+
+
+#if __GNUC__ && ! defined (__declspec)
+# error Please upgrade your GNU compiler to one that supports __declspec.
+#endif
+
+/*
+ * When building the DLL code, you should define PTW32_BUILD so that
+ * the variables/functions are exported correctly. When using the DLL,
+ * do NOT define PTW32_BUILD, and then the variables/functions will
+ * be imported correctly.
+ */
+#ifndef PTW32_STATIC_LIB
+#  ifdef PTW32_BUILD
+#    define PTW32_DLLPORT __declspec (dllexport)
+#  else
+#    define PTW32_DLLPORT __declspec (dllimport)
+#  endif
+#else
+#  define PTW32_DLLPORT
+#endif
+
+/*
+ * The Open Watcom C/C++ compiler uses a non-standard calling convention
+ * that passes function args in registers unless __cdecl is explicitly specified
+ * in exposed function prototypes.
+ *
+ * We force all calls to cdecl even though this could slow Watcom code down
+ * slightly. If you know that the Watcom compiler will be used to build both
+ * the DLL and application, then you can probably define this as a null string.
+ * Remember that pthread.h (this file) is used for both the DLL and application builds.
+ */
+#define PTW32_CDECL __cdecl
+
+#if defined(_UWIN) && PTW32_LEVEL >= PTW32_LEVEL_MAX
+#   include     <sys/types.h>
+#else
+/*
+ * Generic handle type - intended to extend uniqueness beyond
+ * that available with a simple pointer. It should scale for either
+ * IA-32 or IA-64.
+ */
+typedef struct {
+    void * p;                   /* Pointer to actual object */
+    unsigned int x;             /* Extra information - reuse count etc */
+} ptw32_handle_t;
+
+typedef ptw32_handle_t pthread_t;
+typedef struct pthread_attr_t_ * pthread_attr_t;
+typedef struct pthread_once_t_ pthread_once_t;
+typedef struct pthread_key_t_ * pthread_key_t;
+typedef struct pthread_mutex_t_ * pthread_mutex_t;
+typedef struct pthread_mutexattr_t_ * pthread_mutexattr_t;
+typedef struct pthread_cond_t_ * pthread_cond_t;
+typedef struct pthread_condattr_t_ * pthread_condattr_t;
+#endif
+typedef struct pthread_rwlock_t_ * pthread_rwlock_t;
+typedef struct pthread_rwlockattr_t_ * pthread_rwlockattr_t;
+typedef struct pthread_spinlock_t_ * pthread_spinlock_t;
+typedef struct pthread_barrier_t_ * pthread_barrier_t;
+typedef struct pthread_barrierattr_t_ * pthread_barrierattr_t;
+
+/*
+ * ====================
+ * ====================
+ * POSIX Threads
+ * ====================
+ * ====================
+ */
+
+enum {
+/*
+ * pthread_attr_{get,set}detachstate
+ */
+  PTHREAD_CREATE_JOINABLE       = 0,  /* Default */
+  PTHREAD_CREATE_DETACHED       = 1,
+
+/*
+ * pthread_attr_{get,set}inheritsched
+ */
+  PTHREAD_INHERIT_SCHED         = 0,
+  PTHREAD_EXPLICIT_SCHED        = 1,  /* Default */
+
+/*
+ * pthread_{get,set}scope
+ */
+  PTHREAD_SCOPE_PROCESS         = 0,
+  PTHREAD_SCOPE_SYSTEM          = 1,  /* Default */
+
+/*
+ * pthread_setcancelstate paramters
+ */
+  PTHREAD_CANCEL_ENABLE         = 0,  /* Default */
+  PTHREAD_CANCEL_DISABLE        = 1,
+
+/*
+ * pthread_setcanceltype parameters
+ */
+  PTHREAD_CANCEL_ASYNCHRONOUS   = 0,
+  PTHREAD_CANCEL_DEFERRED       = 1,  /* Default */
+
+/*
+ * pthread_mutexattr_{get,set}pshared
+ * pthread_condattr_{get,set}pshared
+ */
+  PTHREAD_PROCESS_PRIVATE       = 0,
+  PTHREAD_PROCESS_SHARED        = 1,
+
+/*
+ * pthread_barrier_wait
+ */
+  PTHREAD_BARRIER_SERIAL_THREAD = -1
+};
+
+/*
+ * ====================
+ * ====================
+ * Cancelation
+ * ====================
+ * ====================
+ */
+#define PTHREAD_CANCELED       ((void *) -1)
+
+
+/*
+ * ====================
+ * ====================
+ * Once Key
+ * ====================
+ * ====================
+ */
+#define PTHREAD_ONCE_INIT       { PTW32_FALSE, 0, 0, 0}
+
+struct pthread_once_t_
+{
+  int          done;        /* indicates if user function has been executed */
+  void *       lock;
+  int          reserved1;
+  int          reserved2;
+};
+
+
+/*
+ * ====================
+ * ====================
+ * Object initialisers
+ * ====================
+ * ====================
+ */
+#define PTHREAD_MUTEX_INITIALIZER ((pthread_mutex_t) -1)
+#define PTHREAD_RECURSIVE_MUTEX_INITIALIZER ((pthread_mutex_t) -2)
+#define PTHREAD_ERRORCHECK_MUTEX_INITIALIZER ((pthread_mutex_t) -3)
+
+/*
+ * Compatibility with LinuxThreads
+ */
+#define PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP PTHREAD_RECURSIVE_MUTEX_INITIALIZER
+#define PTHREAD_ERRORCHECK_MUTEX_INITIALIZER_NP PTHREAD_ERRORCHECK_MUTEX_INITIALIZER
+
+#define PTHREAD_COND_INITIALIZER ((pthread_cond_t) -1)
+
+#define PTHREAD_RWLOCK_INITIALIZER ((pthread_rwlock_t) -1)
+
+#define PTHREAD_SPINLOCK_INITIALIZER ((pthread_spinlock_t) -1)
+
+
+/*
+ * Mutex types.
+ */
+enum
+{
+  /* Compatibility with LinuxThreads */
+  PTHREAD_MUTEX_FAST_NP,
+  PTHREAD_MUTEX_RECURSIVE_NP,
+  PTHREAD_MUTEX_ERRORCHECK_NP,
+  PTHREAD_MUTEX_TIMED_NP = PTHREAD_MUTEX_FAST_NP,
+  PTHREAD_MUTEX_ADAPTIVE_NP = PTHREAD_MUTEX_FAST_NP,
+  /* For compatibility with POSIX */
+  PTHREAD_MUTEX_NORMAL = PTHREAD_MUTEX_FAST_NP,
+  PTHREAD_MUTEX_RECURSIVE = PTHREAD_MUTEX_RECURSIVE_NP,
+  PTHREAD_MUTEX_ERRORCHECK = PTHREAD_MUTEX_ERRORCHECK_NP,
+  PTHREAD_MUTEX_DEFAULT = PTHREAD_MUTEX_NORMAL
+};
+
+
+typedef struct ptw32_cleanup_t ptw32_cleanup_t;
+
+#if defined(_MSC_VER)
+/* Disable MSVC 'anachronism used' warning */
+#pragma warning( disable : 4229 )
+#endif
+
+typedef void (* PTW32_CDECL ptw32_cleanup_callback_t)(void *);
+
+#if defined(_MSC_VER)
+#pragma warning( default : 4229 )
+#endif
+
+struct ptw32_cleanup_t
+{
+  ptw32_cleanup_callback_t routine;
+  void *arg;
+  struct ptw32_cleanup_t *prev;
+};
+
+#ifdef __CLEANUP_SEH
+        /*
+         * WIN32 SEH version of cancel cleanup.
+         */
+
+#define pthread_cleanup_push( _rout, _arg ) \
+        { \
+            ptw32_cleanup_t     _cleanup; \
+            \
+        _cleanup.routine        = (ptw32_cleanup_callback_t)(_rout); \
+            _cleanup.arg        = (_arg); \
+            __try \
+              { \
+
+#define pthread_cleanup_pop( _execute ) \
+              } \
+            __finally \
+                { \
+                    if( _execute || AbnormalTermination()) \
+                      { \
+                          (*(_cleanup.routine))( _cleanup.arg ); \
+                      } \
+                } \
+        }
+
+#else /* __CLEANUP_SEH */
+
+#ifdef __CLEANUP_C
+
+        /*
+         * C implementation of PThreads cancel cleanup
+         */
+
+#define pthread_cleanup_push( _rout, _arg ) \
+        { \
+            ptw32_cleanup_t     _cleanup; \
+            \
+            ptw32_push_cleanup( &_cleanup, (ptw32_cleanup_callback_t) (_rout), (_arg) ); \
+
+#define pthread_cleanup_pop( _execute ) \
+            (void) ptw32_pop_cleanup( _execute ); \
+        }
+
+#else /* __CLEANUP_C */
+
+#ifdef __CLEANUP_CXX
+
+        /*
+         * C++ version of cancel cleanup.
+         * - John E. Bossom.
+         */
+
+        class PThreadCleanup {
+          /*
+           * PThreadCleanup
+           *
+           * Purpose
+           *      This class is a C++ helper class that is
+           *      used to implement pthread_cleanup_push/
+           *      pthread_cleanup_pop.
+           *      The destructor of this class automatically
+           *      pops the pushed cleanup routine regardless
+           *      of how the code exits the scope
+           *      (i.e. such as by an exception)
+           */
+      ptw32_cleanup_callback_t cleanUpRout;
+          void    *       obj;
+          int             executeIt;
+
+        public:
+          PThreadCleanup() :
+            cleanUpRout( 0 ),
+            obj( 0 ),
+            executeIt( 0 )
+            /*
+             * No cleanup performed
+             */
+            {
+            }
+
+          PThreadCleanup(
+             ptw32_cleanup_callback_t routine,
+                         void    *       arg ) :
+            cleanUpRout( routine ),
+            obj( arg ),
+            executeIt( 1 )
+            /*
+             * Registers a cleanup routine for 'arg'
+             */
+            {
+            }
+
+          ~PThreadCleanup()
+            {
+              if ( executeIt && ((void *) cleanUpRout != (void *) 0) )
+                {
+                  (void) (*cleanUpRout)( obj );
+                }
+            }
+
+          void execute( int exec )
+            {
+              executeIt = exec;
+            }
+        };
+
+        /*
+         * C++ implementation of PThreads cancel cleanup;
+         * This implementation takes advantage of a helper
+         * class who's destructor automatically calls the
+         * cleanup routine if we exit our scope weirdly
+         */
+#define pthread_cleanup_push( _rout, _arg ) \
+        { \
+            PThreadCleanup  cleanup((ptw32_cleanup_callback_t)(_rout), \
+                                    (void *) (_arg) );
+
+#define pthread_cleanup_pop( _execute ) \
+            cleanup.execute( _execute ); \
+        }
+
+#else
+
+#error ERROR [__FILE__, line __LINE__]: Cleanup type undefined.
+
+#endif /* __CLEANUP_CXX */
+
+#endif /* __CLEANUP_C */
+
+#endif /* __CLEANUP_SEH */
+
+/*
+ * ===============
+ * ===============
+ * Methods
+ * ===============
+ * ===============
+ */
+
+/*
+ * PThread Attribute Functions
+ */
+PTW32_DLLPORT int PTW32_CDECL pthread_attr_init (pthread_attr_t * attr);
+
+PTW32_DLLPORT int PTW32_CDECL pthread_attr_destroy (pthread_attr_t * attr);
+
+PTW32_DLLPORT int PTW32_CDECL pthread_attr_getdetachstate (const pthread_attr_t * attr,
+                                         int *detachstate);
+
+PTW32_DLLPORT int PTW32_CDECL pthread_attr_getstackaddr (const pthread_attr_t * attr,
+                                       void **stackaddr);
+
+PTW32_DLLPORT int PTW32_CDECL pthread_attr_getstacksize (const pthread_attr_t * attr,
+                                       size_t * stacksize);
+
+PTW32_DLLPORT int PTW32_CDECL pthread_attr_setdetachstate (pthread_attr_t * attr,
+                                         int detachstate);
+
+PTW32_DLLPORT int PTW32_CDECL pthread_attr_setstackaddr (pthread_attr_t * attr,
+                                       void *stackaddr);
+
+PTW32_DLLPORT int PTW32_CDECL pthread_attr_setstacksize (pthread_attr_t * attr,
+                                       size_t stacksize);
+
+PTW32_DLLPORT int PTW32_CDECL pthread_attr_getschedparam (const pthread_attr_t *attr,
+                                        struct sched_param *param);
+
+PTW32_DLLPORT int PTW32_CDECL pthread_attr_setschedparam (pthread_attr_t *attr,
+                                        const struct sched_param *param);
+
+PTW32_DLLPORT int PTW32_CDECL pthread_attr_setschedpolicy (pthread_attr_t *,
+                                         int);
+
+PTW32_DLLPORT int PTW32_CDECL pthread_attr_getschedpolicy (pthread_attr_t *,
+                                         int *);
+
+PTW32_DLLPORT int PTW32_CDECL pthread_attr_setinheritsched(pthread_attr_t * attr,
+                                         int inheritsched);
+
+PTW32_DLLPORT int PTW32_CDECL pthread_attr_getinheritsched(pthread_attr_t * attr,
+                                         int * inheritsched);
+
+PTW32_DLLPORT int PTW32_CDECL pthread_attr_setscope (pthread_attr_t *,
+                                   int);
+
+PTW32_DLLPORT int PTW32_CDECL pthread_attr_getscope (const pthread_attr_t *,
+                                   int *);
+
+/*
+ * PThread Functions
+ */
+PTW32_DLLPORT int PTW32_CDECL pthread_create (pthread_t * tid,
+                            const pthread_attr_t * attr,
+                            void *(*start) (void *),
+                            void *arg);
+
+PTW32_DLLPORT int PTW32_CDECL pthread_detach (pthread_t tid);
+
+PTW32_DLLPORT int PTW32_CDECL pthread_equal (pthread_t t1,
+                           pthread_t t2);
+
+PTW32_DLLPORT void PTW32_CDECL pthread_exit (void *value_ptr);
+
+PTW32_DLLPORT int PTW32_CDECL pthread_join (pthread_t thread,
+                          void **value_ptr);
+
+PTW32_DLLPORT pthread_t PTW32_CDECL pthread_self (void);
+
+PTW32_DLLPORT int PTW32_CDECL pthread_cancel (pthread_t thread);
+
+PTW32_DLLPORT int PTW32_CDECL pthread_setcancelstate (int state,
+                                    int *oldstate);
+
+PTW32_DLLPORT int PTW32_CDECL pthread_setcanceltype (int type,
+                                   int *oldtype);
+
+PTW32_DLLPORT void PTW32_CDECL pthread_testcancel (void);
+
+PTW32_DLLPORT int PTW32_CDECL pthread_once (pthread_once_t * once_control,
+                          void (*init_routine) (void));
+
+#if PTW32_LEVEL >= PTW32_LEVEL_MAX
+PTW32_DLLPORT ptw32_cleanup_t * PTW32_CDECL ptw32_pop_cleanup (int execute);
+
+PTW32_DLLPORT void PTW32_CDECL ptw32_push_cleanup (ptw32_cleanup_t * cleanup,
+                                 void (*routine) (void *),
+                                 void *arg);
+#endif /* PTW32_LEVEL >= PTW32_LEVEL_MAX */
+
+/*
+ * Thread Specific Data Functions
+ */
+PTW32_DLLPORT int PTW32_CDECL pthread_key_create (pthread_key_t * key,
+                                void (*destructor) (void *));
+
+PTW32_DLLPORT int PTW32_CDECL pthread_key_delete (pthread_key_t key);
+
+PTW32_DLLPORT int PTW32_CDECL pthread_setspecific (pthread_key_t key,
+                                 const void *value);
+
+PTW32_DLLPORT void * PTW32_CDECL pthread_getspecific (pthread_key_t key);
+
+
+/*
+ * Mutex Attribute Functions
+ */
+PTW32_DLLPORT int PTW32_CDECL pthread_mutexattr_init (pthread_mutexattr_t * attr);
+
+PTW32_DLLPORT int PTW32_CDECL pthread_mutexattr_destroy (pthread_mutexattr_t * attr);
+
+PTW32_DLLPORT int PTW32_CDECL pthread_mutexattr_getpshared (const pthread_mutexattr_t
+                                          * attr,
+                                          int *pshared);
+
+PTW32_DLLPORT int PTW32_CDECL pthread_mutexattr_setpshared (pthread_mutexattr_t * attr,
+                                          int pshared);
+
+PTW32_DLLPORT int PTW32_CDECL pthread_mutexattr_settype (pthread_mutexattr_t * attr, int kind);
+PTW32_DLLPORT int PTW32_CDECL pthread_mutexattr_gettype (pthread_mutexattr_t * attr, int *kind);
+
+/*
+ * Barrier Attribute Functions
+ */
+PTW32_DLLPORT int PTW32_CDECL pthread_barrierattr_init (pthread_barrierattr_t * attr);
+
+PTW32_DLLPORT int PTW32_CDECL pthread_barrierattr_destroy (pthread_barrierattr_t * attr);
+
+PTW32_DLLPORT int PTW32_CDECL pthread_barrierattr_getpshared (const pthread_barrierattr_t
+                                            * attr,
+                                            int *pshared);
+
+PTW32_DLLPORT int PTW32_CDECL pthread_barrierattr_setpshared (pthread_barrierattr_t * attr,
+                                            int pshared);
+
+/*
+ * Mutex Functions
+ */
+PTW32_DLLPORT int PTW32_CDECL pthread_mutex_init (pthread_mutex_t * mutex,
+                                const pthread_mutexattr_t * attr);
+
+PTW32_DLLPORT int PTW32_CDECL pthread_mutex_destroy (pthread_mutex_t * mutex);
+
+PTW32_DLLPORT int PTW32_CDECL pthread_mutex_lock (pthread_mutex_t * mutex);
+
+PTW32_DLLPORT int PTW32_CDECL pthread_mutex_timedlock(pthread_mutex_t *mutex,
+                                    const struct timespec *abstime);
+
+PTW32_DLLPORT int PTW32_CDECL pthread_mutex_trylock (pthread_mutex_t * mutex);
+
+PTW32_DLLPORT int PTW32_CDECL pthread_mutex_unlock (pthread_mutex_t * mutex);
+
+/*
+ * Spinlock Functions
+ */
+PTW32_DLLPORT int PTW32_CDECL pthread_spin_init (pthread_spinlock_t * lock, int pshared);
+
+PTW32_DLLPORT int PTW32_CDECL pthread_spin_destroy (pthread_spinlock_t * lock);
+
+PTW32_DLLPORT int PTW32_CDECL pthread_spin_lock (pthread_spinlock_t * lock);
+
+PTW32_DLLPORT int PTW32_CDECL pthread_spin_trylock (pthread_spinlock_t * lock);
+
+PTW32_DLLPORT int PTW32_CDECL pthread_spin_unlock (pthread_spinlock_t * lock);
+
+/*
+ * Barrier Functions
+ */
+PTW32_DLLPORT int PTW32_CDECL pthread_barrier_init (pthread_barrier_t * barrier,
+                                  const pthread_barrierattr_t * attr,
+                                  unsigned int count);
+
+PTW32_DLLPORT int PTW32_CDECL pthread_barrier_destroy (pthread_barrier_t * barrier);
+
+PTW32_DLLPORT int PTW32_CDECL pthread_barrier_wait (pthread_barrier_t * barrier);
+
+/*
+ * Condition Variable Attribute Functions
+ */
+PTW32_DLLPORT int PTW32_CDECL pthread_condattr_init (pthread_condattr_t * attr);
+
+PTW32_DLLPORT int PTW32_CDECL pthread_condattr_destroy (pthread_condattr_t * attr);
+
+PTW32_DLLPORT int PTW32_CDECL pthread_condattr_getpshared (const pthread_condattr_t * attr,
+                                         int *pshared);
+
+PTW32_DLLPORT int PTW32_CDECL pthread_condattr_setpshared (pthread_condattr_t * attr,
+                                         int pshared);
+
+/*
+ * Condition Variable Functions
+ */
+PTW32_DLLPORT int PTW32_CDECL pthread_cond_init (pthread_cond_t * cond,
+                               const pthread_condattr_t * attr);
+
+PTW32_DLLPORT int PTW32_CDECL pthread_cond_destroy (pthread_cond_t * cond);
+
+PTW32_DLLPORT int PTW32_CDECL pthread_cond_wait (pthread_cond_t * cond,
+                               pthread_mutex_t * mutex);
+
+PTW32_DLLPORT int PTW32_CDECL pthread_cond_timedwait (pthread_cond_t * cond,
+                                    pthread_mutex_t * mutex,
+                                    const struct timespec *abstime);
+
+PTW32_DLLPORT int PTW32_CDECL pthread_cond_signal (pthread_cond_t * cond);
+
+PTW32_DLLPORT int PTW32_CDECL pthread_cond_broadcast (pthread_cond_t * cond);
+
+/*
+ * Scheduling
+ */
+PTW32_DLLPORT int PTW32_CDECL pthread_setschedparam (pthread_t thread,
+                                   int policy,
+                                   const struct sched_param *param);
+
+PTW32_DLLPORT int PTW32_CDECL pthread_getschedparam (pthread_t thread,
+                                   int *policy,
+                                   struct sched_param *param);
+
+PTW32_DLLPORT int PTW32_CDECL pthread_setconcurrency (int);
+ 
+PTW32_DLLPORT int PTW32_CDECL pthread_getconcurrency (void);
+
+/*
+ * Read-Write Lock Functions
+ */
+PTW32_DLLPORT int PTW32_CDECL pthread_rwlock_init(pthread_rwlock_t *lock,
+                                const pthread_rwlockattr_t *attr);
+
+PTW32_DLLPORT int PTW32_CDECL pthread_rwlock_destroy(pthread_rwlock_t *lock);
+
+PTW32_DLLPORT int PTW32_CDECL pthread_rwlock_tryrdlock(pthread_rwlock_t *);
+
+PTW32_DLLPORT int PTW32_CDECL pthread_rwlock_trywrlock(pthread_rwlock_t *);
+
+PTW32_DLLPORT int PTW32_CDECL pthread_rwlock_rdlock(pthread_rwlock_t *lock);
+
+PTW32_DLLPORT int PTW32_CDECL pthread_rwlock_timedrdlock(pthread_rwlock_t *lock,
+                                       const struct timespec *abstime);
+
+PTW32_DLLPORT int PTW32_CDECL pthread_rwlock_wrlock(pthread_rwlock_t *lock);
+
+PTW32_DLLPORT int PTW32_CDECL pthread_rwlock_timedwrlock(pthread_rwlock_t *lock,
+                                       const struct timespec *abstime);
+
+PTW32_DLLPORT int PTW32_CDECL pthread_rwlock_unlock(pthread_rwlock_t *lock);
+
+PTW32_DLLPORT int PTW32_CDECL pthread_rwlockattr_init (pthread_rwlockattr_t * attr);
+
+PTW32_DLLPORT int PTW32_CDECL pthread_rwlockattr_destroy (pthread_rwlockattr_t * attr);
+
+PTW32_DLLPORT int PTW32_CDECL pthread_rwlockattr_getpshared (const pthread_rwlockattr_t * attr,
+                                           int *pshared);
+
+PTW32_DLLPORT int PTW32_CDECL pthread_rwlockattr_setpshared (pthread_rwlockattr_t * attr,
+                                           int pshared);
+
+#if PTW32_LEVEL >= PTW32_LEVEL_MAX - 1
+
+/*
+ * Signal Functions. Should be defined in <signal.h> but MSVC and MinGW32
+ * already have signal.h that don't define these.
+ */
+PTW32_DLLPORT int PTW32_CDECL pthread_kill(pthread_t thread, int sig);
+
+/*
+ * Non-portable functions
+ */
+
+/*
+ * Compatibility with Linux.
+ */
+PTW32_DLLPORT int PTW32_CDECL pthread_mutexattr_setkind_np(pthread_mutexattr_t * attr,
+                                         int kind);
+PTW32_DLLPORT int PTW32_CDECL pthread_mutexattr_getkind_np(pthread_mutexattr_t * attr,
+                                         int *kind);
+
+/*
+ * Possibly supported by other POSIX threads implementations
+ */
+PTW32_DLLPORT int PTW32_CDECL pthread_delay_np (struct timespec * interval);
+PTW32_DLLPORT int PTW32_CDECL pthread_num_processors_np(void);
+
+/*
+ * Useful if an application wants to statically link
+ * the lib rather than load the DLL at run-time.
+ */
+PTW32_DLLPORT int PTW32_CDECL pthread_win32_process_attach_np(void);
+PTW32_DLLPORT int PTW32_CDECL pthread_win32_process_detach_np(void);
+PTW32_DLLPORT int PTW32_CDECL pthread_win32_thread_attach_np(void);
+PTW32_DLLPORT int PTW32_CDECL pthread_win32_thread_detach_np(void);
+
+/*
+ * Features that are auto-detected at load/run time.
+ */
+PTW32_DLLPORT int PTW32_CDECL pthread_win32_test_features_np(int);
+enum ptw32_features {
+  PTW32_SYSTEM_INTERLOCKED_COMPARE_EXCHANGE = 0x0001, /* System provides it. */
+  PTW32_ALERTABLE_ASYNC_CANCEL              = 0x0002  /* Can cancel blocked threads. */
+};
+
+/*
+ * Register a system time change with the library.
+ * Causes the library to perform various functions
+ * in response to the change. Should be called whenever
+ * the application's top level window receives a
+ * WM_TIMECHANGE message. It can be passed directly to
+ * pthread_create() as a new thread if desired.
+ */
+PTW32_DLLPORT void * PTW32_CDECL pthread_timechange_handler_np(void *);
+
+#endif /*PTW32_LEVEL >= PTW32_LEVEL_MAX - 1 */
+
+#if PTW32_LEVEL >= PTW32_LEVEL_MAX
+
+/*
+ * Returns the Win32 HANDLE for the POSIX thread.
+ */
+PTW32_DLLPORT HANDLE PTW32_CDECL pthread_getw32threadhandle_np(pthread_t thread);
+
+
+/*
+ * Protected Methods
+ *
+ * This function blocks until the given WIN32 handle
+ * is signaled or pthread_cancel had been called.
+ * This function allows the caller to hook into the
+ * PThreads cancel mechanism. It is implemented using
+ *
+ *              WaitForMultipleObjects
+ *
+ * on 'waitHandle' and a manually reset WIN32 Event
+ * used to implement pthread_cancel. The 'timeout'
+ * argument to TimedWait is simply passed to
+ * WaitForMultipleObjects.
+ */
+PTW32_DLLPORT int PTW32_CDECL pthreadCancelableWait (HANDLE waitHandle);
+PTW32_DLLPORT int PTW32_CDECL pthreadCancelableTimedWait (HANDLE waitHandle,
+                                        DWORD timeout);
+
+#endif /* PTW32_LEVEL >= PTW32_LEVEL_MAX */
+
+/*
+ * Thread-Safe C Runtime Library Mappings.
+ */
+#ifndef _UWIN
+#  if defined(NEED_ERRNO)
+     PTW32_DLLPORT int * PTW32_CDECL _errno( void );
+#  else
+#    ifndef errno
+#      if (defined(_MT) || defined(_DLL))
+         __declspec(dllimport) extern int * __cdecl _errno(void);
+#        define errno   (*_errno())
+#      endif
+#    endif
+#  endif
+#endif
+
+/*
+ * WIN32 C runtime library had been made thread-safe
+ * without affecting the user interface. Provide
+ * mappings from the UNIX thread-safe versions to
+ * the standard C runtime library calls.
+ * Only provide function mappings for functions that
+ * actually exist on WIN32.
+ */
+
+#if !defined(__MINGW32__)
+#define strtok_r( _s, _sep, _lasts ) \
+        ( *(_lasts) = strtok( (_s), (_sep) ) )
+#endif /* !__MINGW32__ */
+
+#define asctime_r( _tm, _buf ) \
+        ( strcpy( (_buf), asctime( (_tm) ) ), \
+          (_buf) )
+
+#define ctime_r( _clock, _buf ) \
+        ( strcpy( (_buf), ctime( (_clock) ) ),  \
+          (_buf) )
+
+#define gmtime_r( _clock, _result ) \
+        ( *(_result) = *gmtime( (_clock) ), \
+          (_result) )
+
+#define localtime_r( _clock, _result ) \
+        ( *(_result) = *localtime( (_clock) ), \
+          (_result) )
+
+#define rand_r( _seed ) \
+        ( _seed == _seed? rand() : rand() )
+
+
+/*
+ * Some compiler environments don't define some things.
+ */
+#if defined(__BORLANDC__)
+#  define _ftime ftime
+#  define _timeb timeb
+#endif
+
+#ifdef __cplusplus
+
+/*
+ * Internal exceptions
+ */
+class ptw32_exception {};
+class ptw32_exception_cancel : public ptw32_exception {};
+class ptw32_exception_exit   : public ptw32_exception {};
+
+#endif
+
+#if PTW32_LEVEL >= PTW32_LEVEL_MAX
+
+/* FIXME: This is only required if the library was built using SEH */
+/*
+ * Get internal SEH tag
+ */
+PTW32_DLLPORT DWORD PTW32_CDECL ptw32_get_exception_services_code(void);
+
+#endif /* PTW32_LEVEL >= PTW32_LEVEL_MAX */
+
+#ifndef PTW32_BUILD
+
+#ifdef __CLEANUP_SEH
+
+/*
+ * Redefine the SEH __except keyword to ensure that applications
+ * propagate our internal exceptions up to the library's internal handlers.
+ */
+#define __except( E ) \
+        __except( ( GetExceptionCode() == ptw32_get_exception_services_code() ) \
+                 ? EXCEPTION_CONTINUE_SEARCH : ( E ) )
+
+#endif /* __CLEANUP_SEH */
+
+#ifdef __CLEANUP_CXX
+
+/*
+ * Redefine the C++ catch keyword to ensure that applications
+ * propagate our internal exceptions up to the library's internal handlers.
+ */
+#ifdef _MSC_VER
+        /*
+         * WARNING: Replace any 'catch( ... )' with 'PtW32CatchAll'
+         * if you want Pthread-Win32 cancelation and pthread_exit to work.
+         */
+
+#ifndef PtW32NoCatchWarn
+
+#pragma message("Specify \"/DPtW32NoCatchWarn\" compiler flag to skip this message.")
+#pragma message("------------------------------------------------------------------")
+#pragma message("When compiling applications with MSVC++ and C++ exception handling:")
+#pragma message("  Replace any 'catch( ... )' in routines called from POSIX threads")
+#pragma message("  with 'PtW32CatchAll' or 'CATCHALL' if you want POSIX thread")
+#pragma message("  cancelation and pthread_exit to work. For example:")
+#pragma message("")
+#pragma message("    #ifdef PtW32CatchAll")
+#pragma message("      PtW32CatchAll")
+#pragma message("    #else")
+#pragma message("      catch(...)")
+#pragma message("    #endif")
+#pragma message("        {")
+#pragma message("          /* Catchall block processing */")
+#pragma message("        }")
+#pragma message("------------------------------------------------------------------")
+
+#endif
+
+#define PtW32CatchAll \
+        catch( ptw32_exception & ) { throw; } \
+        catch( ... )
+
+#else /* _MSC_VER */
+
+#define catch( E ) \
+        catch( ptw32_exception & ) { throw; } \
+        catch( E )
+
+#endif /* _MSC_VER */
+
+#endif /* __CLEANUP_CXX */
+
+#endif /* ! PTW32_BUILD */
+
+#ifdef __cplusplus
+}                               /* End of extern "C" */
+#endif                          /* __cplusplus */
+
+#ifdef PTW32__HANDLE_DEF
+# undef HANDLE
+#endif
+#ifdef PTW32__DWORD_DEF
+# undef DWORD
+#endif
+
+#undef PTW32_LEVEL
+#undef PTW32_LEVEL_MAX
+
+#endif /* ! RC_INVOKED */
+
+#endif /* PTHREAD_H */
diff -ur a/win32/pthread/sched.h b/win32/pthread/sched.h
--- a/win32/pthread/sched.h	2011-03-11 16:49:19.000000000 +0200
+++ b/win32/pthread/sched.h	2017-12-07 23:26:02.688855373 +0200
@@ -1,178 +1,178 @@
-/*
- * Module: sched.h
- *
- * Purpose:
- *      Provides an implementation of POSIX realtime extensions
- *      as defined in 
- *
- *              POSIX 1003.1b-1993      (POSIX.1b)
- *
- * --------------------------------------------------------------------------
- *
- *      Pthreads-win32 - POSIX Threads Library for Win32
- *      Copyright(C) 1998 John E. Bossom
- *      Copyright(C) 1999,2005 Pthreads-win32 contributors
- * 
- *      Contact Email: rpj@callisto.canberra.edu.au
- * 
- *      The current list of contributors is contained
- *      in the file CONTRIBUTORS included with the source
- *      code distribution. The list can also be seen at the
- *      following World Wide Web location:
- *      http://sources.redhat.com/pthreads-win32/contributors.html
- * 
- *      This library is free software; you can redistribute it and/or
- *      modify it under the terms of the GNU Lesser General Public
- *      License as published by the Free Software Foundation; either
- *      version 2 of the License, or (at your option) any later version.
- * 
- *      This library is distributed in the hope that it will be useful,
- *      but WITHOUT ANY WARRANTY; without even the implied warranty of
- *      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- *      Lesser General Public License for more details.
- * 
- *      You should have received a copy of the GNU Lesser General Public
- *      License along with this library in the file COPYING.LIB;
- *      if not, write to the Free Software Foundation, Inc.,
- *      59 Temple Place - Suite 330, Boston, MA 02111-1307, USA
- */
-#ifndef _SCHED_H
-#define _SCHED_H
-
-#undef PTW32_LEVEL
-
-#if defined(_POSIX_SOURCE)
-#define PTW32_LEVEL 0
-/* Early POSIX */
-#endif
-
-#if defined(_POSIX_C_SOURCE) && _POSIX_C_SOURCE >= 199309
-#undef PTW32_LEVEL
-#define PTW32_LEVEL 1
-/* Include 1b, 1c and 1d */
-#endif
-
-#if defined(INCLUDE_NP)
-#undef PTW32_LEVEL
-#define PTW32_LEVEL 2
-/* Include Non-Portable extensions */
-#endif
-
-#define PTW32_LEVEL_MAX 3
-
-#if !defined(PTW32_LEVEL)
-#define PTW32_LEVEL PTW32_LEVEL_MAX
-/* Include everything */
-#endif
-
-
-#if __GNUC__ && ! defined (__declspec)
-# error Please upgrade your GNU compiler to one that supports __declspec.
-#endif
-
-/*
- * When building the DLL code, you should define PTW32_BUILD so that
- * the variables/functions are exported correctly. When using the DLL,
- * do NOT define PTW32_BUILD, and then the variables/functions will
- * be imported correctly.
- */
-#ifndef PTW32_STATIC_LIB
-#  ifdef PTW32_BUILD
-#    define PTW32_DLLPORT __declspec (dllexport)
-#  else
-#    define PTW32_DLLPORT __declspec (dllimport)
-#  endif
-#else
-#  define PTW32_DLLPORT
-#endif
-
-/*
- * This is a duplicate of what is in the autoconf config.h,
- * which is only used when building the pthread-win32 libraries.
- */
-
-#ifndef PTW32_CONFIG_H
-#  if defined(WINCE)
-#    define NEED_ERRNO
-#    define NEED_SEM
-#  endif
-#  if defined(_UWIN) || defined(__MINGW32__)
-#    define HAVE_MODE_T
-#  endif
-#endif
-
-/*
- *
- */
-
-#if PTW32_LEVEL >= PTW32_LEVEL_MAX
-#ifdef NEED_ERRNO
-#include "need_errno.h"
-#else
-#include <errno.h>
-#endif
-#endif /* PTW32_LEVEL >= PTW32_LEVEL_MAX */
-
-#if defined(__MINGW32__) || defined(_UWIN)
-#if PTW32_LEVEL >= PTW32_LEVEL_MAX
-/* For pid_t */
-#  include <sys/types.h>
-/* Required by Unix 98 */
-#  include <time.h>
-#endif /* PTW32_LEVEL >= PTW32_LEVEL_MAX */
-#else
-typedef int pid_t;
-#endif
-
-/* Thread scheduling policies */
-
-enum {
-  SCHED_OTHER = 0,
-  SCHED_FIFO,
-  SCHED_RR,
-  SCHED_MIN   = SCHED_OTHER,
-  SCHED_MAX   = SCHED_RR
-};
-
-struct sched_param {
-  int sched_priority;
-};
-
-#ifdef __cplusplus
-extern "C"
-{
-#endif                          /* __cplusplus */
-
-PTW32_DLLPORT int __cdecl sched_yield (void);
-
-PTW32_DLLPORT int __cdecl sched_get_priority_min (int policy);
-
-PTW32_DLLPORT int __cdecl sched_get_priority_max (int policy);
-
-PTW32_DLLPORT int __cdecl sched_setscheduler (pid_t pid, int policy);
-
-PTW32_DLLPORT int __cdecl sched_getscheduler (pid_t pid);
-
-/*
- * Note that this macro returns ENOTSUP rather than
- * ENOSYS as might be expected. However, returning ENOSYS
- * should mean that sched_get_priority_{min,max} are
- * not implemented as well as sched_rr_get_interval.
- * This is not the case, since we just don't support
- * round-robin scheduling. Therefore I have chosen to
- * return the same value as sched_setscheduler when
- * SCHED_RR is passed to it.
- */
-#define sched_rr_get_interval(_pid, _interval) \
-  ( errno = ENOTSUP, (int) -1 )
-
-
-#ifdef __cplusplus
-}                               /* End of extern "C" */
-#endif                          /* __cplusplus */
-
-#undef PTW32_LEVEL
-#undef PTW32_LEVEL_MAX
-
-#endif                          /* !_SCHED_H */
-
+/*
+ * Module: sched.h
+ *
+ * Purpose:
+ *      Provides an implementation of POSIX realtime extensions
+ *      as defined in 
+ *
+ *              POSIX 1003.1b-1993      (POSIX.1b)
+ *
+ * --------------------------------------------------------------------------
+ *
+ *      Pthreads-win32 - POSIX Threads Library for Win32
+ *      Copyright(C) 1998 John E. Bossom
+ *      Copyright(C) 1999,2005 Pthreads-win32 contributors
+ * 
+ *      Contact Email: rpj@callisto.canberra.edu.au
+ * 
+ *      The current list of contributors is contained
+ *      in the file CONTRIBUTORS included with the source
+ *      code distribution. The list can also be seen at the
+ *      following World Wide Web location:
+ *      http://sources.redhat.com/pthreads-win32/contributors.html
+ * 
+ *      This library is free software; you can redistribute it and/or
+ *      modify it under the terms of the GNU Lesser General Public
+ *      License as published by the Free Software Foundation; either
+ *      version 2 of the License, or (at your option) any later version.
+ * 
+ *      This library is distributed in the hope that it will be useful,
+ *      but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *      Lesser General Public License for more details.
+ * 
+ *      You should have received a copy of the GNU Lesser General Public
+ *      License along with this library in the file COPYING.LIB;
+ *      if not, write to the Free Software Foundation, Inc.,
+ *      59 Temple Place - Suite 330, Boston, MA 02111-1307, USA
+ */
+#ifndef _SCHED_H
+#define _SCHED_H
+
+#undef PTW32_LEVEL
+
+#if defined(_POSIX_SOURCE)
+#define PTW32_LEVEL 0
+/* Early POSIX */
+#endif
+
+#if defined(_POSIX_C_SOURCE) && _POSIX_C_SOURCE >= 199309
+#undef PTW32_LEVEL
+#define PTW32_LEVEL 1
+/* Include 1b, 1c and 1d */
+#endif
+
+#if defined(INCLUDE_NP)
+#undef PTW32_LEVEL
+#define PTW32_LEVEL 2
+/* Include Non-Portable extensions */
+#endif
+
+#define PTW32_LEVEL_MAX 3
+
+#if !defined(PTW32_LEVEL)
+#define PTW32_LEVEL PTW32_LEVEL_MAX
+/* Include everything */
+#endif
+
+
+#if __GNUC__ && ! defined (__declspec)
+# error Please upgrade your GNU compiler to one that supports __declspec.
+#endif
+
+/*
+ * When building the DLL code, you should define PTW32_BUILD so that
+ * the variables/functions are exported correctly. When using the DLL,
+ * do NOT define PTW32_BUILD, and then the variables/functions will
+ * be imported correctly.
+ */
+#ifndef PTW32_STATIC_LIB
+#  ifdef PTW32_BUILD
+#    define PTW32_DLLPORT __declspec (dllexport)
+#  else
+#    define PTW32_DLLPORT __declspec (dllimport)
+#  endif
+#else
+#  define PTW32_DLLPORT
+#endif
+
+/*
+ * This is a duplicate of what is in the autoconf config.h,
+ * which is only used when building the pthread-win32 libraries.
+ */
+
+#ifndef PTW32_CONFIG_H
+#  if defined(WINCE)
+#    define NEED_ERRNO
+#    define NEED_SEM
+#  endif
+#  if defined(_UWIN) || defined(__MINGW32__)
+#    define HAVE_MODE_T
+#  endif
+#endif
+
+/*
+ *
+ */
+
+#if PTW32_LEVEL >= PTW32_LEVEL_MAX
+#ifdef NEED_ERRNO
+#include "need_errno.h"
+#else
+#include <errno.h>
+#endif
+#endif /* PTW32_LEVEL >= PTW32_LEVEL_MAX */
+
+#if defined(__MINGW32__) || defined(_UWIN)
+#if PTW32_LEVEL >= PTW32_LEVEL_MAX
+/* For pid_t */
+#  include <sys/types.h>
+/* Required by Unix 98 */
+#  include <time.h>
+#endif /* PTW32_LEVEL >= PTW32_LEVEL_MAX */
+#else
+typedef int pid_t;
+#endif
+
+/* Thread scheduling policies */
+
+enum {
+  SCHED_OTHER = 0,
+  SCHED_FIFO,
+  SCHED_RR,
+  SCHED_MIN   = SCHED_OTHER,
+  SCHED_MAX   = SCHED_RR
+};
+
+struct sched_param {
+  int sched_priority;
+};
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif                          /* __cplusplus */
+
+PTW32_DLLPORT int __cdecl sched_yield (void);
+
+PTW32_DLLPORT int __cdecl sched_get_priority_min (int policy);
+
+PTW32_DLLPORT int __cdecl sched_get_priority_max (int policy);
+
+PTW32_DLLPORT int __cdecl sched_setscheduler (pid_t pid, int policy);
+
+PTW32_DLLPORT int __cdecl sched_getscheduler (pid_t pid);
+
+/*
+ * Note that this macro returns ENOTSUP rather than
+ * ENOSYS as might be expected. However, returning ENOSYS
+ * should mean that sched_get_priority_{min,max} are
+ * not implemented as well as sched_rr_get_interval.
+ * This is not the case, since we just don't support
+ * round-robin scheduling. Therefore I have chosen to
+ * return the same value as sched_setscheduler when
+ * SCHED_RR is passed to it.
+ */
+#define sched_rr_get_interval(_pid, _interval) \
+  ( errno = ENOTSUP, (int) -1 )
+
+
+#ifdef __cplusplus
+}                               /* End of extern "C" */
+#endif                          /* __cplusplus */
+
+#undef PTW32_LEVEL
+#undef PTW32_LEVEL_MAX
+
+#endif                          /* !_SCHED_H */
+
diff -ur a/win32/pthread/semaphore.h b/win32/pthread/semaphore.h
--- a/win32/pthread/semaphore.h	2011-03-11 16:49:19.000000000 +0200
+++ b/win32/pthread/semaphore.h	2017-12-07 23:26:02.692855394 +0200
@@ -1,166 +1,166 @@
-/*
- * Module: semaphore.h
- *
- * Purpose:
- *	Semaphores aren't actually part of the PThreads standard.
- *	They are defined by the POSIX Standard:
- *
- *		POSIX 1003.1b-1993	(POSIX.1b)
- *
- * --------------------------------------------------------------------------
- *
- *      Pthreads-win32 - POSIX Threads Library for Win32
- *      Copyright(C) 1998 John E. Bossom
- *      Copyright(C) 1999,2005 Pthreads-win32 contributors
- * 
- *      Contact Email: rpj@callisto.canberra.edu.au
- * 
- *      The current list of contributors is contained
- *      in the file CONTRIBUTORS included with the source
- *      code distribution. The list can also be seen at the
- *      following World Wide Web location:
- *      http://sources.redhat.com/pthreads-win32/contributors.html
- * 
- *      This library is free software; you can redistribute it and/or
- *      modify it under the terms of the GNU Lesser General Public
- *      License as published by the Free Software Foundation; either
- *      version 2 of the License, or (at your option) any later version.
- * 
- *      This library is distributed in the hope that it will be useful,
- *      but WITHOUT ANY WARRANTY; without even the implied warranty of
- *      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- *      Lesser General Public License for more details.
- * 
- *      You should have received a copy of the GNU Lesser General Public
- *      License along with this library in the file COPYING.LIB;
- *      if not, write to the Free Software Foundation, Inc.,
- *      59 Temple Place - Suite 330, Boston, MA 02111-1307, USA
- */
-#if !defined( SEMAPHORE_H )
-#define SEMAPHORE_H
-
-#undef PTW32_LEVEL
-
-#if defined(_POSIX_SOURCE)
-#define PTW32_LEVEL 0
-/* Early POSIX */
-#endif
-
-#if defined(_POSIX_C_SOURCE) && _POSIX_C_SOURCE >= 199309
-#undef PTW32_LEVEL
-#define PTW32_LEVEL 1
-/* Include 1b, 1c and 1d */
-#endif
-
-#if defined(INCLUDE_NP)
-#undef PTW32_LEVEL
-#define PTW32_LEVEL 2
-/* Include Non-Portable extensions */
-#endif
-
-#define PTW32_LEVEL_MAX 3
-
-#if !defined(PTW32_LEVEL)
-#define PTW32_LEVEL PTW32_LEVEL_MAX
-/* Include everything */
-#endif
-
-#if __GNUC__ && ! defined (__declspec)
-# error Please upgrade your GNU compiler to one that supports __declspec.
-#endif
-
-/*
- * When building the DLL code, you should define PTW32_BUILD so that
- * the variables/functions are exported correctly. When using the DLL,
- * do NOT define PTW32_BUILD, and then the variables/functions will
- * be imported correctly.
- */
-#ifndef PTW32_STATIC_LIB
-#  ifdef PTW32_BUILD
-#    define PTW32_DLLPORT __declspec (dllexport)
-#  else
-#    define PTW32_DLLPORT __declspec (dllimport)
-#  endif
-#else
-#  define PTW32_DLLPORT
-#endif
-
-/*
- * This is a duplicate of what is in the autoconf config.h,
- * which is only used when building the pthread-win32 libraries.
- */
-
-#ifndef PTW32_CONFIG_H
-#  if defined(WINCE)
-#    define NEED_ERRNO
-#    define NEED_SEM
-#  endif
-#  if defined(_UWIN) || defined(__MINGW32__)
-#    define HAVE_MODE_T
-#  endif
-#endif
-
-/*
- *
- */
-
-#if PTW32_LEVEL >= PTW32_LEVEL_MAX
-#ifdef NEED_ERRNO
-#include "need_errno.h"
-#else
-#include <errno.h>
-#endif
-#endif /* PTW32_LEVEL >= PTW32_LEVEL_MAX */
-
-#define _POSIX_SEMAPHORES
-
-#ifdef __cplusplus
-extern "C"
-{
-#endif				/* __cplusplus */
-
-#ifndef HAVE_MODE_T
-typedef unsigned int mode_t;
-#endif
-
-
-typedef struct sem_t_ * sem_t;
-
-PTW32_DLLPORT int __cdecl sem_init (sem_t * sem,
-			    int pshared,
-			    unsigned int value);
-
-PTW32_DLLPORT int __cdecl sem_destroy (sem_t * sem);
-
-PTW32_DLLPORT int __cdecl sem_trywait (sem_t * sem);
-
-PTW32_DLLPORT int __cdecl sem_wait (sem_t * sem);
-
-PTW32_DLLPORT int __cdecl sem_timedwait (sem_t * sem,
-				 const struct timespec * abstime);
-
-PTW32_DLLPORT int __cdecl sem_post (sem_t * sem);
-
-PTW32_DLLPORT int __cdecl sem_post_multiple (sem_t * sem,
-				     int count);
-
-PTW32_DLLPORT int __cdecl sem_open (const char * name,
-			    int oflag,
-			    mode_t mode,
-			    unsigned int value);
-
-PTW32_DLLPORT int __cdecl sem_close (sem_t * sem);
-
-PTW32_DLLPORT int __cdecl sem_unlink (const char * name);
-
-PTW32_DLLPORT int __cdecl sem_getvalue (sem_t * sem,
-				int * sval);
-
-#ifdef __cplusplus
-}				/* End of extern "C" */
-#endif				/* __cplusplus */
-
-#undef PTW32_LEVEL
-#undef PTW32_LEVEL_MAX
-
-#endif				/* !SEMAPHORE_H */
+/*
+ * Module: semaphore.h
+ *
+ * Purpose:
+ *	Semaphores aren't actually part of the PThreads standard.
+ *	They are defined by the POSIX Standard:
+ *
+ *		POSIX 1003.1b-1993	(POSIX.1b)
+ *
+ * --------------------------------------------------------------------------
+ *
+ *      Pthreads-win32 - POSIX Threads Library for Win32
+ *      Copyright(C) 1998 John E. Bossom
+ *      Copyright(C) 1999,2005 Pthreads-win32 contributors
+ * 
+ *      Contact Email: rpj@callisto.canberra.edu.au
+ * 
+ *      The current list of contributors is contained
+ *      in the file CONTRIBUTORS included with the source
+ *      code distribution. The list can also be seen at the
+ *      following World Wide Web location:
+ *      http://sources.redhat.com/pthreads-win32/contributors.html
+ * 
+ *      This library is free software; you can redistribute it and/or
+ *      modify it under the terms of the GNU Lesser General Public
+ *      License as published by the Free Software Foundation; either
+ *      version 2 of the License, or (at your option) any later version.
+ * 
+ *      This library is distributed in the hope that it will be useful,
+ *      but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *      Lesser General Public License for more details.
+ * 
+ *      You should have received a copy of the GNU Lesser General Public
+ *      License along with this library in the file COPYING.LIB;
+ *      if not, write to the Free Software Foundation, Inc.,
+ *      59 Temple Place - Suite 330, Boston, MA 02111-1307, USA
+ */
+#if !defined( SEMAPHORE_H )
+#define SEMAPHORE_H
+
+#undef PTW32_LEVEL
+
+#if defined(_POSIX_SOURCE)
+#define PTW32_LEVEL 0
+/* Early POSIX */
+#endif
+
+#if defined(_POSIX_C_SOURCE) && _POSIX_C_SOURCE >= 199309
+#undef PTW32_LEVEL
+#define PTW32_LEVEL 1
+/* Include 1b, 1c and 1d */
+#endif
+
+#if defined(INCLUDE_NP)
+#undef PTW32_LEVEL
+#define PTW32_LEVEL 2
+/* Include Non-Portable extensions */
+#endif
+
+#define PTW32_LEVEL_MAX 3
+
+#if !defined(PTW32_LEVEL)
+#define PTW32_LEVEL PTW32_LEVEL_MAX
+/* Include everything */
+#endif
+
+#if __GNUC__ && ! defined (__declspec)
+# error Please upgrade your GNU compiler to one that supports __declspec.
+#endif
+
+/*
+ * When building the DLL code, you should define PTW32_BUILD so that
+ * the variables/functions are exported correctly. When using the DLL,
+ * do NOT define PTW32_BUILD, and then the variables/functions will
+ * be imported correctly.
+ */
+#ifndef PTW32_STATIC_LIB
+#  ifdef PTW32_BUILD
+#    define PTW32_DLLPORT __declspec (dllexport)
+#  else
+#    define PTW32_DLLPORT __declspec (dllimport)
+#  endif
+#else
+#  define PTW32_DLLPORT
+#endif
+
+/*
+ * This is a duplicate of what is in the autoconf config.h,
+ * which is only used when building the pthread-win32 libraries.
+ */
+
+#ifndef PTW32_CONFIG_H
+#  if defined(WINCE)
+#    define NEED_ERRNO
+#    define NEED_SEM
+#  endif
+#  if defined(_UWIN) || defined(__MINGW32__)
+#    define HAVE_MODE_T
+#  endif
+#endif
+
+/*
+ *
+ */
+
+#if PTW32_LEVEL >= PTW32_LEVEL_MAX
+#ifdef NEED_ERRNO
+#include "need_errno.h"
+#else
+#include <errno.h>
+#endif
+#endif /* PTW32_LEVEL >= PTW32_LEVEL_MAX */
+
+#define _POSIX_SEMAPHORES
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif				/* __cplusplus */
+
+#ifndef HAVE_MODE_T
+typedef unsigned int mode_t;
+#endif
+
+
+typedef struct sem_t_ * sem_t;
+
+PTW32_DLLPORT int __cdecl sem_init (sem_t * sem,
+			    int pshared,
+			    unsigned int value);
+
+PTW32_DLLPORT int __cdecl sem_destroy (sem_t * sem);
+
+PTW32_DLLPORT int __cdecl sem_trywait (sem_t * sem);
+
+PTW32_DLLPORT int __cdecl sem_wait (sem_t * sem);
+
+PTW32_DLLPORT int __cdecl sem_timedwait (sem_t * sem,
+				 const struct timespec * abstime);
+
+PTW32_DLLPORT int __cdecl sem_post (sem_t * sem);
+
+PTW32_DLLPORT int __cdecl sem_post_multiple (sem_t * sem,
+				     int count);
+
+PTW32_DLLPORT int __cdecl sem_open (const char * name,
+			    int oflag,
+			    mode_t mode,
+			    unsigned int value);
+
+PTW32_DLLPORT int __cdecl sem_close (sem_t * sem);
+
+PTW32_DLLPORT int __cdecl sem_unlink (const char * name);
+
+PTW32_DLLPORT int __cdecl sem_getvalue (sem_t * sem,
+				int * sval);
+
+#ifdef __cplusplus
+}				/* End of extern "C" */
+#endif				/* __cplusplus */
+
+#undef PTW32_LEVEL
+#undef PTW32_LEVEL_MAX
+
+#endif				/* !SEMAPHORE_H */
